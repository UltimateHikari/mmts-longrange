*** contrib/mmts/../../src/test/regress/expected/enum.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/enum.out	CENSORED
***************
*** 40,45 ****
--- 40,46 ----
  (3 rows)
  
  ALTER TYPE planets ADD VALUE 'uranus';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT enumlabel, enumsortorder
  FROM pg_enum
  WHERE enumtypid = 'planets'::regtype
***************
*** 49,76 ****
   venus     |             1
   earth     |             2
   mars      |             3
!  uranus    |             4
! (4 rows)
  
  ALTER TYPE planets ADD VALUE 'mercury' BEFORE 'venus';
  ALTER TYPE planets ADD VALUE 'saturn' BEFORE 'uranus';
  ALTER TYPE planets ADD VALUE 'jupiter' AFTER 'mars';
  ALTER TYPE planets ADD VALUE 'neptune' AFTER 'uranus';
  SELECT enumlabel, enumsortorder
  FROM pg_enum
  WHERE enumtypid = 'planets'::regtype
  ORDER BY 2;
   enumlabel | enumsortorder 
  -----------+---------------
-  mercury   |             0
   venus     |             1
   earth     |             2
   mars      |             3
!  jupiter   |          3.25
!  saturn    |           3.5
!  uranus    |             4
!  neptune   |             5
! (8 rows)
  
  SELECT enumlabel, enumsortorder
  FROM pg_enum
--- 50,75 ----
   venus     |             1
   earth     |             2
   mars      |             3
! (3 rows)
  
  ALTER TYPE planets ADD VALUE 'mercury' BEFORE 'venus';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  ALTER TYPE planets ADD VALUE 'saturn' BEFORE 'uranus';
+ ERROR:  "uranus" is not an existing enum label
  ALTER TYPE planets ADD VALUE 'jupiter' AFTER 'mars';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  ALTER TYPE planets ADD VALUE 'neptune' AFTER 'uranus';
+ ERROR:  "uranus" is not an existing enum label
  SELECT enumlabel, enumsortorder
  FROM pg_enum
  WHERE enumtypid = 'planets'::regtype
  ORDER BY 2;
   enumlabel | enumsortorder 
  -----------+---------------
   venus     |             1
   earth     |             2
   mars      |             3
! (3 rows)
  
  SELECT enumlabel, enumsortorder
  FROM pg_enum
***************
*** 78,92 ****
  ORDER BY enumlabel::planets;
   enumlabel | enumsortorder 
  -----------+---------------
-  mercury   |             0
   venus     |             1
   earth     |             2
   mars      |             3
!  jupiter   |          3.25
!  saturn    |           3.5
!  uranus    |             4
!  neptune   |             5
! (8 rows)
  
  -- errors for adding labels
  ALTER TYPE planets ADD VALUE
--- 77,86 ----
  ORDER BY enumlabel::planets;
   enumlabel | enumsortorder 
  -----------+---------------
   venus     |             1
   earth     |             2
   mars      |             3
! (3 rows)
  
  -- errors for adding labels
  ALTER TYPE planets ADD VALUE
***************
*** 98,120 ****
  -- if not exists tests
  --  existing value gives error
  ALTER TYPE planets ADD VALUE 'mercury';
! ERROR:  enum label "mercury" already exists
  -- unless IF NOT EXISTS is specified
  ALTER TYPE planets ADD VALUE IF NOT EXISTS 'mercury';
! NOTICE:  enum label "mercury" already exists, skipping
  -- should be neptune, not mercury
  SELECT enum_last(NULL::planets);
   enum_last 
  -----------
!  neptune
  (1 row)
  
  ALTER TYPE planets ADD VALUE IF NOT EXISTS 'pluto';
  -- should be pluto, i.e. the new value
  SELECT enum_last(NULL::planets);
   enum_last 
  -----------
!  pluto
  (1 row)
  
  --
--- 92,115 ----
  -- if not exists tests
  --  existing value gives error
  ALTER TYPE planets ADD VALUE 'mercury';
! ERROR:  [multimaster] failed to prepare transaction at peer node
  -- unless IF NOT EXISTS is specified
  ALTER TYPE planets ADD VALUE IF NOT EXISTS 'mercury';
! ERROR:  [multimaster] failed to prepare transaction at peer node
  -- should be neptune, not mercury
  SELECT enum_last(NULL::planets);
   enum_last 
  -----------
!  mars
  (1 row)
  
  ALTER TYPE planets ADD VALUE IF NOT EXISTS 'pluto';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  -- should be pluto, i.e. the new value
  SELECT enum_last(NULL::planets);
   enum_last 
  -----------
!  mars
  (1 row)
  
  --
***************
*** 122,156 ****
--- 117,181 ----
  --
  create type insenum as enum ('L1', 'L2');
  alter type insenum add value 'i1' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i2' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i3' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i4' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i5' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i6' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i7' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i8' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i9' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i10' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i11' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i12' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i13' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i14' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i15' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i16' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i17' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i18' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i19' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i20' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i21' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i22' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i23' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i24' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i25' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i26' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i27' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i28' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i29' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter type insenum add value 'i30' before 'L2';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  -- The exact values of enumsortorder will now depend on the local properties
  -- of float4, but in any reasonable implementation we should get at least
  -- 20 splits before having to renumber; so only hide values > 20.
***************
*** 162,199 ****
   enumlabel | so 
  -----------+----
   L1        |  1
!  i1        |  2
!  i2        |  3
!  i3        |  4
!  i4        |  5
!  i5        |  6
!  i6        |  7
!  i7        |  8
!  i8        |  9
!  i9        | 10
!  i10       | 11
!  i11       | 12
!  i12       | 13
!  i13       | 14
!  i14       | 15
!  i15       | 16
!  i16       | 17
!  i17       | 18
!  i18       | 19
!  i19       | 20
!  i20       |   
!  i21       |   
!  i22       |   
!  i23       |   
!  i24       |   
!  i25       |   
!  i26       |   
!  i27       |   
!  i28       |   
!  i29       |   
!  i30       |   
!  L2        |   
! (32 rows)
  
  --
  -- Basic table creation, row selection
--- 187,194 ----
   enumlabel | so 
  -----------+----
   L1        |  1
!  L2        |  2
! (2 rows)
  
  --
  -- Basic table creation, row selection

======================================================================

*** contrib/mmts/../../src/test/regress/expected/insert.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/insert.out	CENSORED
***************
*** 695,711 ****
  set role regress_insert_other_user;
  -- no key description is shown
  insert into key_desc values (1, 1);
! ERROR:  no partition of relation "key_desc_1" found for row
  reset role;
  grant select (b) on key_desc_1 to regress_insert_other_user;
  set role regress_insert_other_user;
  -- key description (b)=(1) is now shown
  insert into key_desc values (1, 1);
! ERROR:  no partition of relation "key_desc_1" found for row
! DETAIL:  Partition key of the failing row contains (b) = (1).
  -- key description is not shown if key contains expression
  insert into key_desc values (2, 1);
! ERROR:  no partition of relation "key_desc" found for row
  reset role;
  revoke all on key_desc from regress_insert_other_user;
  revoke all on key_desc_1 from regress_insert_other_user;
--- 695,716 ----
  set role regress_insert_other_user;
  -- no key description is shown
  insert into key_desc values (1, 1);
! ERROR:  relation "key_desc" does not exist
! LINE 1: insert into key_desc values (1, 1);
!                     ^
  reset role;
  grant select (b) on key_desc_1 to regress_insert_other_user;
  set role regress_insert_other_user;
  -- key description (b)=(1) is now shown
  insert into key_desc values (1, 1);
! ERROR:  relation "key_desc" does not exist
! LINE 1: insert into key_desc values (1, 1);
!                     ^
  -- key description is not shown if key contains expression
  insert into key_desc values (2, 1);
! ERROR:  relation "key_desc" does not exist
! LINE 1: insert into key_desc values (2, 1);
!                     ^
  reset role;
  revoke all on key_desc from regress_insert_other_user;
  revoke all on key_desc_1 from regress_insert_other_user;
***************
*** 808,815 ****
  set role regress_coldesc_role;
  with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
    insert into inserttest3 (f3) select * from result;
! ERROR:  new row for relation "brtrigpartcon1" violates partition constraint
! DETAIL:  Failing row contains (a, b) = (2, hi there).
  reset role;
  -- cleanup
  revoke all on inserttest3 from regress_coldesc_role;
--- 813,821 ----
  set role regress_coldesc_role;
  with result as (insert into brtrigpartcon values (1, 'hi there') returning 1)
    insert into inserttest3 (f3) select * from result;
! ERROR:  relation "brtrigpartcon" does not exist
! LINE 1: with result as (insert into brtrigpartcon values (1, 'hi the...
!                                     ^
  reset role;
  -- cleanup
  revoke all on inserttest3 from regress_coldesc_role;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/create_table.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/create_table.out	CENSORED
***************
*** 265,281 ****
  DROP TABLE as_select1;
  PREPARE select1 AS SELECT 1 as a;
  CREATE TABLE as_select1 AS EXECUTE select1;
  CREATE TABLE as_select1 AS EXECUTE select1;
! ERROR:  relation "as_select1" already exists
  SELECT * FROM as_select1;
!  a 
! ---
!  1
! (1 row)
! 
  CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
! NOTICE:  relation "as_select1" already exists, skipping
  DROP TABLE as_select1;
  DEALLOCATE select1;
  -- create an extra wide table to test for issues related to that
  -- (temporarily hide query, to avoid the long CREATE TABLE stmt)
--- 265,281 ----
  DROP TABLE as_select1;
  PREPARE select1 AS SELECT 1 as a;
  CREATE TABLE as_select1 AS EXECUTE select1;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  CREATE TABLE as_select1 AS EXECUTE select1;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT * FROM as_select1;
! ERROR:  relation "as_select1" does not exist
! LINE 1: SELECT * FROM as_select1;
!                       ^
  CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  DROP TABLE as_select1;
+ ERROR:  table "as_select1" does not exist
  DEALLOCATE select1;
  -- create an extra wide table to test for issues related to that
  -- (temporarily hide query, to avoid the long CREATE TABLE stmt)

======================================================================

*** contrib/mmts/../../src/test/regress/expected/create_operator.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/create_operator.out	CENSORED
***************
*** 198,204 ****
     rightarg = int8,
     procedure = fn_op3
  );
! ERROR:  permission denied for type type_op3
  ROLLBACK;
  -- Should fail. CREATE OPERATOR requires USAGE on TYPE (need to check separately for rightarg)
  BEGIN TRANSACTION;
--- 198,204 ----
     rightarg = int8,
     procedure = fn_op3
  );
! ERROR:  no schema has been selected to create in
  ROLLBACK;
  -- Should fail. CREATE OPERATOR requires USAGE on TYPE (need to check separately for rightarg)
  BEGIN TRANSACTION;
***************
*** 216,222 ****
     rightarg = type_op4,
     procedure = fn_op4
  );
! ERROR:  permission denied for type type_op4
  ROLLBACK;
  -- Should fail. CREATE OPERATOR requires EXECUTE on function
  BEGIN TRANSACTION;
--- 216,222 ----
     rightarg = type_op4,
     procedure = fn_op4
  );
! ERROR:  no schema has been selected to create in
  ROLLBACK;
  -- Should fail. CREATE OPERATOR requires EXECUTE on function
  BEGIN TRANSACTION;
***************
*** 234,240 ****
     rightarg = int8,
     procedure = fn_op5
  );
! ERROR:  permission denied for function fn_op5
  ROLLBACK;
  -- Should fail. CREATE OPERATOR requires USAGE on return TYPE
  BEGIN TRANSACTION;
--- 234,240 ----
     rightarg = int8,
     procedure = fn_op5
  );
! ERROR:  no schema has been selected to create in
  ROLLBACK;
  -- Should fail. CREATE OPERATOR requires USAGE on return TYPE
  BEGIN TRANSACTION;
***************
*** 252,258 ****
     rightarg = int8,
     procedure = fn_op6
  );
! ERROR:  permission denied for type type_op6
  ROLLBACK;
  -- invalid: non-lowercase quoted identifiers
  CREATE OPERATOR ===
--- 252,258 ----
     rightarg = int8,
     procedure = fn_op6
  );
! ERROR:  no schema has been selected to create in
  ROLLBACK;
  -- invalid: non-lowercase quoted identifiers
  CREATE OPERATOR ===

======================================================================

*** contrib/mmts/../../src/test/regress/expected/create_procedure.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/create_procedure.out	CENSORED
***************
*** 190,200 ****
  REVOKE EXECUTE ON PROCEDURE ptest1(text) FROM PUBLIC;
  SET ROLE regress_cp_user1;
  CALL ptest1('a');  -- error
! ERROR:  permission denied for procedure ptest1
  RESET ROLE;
  GRANT EXECUTE ON PROCEDURE ptest1(text) TO regress_cp_user1;
  SET ROLE regress_cp_user1;
  CALL ptest1('a');  -- ok
  RESET ROLE;
  -- ROUTINE syntax
  ALTER ROUTINE cp_testfunc1(int) RENAME TO cp_testfunc1a;
--- 190,207 ----
  REVOKE EXECUTE ON PROCEDURE ptest1(text) FROM PUBLIC;
  SET ROLE regress_cp_user1;
  CALL ptest1('a');  -- error
! ERROR:  procedure ptest1(unknown) does not exist
! LINE 1: CALL ptest1('a');
!              ^
! HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
  RESET ROLE;
  GRANT EXECUTE ON PROCEDURE ptest1(text) TO regress_cp_user1;
  SET ROLE regress_cp_user1;
  CALL ptest1('a');  -- ok
+ ERROR:  procedure ptest1(unknown) does not exist
+ LINE 1: CALL ptest1('a');
+              ^
+ HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
  RESET ROLE;
  -- ROUTINE syntax
  ALTER ROUTINE cp_testfunc1(int) RENAME TO cp_testfunc1a;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/constraints.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/constraints.out	CENSORED
***************
*** 706,737 ****
  CREATE ROLE regress_constraint_comments;
  SET SESSION AUTHORIZATION regress_constraint_comments;
  CREATE TABLE constraint_comments_tbl (a int CONSTRAINT the_constraint CHECK (a > 0));
  CREATE DOMAIN constraint_comments_dom AS int CONSTRAINT the_constraint CHECK (value > 0);
  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'yes, the comment';
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
  -- no such constraint
  COMMENT ON CONSTRAINT no_constraint ON constraint_comments_tbl IS 'yes, the comment';
! ERROR:  constraint "no_constraint" for table "constraint_comments_tbl" does not exist
  COMMENT ON CONSTRAINT no_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
! ERROR:  constraint "no_constraint" for domain constraint_comments_dom does not exist
  -- no such table/domain
  COMMENT ON CONSTRAINT the_constraint ON no_comments_tbl IS 'bad comment';
  ERROR:  relation "no_comments_tbl" does not exist
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN no_comments_dom IS 'another bad comment';
  ERROR:  type "no_comments_dom" does not exist
  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS NULL;
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS NULL;
  -- unauthorized user
  RESET SESSION AUTHORIZATION;
  CREATE ROLE regress_constraint_comments_noaccess;
  SET SESSION AUTHORIZATION regress_constraint_comments_noaccess;
  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'no, the comment';
! ERROR:  must be owner of relation constraint_comments_tbl
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'no, another comment';
! ERROR:  must be owner of type constraint_comments_dom
  RESET SESSION AUTHORIZATION;
  DROP TABLE constraint_comments_tbl;
  DROP DOMAIN constraint_comments_dom;
  -- ALTER CONSTRAINT ... USING INDEX
  CREATE TABLE constraint_alter_index (a int CONSTRAINT must_be_different UNIQUE NOT NULL, b int);
  INSERT INTO  constraint_alter_index VALUES(1, 1);
--- 706,747 ----
  CREATE ROLE regress_constraint_comments;
  SET SESSION AUTHORIZATION regress_constraint_comments;
  CREATE TABLE constraint_comments_tbl (a int CONSTRAINT the_constraint CHECK (a > 0));
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE constraint_comments_tbl (a int CONSTRAINT the_c...
+                      ^
  CREATE DOMAIN constraint_comments_dom AS int CONSTRAINT the_constraint CHECK (value > 0);
+ ERROR:  no schema has been selected to create in
  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'yes, the comment';
+ ERROR:  relation "constraint_comments_tbl" does not exist
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
+ ERROR:  type "constraint_comments_dom" does not exist
  -- no such constraint
  COMMENT ON CONSTRAINT no_constraint ON constraint_comments_tbl IS 'yes, the comment';
! ERROR:  relation "constraint_comments_tbl" does not exist
  COMMENT ON CONSTRAINT no_constraint ON DOMAIN constraint_comments_dom IS 'yes, another comment';
! ERROR:  type "constraint_comments_dom" does not exist
  -- no such table/domain
  COMMENT ON CONSTRAINT the_constraint ON no_comments_tbl IS 'bad comment';
  ERROR:  relation "no_comments_tbl" does not exist
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN no_comments_dom IS 'another bad comment';
  ERROR:  type "no_comments_dom" does not exist
  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS NULL;
+ ERROR:  relation "constraint_comments_tbl" does not exist
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS NULL;
+ ERROR:  type "constraint_comments_dom" does not exist
  -- unauthorized user
  RESET SESSION AUTHORIZATION;
  CREATE ROLE regress_constraint_comments_noaccess;
  SET SESSION AUTHORIZATION regress_constraint_comments_noaccess;
  COMMENT ON CONSTRAINT the_constraint ON constraint_comments_tbl IS 'no, the comment';
! ERROR:  relation "constraint_comments_tbl" does not exist
  COMMENT ON CONSTRAINT the_constraint ON DOMAIN constraint_comments_dom IS 'no, another comment';
! ERROR:  type "constraint_comments_dom" does not exist
  RESET SESSION AUTHORIZATION;
  DROP TABLE constraint_comments_tbl;
+ ERROR:  table "constraint_comments_tbl" does not exist
  DROP DOMAIN constraint_comments_dom;
+ ERROR:  type "constraint_comments_dom" does not exist
  -- ALTER CONSTRAINT ... USING INDEX
  CREATE TABLE constraint_alter_index (a int CONSTRAINT must_be_different UNIQUE NOT NULL, b int);
  INSERT INTO  constraint_alter_index VALUES(1, 1);

======================================================================

*** contrib/mmts/../../src/test/regress/expected/updatable_views.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/updatable_views.out	CENSORED
***************
*** 958,1187 ****
  CREATE USER regress_view_user2;
  SET SESSION AUTHORIZATION regress_view_user1;
  CREATE TABLE base_tbl(a int, b text, c float);
  INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
  CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
  INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
  GRANT SELECT ON base_tbl TO regress_view_user2;
  GRANT SELECT ON rw_view1 TO regress_view_user2;
  GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
  GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user2;
  CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
  SELECT * FROM base_tbl; -- ok
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
!  2 | Row 2 | 2
! (2 rows)
! 
  SELECT * FROM rw_view1; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
  SELECT * FROM rw_view2; -- ok
!   bb   | cc | aa 
! -------+----+----
!  Row 1 |  1 |  1
!  Row 2 |  2 |  2
! (2 rows)
! 
  INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowed
! ERROR:  permission denied for table base_tbl
  INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for view rw_view1
  INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  permission denied for table base_tbl
  UPDATE base_tbl SET a=a, c=c; -- ok
  UPDATE base_tbl SET b=b; -- not allowed
! ERROR:  permission denied for table base_tbl
  UPDATE rw_view1 SET bb=bb, cc=cc; -- ok
  UPDATE rw_view1 SET aa=aa; -- not allowed
! ERROR:  permission denied for view rw_view1
  UPDATE rw_view2 SET aa=aa, cc=cc; -- ok
  UPDATE rw_view2 SET bb=bb; -- not allowed
! ERROR:  permission denied for table base_tbl
  DELETE FROM base_tbl; -- not allowed
! ERROR:  permission denied for table base_tbl
  DELETE FROM rw_view1; -- not allowed
! ERROR:  permission denied for view rw_view1
  DELETE FROM rw_view2; -- not allowed
! ERROR:  permission denied for table base_tbl
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user1;
  GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user2;
  INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- ok
  INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowed
! ERROR:  permission denied for view rw_view1
  INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- ok
  DELETE FROM base_tbl WHERE a=1; -- ok
  DELETE FROM rw_view1 WHERE aa=2; -- not allowed
! ERROR:  permission denied for view rw_view1
  DELETE FROM rw_view2 WHERE aa=2; -- ok
  SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  3 | Row 3 | 3
!  4 | Row 4 | 4
! (2 rows)
! 
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user1;
  REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
  GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user2;
  INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowed
! ERROR:  permission denied for table base_tbl
  INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- ok
  INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowed
! ERROR:  permission denied for table base_tbl
  DELETE FROM base_tbl WHERE a=3; -- not allowed
! ERROR:  permission denied for table base_tbl
  DELETE FROM rw_view1 WHERE aa=3; -- ok
  DELETE FROM rw_view2 WHERE aa=4; -- not allowed
! ERROR:  permission denied for table base_tbl
  SELECT * FROM base_tbl;
!  a |   b   | c 
! ---+-------+---
!  4 | Row 4 | 4
!  5 | Row 5 | 5
! (2 rows)
! 
  RESET SESSION AUTHORIZATION;
  DROP TABLE base_tbl CASCADE;
! NOTICE:  drop cascades to 2 other objects
! DETAIL:  drop cascades to view rw_view1
! drop cascades to view rw_view2
  -- nested-view permissions
  CREATE TABLE base_tbl(a int, b text, c float);
  INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
  SET SESSION AUTHORIZATION regress_view_user1;
  CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
  SELECT * FROM rw_view1;  -- not allowed
! ERROR:  permission denied for table base_tbl
  SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for table base_tbl
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for table base_tbl
  SET SESSION AUTHORIZATION regress_view_user2;
  CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
  SELECT * FROM rw_view2;  -- not allowed
! ERROR:  permission denied for view rw_view1
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for view rw_view1
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for view rw_view1
  RESET SESSION AUTHORIZATION;
  GRANT SELECT ON base_tbl TO regress_view_user1;
  SET SESSION AUTHORIZATION regress_view_user1;
  SELECT * FROM rw_view1;
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
! (1 row)
! 
  SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for table base_tbl
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for table base_tbl
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;  -- not allowed
! ERROR:  permission denied for view rw_view1
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for view rw_view1
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for view rw_view1
  SET SESSION AUTHORIZATION regress_view_user1;
  GRANT SELECT ON rw_view1 TO regress_view_user2;
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
! (1 row)
! 
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for view rw_view1
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for view rw_view1
  RESET SESSION AUTHORIZATION;
  GRANT UPDATE ON base_tbl TO regress_view_user1;
  SET SESSION AUTHORIZATION regress_view_user1;
  SELECT * FROM rw_view1;
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
! (1 row)
! 
  SELECT * FROM rw_view1 FOR UPDATE;
!  a |   b   | c 
! ---+-------+---
!  1 | Row 1 | 1
! (1 row)
! 
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 1
! (1 row)
! 
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for view rw_view1
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for view rw_view1
  SET SESSION AUTHORIZATION regress_view_user1;
  GRANT UPDATE ON rw_view1 TO regress_view_user2;
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 1
! (1 row)
! 
  SELECT * FROM rw_view2 FOR UPDATE;
!  a |  b  | c 
! ---+-----+---
!  1 | foo | 1
! (1 row)
! 
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
  RESET SESSION AUTHORIZATION;
  REVOKE UPDATE ON base_tbl FROM regress_view_user1;
  SET SESSION AUTHORIZATION regress_view_user1;
  SELECT * FROM rw_view1;
!  a |  b  | c 
! ---+-----+---
!  1 | bar | 1
! (1 row)
! 
  SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for table base_tbl
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for table base_tbl
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
!  a |  b  | c 
! ---+-----+---
!  1 | bar | 1
! (1 row)
! 
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  permission denied for table base_tbl
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  permission denied for table base_tbl
  RESET SESSION AUTHORIZATION;
  DROP TABLE base_tbl CASCADE;
- NOTICE:  drop cascades to 2 other objects
- DETAIL:  drop cascades to view rw_view1
- drop cascades to view rw_view2
  DROP USER regress_view_user1;
  DROP USER regress_view_user2;
  -- column defaults
--- 958,1280 ----
  CREATE USER regress_view_user2;
  SET SESSION AUTHORIZATION regress_view_user1;
  CREATE TABLE base_tbl(a int, b text, c float);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE base_tbl(a int, b text, c float);
+                      ^
  INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
+                     ^
  CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: ... rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+                                                               ^
  INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
+                     ^
  GRANT SELECT ON base_tbl TO regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  GRANT SELECT ON rw_view1 TO regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user2;
  CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: ... rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
+                                                               ^
  SELECT * FROM base_tbl; -- ok
! ERROR:  relation "base_tbl" does not exist
! LINE 1: SELECT * FROM base_tbl;
!                       ^
  SELECT * FROM rw_view1; -- ok
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1;
!                       ^
  SELECT * FROM rw_view2; -- ok
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- not allowed
! ERROR:  relation "base_tbl" does not exist
! LINE 1: INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
!                     ^
  INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
!                     ^
  INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3); -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3);
!                     ^
  UPDATE base_tbl SET a=a, c=c; -- ok
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: UPDATE base_tbl SET a=a, c=c;
+                ^
  UPDATE base_tbl SET b=b; -- not allowed
! ERROR:  relation "base_tbl" does not exist
! LINE 1: UPDATE base_tbl SET b=b;
!                ^
  UPDATE rw_view1 SET bb=bb, cc=cc; -- ok
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: UPDATE rw_view1 SET bb=bb, cc=cc;
+                ^
  UPDATE rw_view1 SET aa=aa; -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: UPDATE rw_view1 SET aa=aa;
!                ^
  UPDATE rw_view2 SET aa=aa, cc=cc; -- ok
+ ERROR:  relation "rw_view2" does not exist
+ LINE 1: UPDATE rw_view2 SET aa=aa, cc=cc;
+                ^
  UPDATE rw_view2 SET bb=bb; -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: UPDATE rw_view2 SET bb=bb;
!                ^
  DELETE FROM base_tbl; -- not allowed
! ERROR:  relation "base_tbl" does not exist
! LINE 1: DELETE FROM base_tbl;
!                     ^
  DELETE FROM rw_view1; -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: DELETE FROM rw_view1;
!                     ^
  DELETE FROM rw_view2; -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: DELETE FROM rw_view2;
!                     ^
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user1;
  GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user2;
  INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0); -- ok
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
+                     ^
  INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4); -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
!                     ^
  INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4); -- ok
+ ERROR:  relation "rw_view2" does not exist
+ LINE 1: INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4);
+                     ^
  DELETE FROM base_tbl WHERE a=1; -- ok
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: DELETE FROM base_tbl WHERE a=1;
+                     ^
  DELETE FROM rw_view1 WHERE aa=2; -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: DELETE FROM rw_view1 WHERE aa=2;
!                     ^
  DELETE FROM rw_view2 WHERE aa=2; -- ok
+ ERROR:  relation "rw_view2" does not exist
+ LINE 1: DELETE FROM rw_view2 WHERE aa=2;
+                     ^
  SELECT * FROM base_tbl;
! ERROR:  relation "base_tbl" does not exist
! LINE 1: SELECT * FROM base_tbl;
!                       ^
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user1;
  REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_view_user2;
  INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0); -- not allowed
! ERROR:  relation "base_tbl" does not exist
! LINE 1: INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0);
!                     ^
  INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5); -- ok
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5);
+                     ^
  INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6); -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6);
!                     ^
  DELETE FROM base_tbl WHERE a=3; -- not allowed
! ERROR:  relation "base_tbl" does not exist
! LINE 1: DELETE FROM base_tbl WHERE a=3;
!                     ^
  DELETE FROM rw_view1 WHERE aa=3; -- ok
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: DELETE FROM rw_view1 WHERE aa=3;
+                     ^
  DELETE FROM rw_view2 WHERE aa=4; -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: DELETE FROM rw_view2 WHERE aa=4;
!                     ^
  SELECT * FROM base_tbl;
! ERROR:  relation "base_tbl" does not exist
! LINE 1: SELECT * FROM base_tbl;
!                       ^
  RESET SESSION AUTHORIZATION;
  DROP TABLE base_tbl CASCADE;
! ERROR:  table "base_tbl" does not exist
  -- nested-view permissions
  CREATE TABLE base_tbl(a int, b text, c float);
  INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
  SET SESSION AUTHORIZATION regress_view_user1;
  CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
+                                               ^
  SELECT * FROM rw_view1;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1;
!                       ^
  SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
!                       ^
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
!                ^
  SET SESSION AUTHORIZATION regress_view_user2;
  CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
+                                               ^
  SELECT * FROM rw_view2;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
!                       ^
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
!                ^
  RESET SESSION AUTHORIZATION;
  GRANT SELECT ON base_tbl TO regress_view_user1;
  SET SESSION AUTHORIZATION regress_view_user1;
  SELECT * FROM rw_view1;
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1;
!                       ^
  SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
!                       ^
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
!                ^
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
!                       ^
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
!                ^
  SET SESSION AUTHORIZATION regress_view_user1;
  GRANT SELECT ON rw_view1 TO regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
!                       ^
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
!                ^
  RESET SESSION AUTHORIZATION;
  GRANT UPDATE ON base_tbl TO regress_view_user1;
  SET SESSION AUTHORIZATION regress_view_user1;
  SELECT * FROM rw_view1;
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1;
!                       ^
  SELECT * FROM rw_view1 FOR UPDATE;
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
!                       ^
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
+                ^
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
!                       ^
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
!                ^
  SET SESSION AUTHORIZATION regress_view_user1;
  GRANT UPDATE ON rw_view1 TO regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  SELECT * FROM rw_view2 FOR UPDATE;
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
!                       ^
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+ ERROR:  relation "rw_view2" does not exist
+ LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
+                ^
  RESET SESSION AUTHORIZATION;
  REVOKE UPDATE ON base_tbl FROM regress_view_user1;
  SET SESSION AUTHORIZATION regress_view_user1;
  SELECT * FROM rw_view1;
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1;
!                       ^
  SELECT * FROM rw_view1 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: SELECT * FROM rw_view1 FOR UPDATE;
!                       ^
  UPDATE rw_view1 SET b = 'foo' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
!                ^
  SET SESSION AUTHORIZATION regress_view_user2;
  SELECT * FROM rw_view2;
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2;
!                       ^
  SELECT * FROM rw_view2 FOR UPDATE;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: SELECT * FROM rw_view2 FOR UPDATE;
!                       ^
  UPDATE rw_view2 SET b = 'bar' WHERE a = 1;  -- not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
!                ^
  RESET SESSION AUTHORIZATION;
  DROP TABLE base_tbl CASCADE;
  DROP USER regress_view_user1;
  DROP USER regress_view_user2;
  -- column defaults
***************
*** 2704,2775 ****
  create user regress_view_user2;
  set session authorization regress_view_user1;
  create table base_tbl(a int unique, b text, c float);
  insert into base_tbl values (1,'xxx',1.0);
  create view rw_view1 as select b as bb, c as cc, a as aa from base_tbl;
  grant select (aa,bb) on rw_view1 to regress_view_user2;
  grant insert on rw_view1 to regress_view_user2;
  grant update (bb) on rw_view1 to regress_view_user2;
  set session authorization regress_view_user2;
  insert into rw_view1 values ('yyy',2.0,1)
    on conflict (aa) do update set bb = excluded.cc; -- Not allowed
! ERROR:  permission denied for view rw_view1
  insert into rw_view1 values ('yyy',2.0,1)
    on conflict (aa) do update set bb = rw_view1.cc; -- Not allowed
! ERROR:  permission denied for view rw_view1
  insert into rw_view1 values ('yyy',2.0,1)
    on conflict (aa) do update set bb = excluded.bb; -- OK
  insert into rw_view1 values ('zzz',2.0,1)
    on conflict (aa) do update set bb = rw_view1.bb||'xxx'; -- OK
  insert into rw_view1 values ('zzz',2.0,1)
    on conflict (aa) do update set cc = 3.0; -- Not allowed
! ERROR:  permission denied for view rw_view1
  reset session authorization;
  select * from base_tbl;
!  a |   b    | c 
! ---+--------+---
!  1 | yyyxxx | 1
! (1 row)
! 
  set session authorization regress_view_user1;
  grant select (a,b) on base_tbl to regress_view_user2;
  grant insert (a,b) on base_tbl to regress_view_user2;
  grant update (a,b) on base_tbl to regress_view_user2;
  set session authorization regress_view_user2;
  create view rw_view2 as select b as bb, c as cc, a as aa from base_tbl;
  insert into rw_view2 (aa,bb) values (1,'xxx')
    on conflict (aa) do update set bb = excluded.bb; -- Not allowed
! ERROR:  permission denied for table base_tbl
  create view rw_view3 as select b as bb, a as aa from base_tbl;
  insert into rw_view3 (aa,bb) values (1,'xxx')
    on conflict (aa) do update set bb = excluded.bb; -- OK
  reset session authorization;
  select * from base_tbl;
!  a |  b  | c 
! ---+-----+---
!  1 | xxx | 1
! (1 row)
! 
  set session authorization regress_view_user2;
  create view rw_view4 as select aa, bb, cc FROM rw_view1;
  insert into rw_view4 (aa,bb) values (1,'yyy')
    on conflict (aa) do update set bb = excluded.bb; -- Not allowed
! ERROR:  permission denied for view rw_view1
  create view rw_view5 as select aa, bb FROM rw_view1;
  insert into rw_view5 (aa,bb) values (1,'yyy')
    on conflict (aa) do update set bb = excluded.bb; -- OK
  reset session authorization;
  select * from base_tbl;
!  a |  b  | c 
! ---+-----+---
!  1 | yyy | 1
! (1 row)
! 
  drop view rw_view5;
  drop view rw_view4;
  drop view rw_view3;
  drop view rw_view2;
  drop view rw_view1;
  drop table base_tbl;
  drop user regress_view_user1;
  drop user regress_view_user2;
  -- Test single- and multi-row inserts with table and view defaults.
--- 2797,2917 ----
  create user regress_view_user2;
  set session authorization regress_view_user1;
  create table base_tbl(a int unique, b text, c float);
+ ERROR:  no schema has been selected to create in
+ LINE 1: create table base_tbl(a int unique, b text, c float);
+                      ^
  insert into base_tbl values (1,'xxx',1.0);
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: insert into base_tbl values (1,'xxx',1.0);
+                     ^
  create view rw_view1 as select b as bb, c as cc, a as aa from base_tbl;
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: ... rw_view1 as select b as bb, c as cc, a as aa from base_tbl;
+                                                               ^
  grant select (aa,bb) on rw_view1 to regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  grant insert on rw_view1 to regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  grant update (bb) on rw_view1 to regress_view_user2;
+ ERROR:  relation "rw_view1" does not exist
  set session authorization regress_view_user2;
  insert into rw_view1 values ('yyy',2.0,1)
    on conflict (aa) do update set bb = excluded.cc; -- Not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: insert into rw_view1 values ('yyy',2.0,1)
!                     ^
  insert into rw_view1 values ('yyy',2.0,1)
    on conflict (aa) do update set bb = rw_view1.cc; -- Not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: insert into rw_view1 values ('yyy',2.0,1)
!                     ^
  insert into rw_view1 values ('yyy',2.0,1)
    on conflict (aa) do update set bb = excluded.bb; -- OK
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: insert into rw_view1 values ('yyy',2.0,1)
+                     ^
  insert into rw_view1 values ('zzz',2.0,1)
    on conflict (aa) do update set bb = rw_view1.bb||'xxx'; -- OK
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: insert into rw_view1 values ('zzz',2.0,1)
+                     ^
  insert into rw_view1 values ('zzz',2.0,1)
    on conflict (aa) do update set cc = 3.0; -- Not allowed
! ERROR:  relation "rw_view1" does not exist
! LINE 1: insert into rw_view1 values ('zzz',2.0,1)
!                     ^
  reset session authorization;
  select * from base_tbl;
! ERROR:  relation "base_tbl" does not exist
! LINE 1: select * from base_tbl;
!                       ^
  set session authorization regress_view_user1;
  grant select (a,b) on base_tbl to regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  grant insert (a,b) on base_tbl to regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  grant update (a,b) on base_tbl to regress_view_user2;
+ ERROR:  relation "base_tbl" does not exist
  set session authorization regress_view_user2;
  create view rw_view2 as select b as bb, c as cc, a as aa from base_tbl;
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: ... rw_view2 as select b as bb, c as cc, a as aa from base_tbl;
+                                                               ^
  insert into rw_view2 (aa,bb) values (1,'xxx')
    on conflict (aa) do update set bb = excluded.bb; -- Not allowed
! ERROR:  relation "rw_view2" does not exist
! LINE 1: insert into rw_view2 (aa,bb) values (1,'xxx')
!                     ^
  create view rw_view3 as select b as bb, a as aa from base_tbl;
+ ERROR:  relation "base_tbl" does not exist
+ LINE 1: ...eate view rw_view3 as select b as bb, a as aa from base_tbl;
+                                                               ^
  insert into rw_view3 (aa,bb) values (1,'xxx')
    on conflict (aa) do update set bb = excluded.bb; -- OK
+ ERROR:  relation "rw_view3" does not exist
+ LINE 1: insert into rw_view3 (aa,bb) values (1,'xxx')
+                     ^
  reset session authorization;
  select * from base_tbl;
! ERROR:  relation "base_tbl" does not exist
! LINE 1: select * from base_tbl;
!                       ^
  set session authorization regress_view_user2;
  create view rw_view4 as select aa, bb, cc FROM rw_view1;
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: create view rw_view4 as select aa, bb, cc FROM rw_view1;
+                                                        ^
  insert into rw_view4 (aa,bb) values (1,'yyy')
    on conflict (aa) do update set bb = excluded.bb; -- Not allowed
! ERROR:  relation "rw_view4" does not exist
! LINE 1: insert into rw_view4 (aa,bb) values (1,'yyy')
!                     ^
  create view rw_view5 as select aa, bb FROM rw_view1;
+ ERROR:  relation "rw_view1" does not exist
+ LINE 1: create view rw_view5 as select aa, bb FROM rw_view1;
+                                                    ^
  insert into rw_view5 (aa,bb) values (1,'yyy')
    on conflict (aa) do update set bb = excluded.bb; -- OK
+ ERROR:  relation "rw_view5" does not exist
+ LINE 1: insert into rw_view5 (aa,bb) values (1,'yyy')
+                     ^
  reset session authorization;
  select * from base_tbl;
! ERROR:  relation "base_tbl" does not exist
! LINE 1: select * from base_tbl;
!                       ^
  drop view rw_view5;
+ ERROR:  view "rw_view5" does not exist
  drop view rw_view4;
+ ERROR:  view "rw_view4" does not exist
  drop view rw_view3;
+ ERROR:  view "rw_view3" does not exist
  drop view rw_view2;
+ ERROR:  view "rw_view2" does not exist
  drop view rw_view1;
+ ERROR:  view "rw_view1" does not exist
  drop table base_tbl;
+ ERROR:  table "base_tbl" does not exist
  drop user regress_view_user1;
  drop user regress_view_user2;
  -- Test single- and multi-row inserts with table and view defaults.

======================================================================

*** contrib/mmts/../../src/test/regress/expected/sanity_check.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/sanity_check.out	CENSORED
***************
*** 32,37 ****
--- 32,39 ----
  check_tbl|f
  circle_tbl|t
  city|f
+ cluster_nodes|t
+ config|t
  copy_tbl|f
  d|f
  d_star|f
***************
*** 69,74 ****
--- 71,77 ----
  iportaltest|f
  kd_point_tbl|t
  line_tbl|f
+ local_tables|t
  log_table|f
  lseg_tbl|f
  main_table|f
***************
*** 175,180 ****
--- 178,184 ----
  radix_text_tbl|t
  ramp|f
  real_city|f
+ referee_decision|t
  road|t
  shighway|t
  slow_emp4000|f
***************
*** 187,192 ****
--- 191,197 ----
  sql_sizing_profiles|f
  stud_emp|f
  student|f
+ syncpoints|t
  tbl_include_box|t
  tbl_include_box_pk|f
  tbl_include_pk|t
***************
*** 195,200 ****
--- 200,206 ----
  tbl_include_unique2|f
  tenk1|t
  tenk2|t
+ test|t
  test_range_excl|t
  test_range_gist|t
  test_range_spgist|t

======================================================================

*** contrib/mmts/../../src/test/regress/expected/hash_index.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/hash_index.out	CENSORED
***************
*** 168,190 ****
  UPDATE hash_f8_heap
     SET random = '-1234.1234'::float8
     WHERE hash_f8_heap.seqno = 8906;
  SELECT h.seqno AS i8096, h.random AS f1234_1234
     FROM hash_f8_heap h
     WHERE h.random = '-1234.1234'::float8;
   i8096 | f1234_1234 
  -------+------------
!   8906 | -1234.1234
! (1 row)
  
  UPDATE hash_f8_heap
     SET seqno = 20000
     WHERE hash_f8_heap.random = '488912369'::float8;
  SELECT h.seqno AS f20000
     FROM hash_f8_heap h
     WHERE h.random = '488912369'::float8;
   f20000 
  --------
!   20000
  (1 row)
  
  -- UPDATE hash_ovfl_heap
--- 168,191 ----
  UPDATE hash_f8_heap
     SET random = '-1234.1234'::float8
     WHERE hash_f8_heap.seqno = 8906;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT h.seqno AS i8096, h.random AS f1234_1234
     FROM hash_f8_heap h
     WHERE h.random = '-1234.1234'::float8;
   i8096 | f1234_1234 
  -------+------------
! (0 rows)
  
  UPDATE hash_f8_heap
     SET seqno = 20000
     WHERE hash_f8_heap.random = '488912369'::float8;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT h.seqno AS f20000
     FROM hash_f8_heap h
     WHERE h.random = '488912369'::float8;
   f20000 
  --------
!    8932
  (1 row)
  
  -- UPDATE hash_ovfl_heap

======================================================================

*** contrib/mmts/../../src/test/regress/expected/update.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/update.out	CENSORED
***************
*** 558,564 ****
  -- This should fail with RLS violation error while moving row from
  -- part_a_10_a_20 to part_d_1_15, because we are setting 'c' to an odd number.
  UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c = 200;
! ERROR:  new row violates row-level security policy for table "range_parted"
  RESET SESSION AUTHORIZATION;
  -- Create a trigger on part_d_1_15
  CREATE FUNCTION func_d_1_15() RETURNS trigger AS $$
--- 558,566 ----
  -- This should fail with RLS violation error while moving row from
  -- part_a_10_a_20 to part_d_1_15, because we are setting 'c' to an odd number.
  UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c = 200;
! ERROR:  relation "range_parted" does not exist
! LINE 1: UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c...
!                ^
  RESET SESSION AUTHORIZATION;
  -- Create a trigger on part_d_1_15
  CREATE FUNCTION func_d_1_15() RETURNS trigger AS $$
***************
*** 574,579 ****
--- 576,584 ----
  -- part_d_1_15. Even though the UPDATE is setting 'c' to an odd number, the
  -- trigger at the destination partition again makes it an even number.
  UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c = 200;
+ ERROR:  relation "range_parted" does not exist
+ LINE 1: UPDATE range_parted set a = 'b', c = 151 WHERE a = 'a' and c...
+                ^
  RESET SESSION AUTHORIZATION;
  :init_range_parted;
  SET SESSION AUTHORIZATION regress_range_parted_user;
***************
*** 581,587 ****
  -- 'c' to an even number, the trigger at the destination partition again makes
  -- it an odd number.
  UPDATE range_parted set a = 'b', c = 150 WHERE a = 'a' and c = 200;
! ERROR:  new row violates row-level security policy for table "range_parted"
  -- Cleanup
  RESET SESSION AUTHORIZATION;
  DROP TRIGGER trig_d_1_15 ON part_d_1_15;
--- 586,594 ----
  -- 'c' to an even number, the trigger at the destination partition again makes
  -- it an odd number.
  UPDATE range_parted set a = 'b', c = 150 WHERE a = 'a' and c = 200;
! ERROR:  relation "range_parted" does not exist
! LINE 1: UPDATE range_parted set a = 'b', c = 150 WHERE a = 'a' and c...
!                ^
  -- Cleanup
  RESET SESSION AUTHORIZATION;
  DROP TRIGGER trig_d_1_15 ON part_d_1_15;
***************
*** 595,603 ****
  SET SESSION AUTHORIZATION regress_range_parted_user;
  -- fail, mintab has row with c1 = 120
  UPDATE range_parted set a = 'b', c = 122 WHERE a = 'a' and c = 200;
! ERROR:  new row violates row-level security policy "policy_range_parted_subplan" for table "range_parted"
  -- ok
  UPDATE range_parted set a = 'b', c = 120 WHERE a = 'a' and c = 200;
  -- RLS policy expression contains whole row.
  RESET SESSION AUTHORIZATION;
  :init_range_parted;
--- 602,615 ----
  SET SESSION AUTHORIZATION regress_range_parted_user;
  -- fail, mintab has row with c1 = 120
  UPDATE range_parted set a = 'b', c = 122 WHERE a = 'a' and c = 200;
! ERROR:  relation "range_parted" does not exist
! LINE 1: UPDATE range_parted set a = 'b', c = 122 WHERE a = 'a' and c...
!                ^
  -- ok
  UPDATE range_parted set a = 'b', c = 120 WHERE a = 'a' and c = 200;
+ ERROR:  relation "range_parted" does not exist
+ LINE 1: UPDATE range_parted set a = 'b', c = 120 WHERE a = 'a' and c...
+                ^
  -- RLS policy expression contains whole row.
  RESET SESSION AUTHORIZATION;
  :init_range_parted;
***************
*** 606,617 ****
  SET SESSION AUTHORIZATION regress_range_parted_user;
  -- ok, should pass the RLS check
  UPDATE range_parted set a = 'b', c = 112 WHERE a = 'a' and c = 200;
  RESET SESSION AUTHORIZATION;
  :init_range_parted;
  SET SESSION AUTHORIZATION regress_range_parted_user;
  -- fail, the whole row RLS check should fail
  UPDATE range_parted set a = 'b', c = 116 WHERE a = 'a' and c = 200;
! ERROR:  new row violates row-level security policy "policy_range_parted_wholerow" for table "range_parted"
  -- Cleanup
  RESET SESSION AUTHORIZATION;
  DROP POLICY policy_range_parted ON range_parted;
--- 618,634 ----
  SET SESSION AUTHORIZATION regress_range_parted_user;
  -- ok, should pass the RLS check
  UPDATE range_parted set a = 'b', c = 112 WHERE a = 'a' and c = 200;
+ ERROR:  relation "range_parted" does not exist
+ LINE 1: UPDATE range_parted set a = 'b', c = 112 WHERE a = 'a' and c...
+                ^
  RESET SESSION AUTHORIZATION;
  :init_range_parted;
  SET SESSION AUTHORIZATION regress_range_parted_user;
  -- fail, the whole row RLS check should fail
  UPDATE range_parted set a = 'b', c = 116 WHERE a = 'a' and c = 200;
! ERROR:  relation "range_parted" does not exist
! LINE 1: UPDATE range_parted set a = 'b', c = 116 WHERE a = 'a' and c...
!                ^
  -- Cleanup
  RESET SESSION AUTHORIZATION;
  DROP POLICY policy_range_parted ON range_parted;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/privileges.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/privileges.out	CENSORED
***************
*** 42,77 ****
  (1 row)
  
  CREATE TABLE atest1 ( a int, b text );
  SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
  INSERT INTO atest1 VALUES (1, 'one');
  DELETE FROM atest1;
  UPDATE atest1 SET a = 1 WHERE b = 'blech';
  TRUNCATE atest1;
  BEGIN;
  LOCK atest1 IN ACCESS EXCLUSIVE MODE;
  COMMIT;
  REVOKE ALL ON atest1 FROM PUBLIC;
  SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
  GRANT ALL ON atest1 TO regress_priv_user2;
  GRANT SELECT ON atest1 TO regress_priv_user3, regress_priv_user4;
  SELECT * FROM atest1;
!  a | b 
! ---+---
! (0 rows)
! 
  CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
  GRANT SELECT ON atest2 TO regress_priv_user2;
  GRANT UPDATE ON atest2 TO regress_priv_user3;
  GRANT INSERT ON atest2 TO regress_priv_user4;
  GRANT TRUNCATE ON atest2 TO regress_priv_user5;
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT session_user, current_user;
      session_user    |    current_user    
--- 42,98 ----
  (1 row)
  
  CREATE TABLE atest1 ( a int, b text );
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atest1 ( a int, b text );
+                      ^
  SELECT * FROM atest1;
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1;
!                       ^
  INSERT INTO atest1 VALUES (1, 'one');
+ ERROR:  relation "atest1" does not exist
+ LINE 1: INSERT INTO atest1 VALUES (1, 'one');
+                     ^
  DELETE FROM atest1;
+ ERROR:  relation "atest1" does not exist
+ LINE 1: DELETE FROM atest1;
+                     ^
  UPDATE atest1 SET a = 1 WHERE b = 'blech';
+ ERROR:  relation "atest1" does not exist
+ LINE 1: UPDATE atest1 SET a = 1 WHERE b = 'blech';
+                ^
  TRUNCATE atest1;
+ ERROR:  relation "atest1" does not exist
  BEGIN;
  LOCK atest1 IN ACCESS EXCLUSIVE MODE;
+ ERROR:  relation "atest1" does not exist
  COMMIT;
  REVOKE ALL ON atest1 FROM PUBLIC;
+ ERROR:  relation "atest1" does not exist
  SELECT * FROM atest1;
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1;
!                       ^
  GRANT ALL ON atest1 TO regress_priv_user2;
+ ERROR:  relation "atest1" does not exist
  GRANT SELECT ON atest1 TO regress_priv_user3, regress_priv_user4;
+ ERROR:  relation "atest1" does not exist
  SELECT * FROM atest1;
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1;
!                       ^
  CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
+                      ^
  GRANT SELECT ON atest2 TO regress_priv_user2;
+ ERROR:  relation "atest2" does not exist
  GRANT UPDATE ON atest2 TO regress_priv_user3;
+ ERROR:  relation "atest2" does not exist
  GRANT INSERT ON atest2 TO regress_priv_user4;
+ ERROR:  relation "atest2" does not exist
  GRANT TRUNCATE ON atest2 TO regress_priv_user5;
+ ERROR:  relation "atest2" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT session_user, current_user;
      session_user    |    current_user    
***************
*** 81,134 ****
  
  -- try various combinations of queries on atest1 and atest2
  SELECT * FROM atest1; -- ok
!  a | b 
! ---+---
! (0 rows)
! 
  SELECT * FROM atest2; -- ok
!  col1 | col2 
! ------+------
! (0 rows)
! 
  INSERT INTO atest1 VALUES (2, 'two'); -- ok
  INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  permission denied for table atest2
  INSERT INTO atest1 SELECT 1, b FROM atest1; -- ok
  UPDATE atest1 SET a = 1 WHERE a = 2; -- ok
  UPDATE atest2 SET col2 = NOT col2; -- fail
! ERROR:  permission denied for table atest2
  SELECT * FROM atest1 FOR UPDATE; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
  SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  permission denied for table atest2
  DELETE FROM atest2; -- fail
! ERROR:  permission denied for table atest2
  TRUNCATE atest2; -- fail
! ERROR:  permission denied for table atest2
  BEGIN;
  LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail
! ERROR:  permission denied for table atest2
  COMMIT;
  COPY atest2 FROM stdin; -- fail
! ERROR:  permission denied for table atest2
  GRANT ALL ON atest1 TO PUBLIC; -- fail
! WARNING:  no privileges were granted for "atest1"
  -- checks in subquery, both ok
  SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
!  a | b 
! ---+---
! (0 rows)
! 
  SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
!  col1 | col2 
! ------+------
! (0 rows)
! 
  SET SESSION AUTHORIZATION regress_priv_user3;
  SELECT session_user, current_user;
      session_user    |    current_user    
--- 102,165 ----
  
  -- try various combinations of queries on atest1 and atest2
  SELECT * FROM atest1; -- ok
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1;
!                       ^
  SELECT * FROM atest2; -- ok
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2;
!                       ^
  INSERT INTO atest1 VALUES (2, 'two'); -- ok
+ ERROR:  relation "atest1" does not exist
+ LINE 1: INSERT INTO atest1 VALUES (2, 'two');
+                     ^
  INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: INSERT INTO atest2 VALUES ('foo', true);
!                     ^
  INSERT INTO atest1 SELECT 1, b FROM atest1; -- ok
+ ERROR:  relation "atest1" does not exist
+ LINE 1: INSERT INTO atest1 SELECT 1, b FROM atest1;
+                     ^
  UPDATE atest1 SET a = 1 WHERE a = 2; -- ok
+ ERROR:  relation "atest1" does not exist
+ LINE 1: UPDATE atest1 SET a = 1 WHERE a = 2;
+                ^
  UPDATE atest2 SET col2 = NOT col2; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: UPDATE atest2 SET col2 = NOT col2;
!                ^
  SELECT * FROM atest1 FOR UPDATE; -- ok
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1 FOR UPDATE;
!                       ^
  SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2 FOR UPDATE;
!                       ^
  DELETE FROM atest2; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: DELETE FROM atest2;
!                     ^
  TRUNCATE atest2; -- fail
! ERROR:  relation "atest2" does not exist
  BEGIN;
  LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- fail
! ERROR:  relation "atest2" does not exist
  COMMIT;
  COPY atest2 FROM stdin; -- fail
! ERROR:  relation "atest2" does not exist
  GRANT ALL ON atest1 TO PUBLIC; -- fail
! ERROR:  relation "atest1" does not exist
  -- checks in subquery, both ok
  SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ...
!                       ^
  SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ...
!                       ^
  SET SESSION AUTHORIZATION regress_priv_user3;
  SELECT session_user, current_user;
      session_user    |    current_user    
***************
*** 137,700 ****
  (1 row)
  
  SELECT * FROM atest1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
  SELECT * FROM atest2; -- fail
! ERROR:  permission denied for table atest2
  INSERT INTO atest1 VALUES (2, 'two'); -- fail
! ERROR:  permission denied for table atest1
  INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  permission denied for table atest2
  INSERT INTO atest1 SELECT 1, b FROM atest1; -- fail
! ERROR:  permission denied for table atest1
  UPDATE atest1 SET a = 1 WHERE a = 2; -- fail
! ERROR:  permission denied for table atest1
  UPDATE atest2 SET col2 = NULL; -- ok
  UPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2
! ERROR:  permission denied for table atest2
  UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5; -- ok
  SELECT * FROM atest1 FOR UPDATE; -- fail
! ERROR:  permission denied for table atest1
  SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  permission denied for table atest2
  DELETE FROM atest2; -- fail
! ERROR:  permission denied for table atest2
  TRUNCATE atest2; -- fail
! ERROR:  permission denied for table atest2
  BEGIN;
  LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok
  COMMIT;
  COPY atest2 FROM stdin; -- fail
! ERROR:  permission denied for table atest2
  -- checks in subquery, both fail
  SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
! ERROR:  permission denied for table atest2
  SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
! ERROR:  permission denied for table atest2
  SET SESSION AUTHORIZATION regress_priv_user4;
  COPY atest2 FROM stdin; -- ok
  SELECT * FROM atest1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
  -- test leaky-function protections in selfuncs
  -- regress_priv_user1 will own a table and provide views for it.
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atest12 as
    SELECT x AS a, 10001 - x AS b FROM generate_series(1,10000) x;
  CREATE INDEX ON atest12 (a);
  CREATE INDEX ON atest12 (abs(a));
  VACUUM ANALYZE atest12;
  CREATE FUNCTION leak(integer,integer) RETURNS boolean
    AS $$begin return $1 < $2; end$$
    LANGUAGE plpgsql immutable;
  CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,
                       restrict = scalarltsel);
  -- views with leaky operator
  CREATE VIEW atest12v AS
    SELECT * FROM atest12 WHERE b <<< 5;
  CREATE VIEW atest12sbv WITH (security_barrier=true) AS
    SELECT * FROM atest12 WHERE b <<< 5;
  GRANT SELECT ON atest12v TO PUBLIC;
  GRANT SELECT ON atest12sbv TO PUBLIC;
  -- This plan should use nestloop, knowing that few rows will be selected.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on atest12 atest12_1
!          Filter: (b <<< 5)
!    ->  Index Scan using atest12_a_idx on atest12
!          Index Cond: (a = atest12_1.b)
!          Filter: (b <<< 5)
! (6 rows)
! 
  -- And this one.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
    WHERE x.a = y.b and abs(y.a) <<< 5;
!                     QUERY PLAN                     
! ---------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on atest12 y
!          Filter: (abs(a) <<< 5)
!    ->  Index Scan using atest12_a_idx on atest12 x
!          Index Cond: (a = y.b)
! (5 rows)
! 
  -- This should also be a nestloop, but the security barrier forces the inner
  -- scan to be materialized
  EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
!                 QUERY PLAN                 
! -------------------------------------------
!  Nested Loop
!    Join Filter: (atest12.a = atest12_1.b)
!    ->  Seq Scan on atest12
!          Filter: (b <<< 5)
!    ->  Materialize
!          ->  Seq Scan on atest12 atest12_1
!                Filter: (b <<< 5)
! (7 rows)
! 
  -- Check if regress_priv_user2 can break security.
  SET SESSION AUTHORIZATION regress_priv_user2;
  CREATE FUNCTION leak2(integer,integer) RETURNS boolean
    AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$
    LANGUAGE plpgsql immutable;
  CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,
                       restrict = scalargtsel);
  -- This should not show any "leak" notices before failing.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
! ERROR:  permission denied for table atest12
  -- These plans should continue to use a nestloop, since they execute with the
  -- privileges of the view owner.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on atest12 atest12_1
!          Filter: (b <<< 5)
!    ->  Index Scan using atest12_a_idx on atest12
!          Index Cond: (a = atest12_1.b)
!          Filter: (b <<< 5)
! (6 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
!                 QUERY PLAN                 
! -------------------------------------------
!  Nested Loop
!    Join Filter: (atest12.a = atest12_1.b)
!    ->  Seq Scan on atest12
!          Filter: (b <<< 5)
!    ->  Materialize
!          ->  Seq Scan on atest12 atest12_1
!                Filter: (b <<< 5)
! (7 rows)
! 
  -- A non-security barrier view does not guard against information leakage.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
    WHERE x.a = y.b and abs(y.a) <<< 5;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on atest12 atest12_1
!          Filter: ((b <<< 5) AND (abs(a) <<< 5))
!    ->  Index Scan using atest12_a_idx on atest12
!          Index Cond: (a = atest12_1.b)
!          Filter: (b <<< 5)
! (6 rows)
! 
  -- But a security barrier view isolates the leaky operator.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
    WHERE x.a = y.b and abs(y.a) <<< 5;
!              QUERY PLAN              
! -------------------------------------
!  Nested Loop
!    Join Filter: (atest12_1.a = y.b)
!    ->  Subquery Scan on y
!          Filter: (abs(y.a) <<< 5)
!          ->  Seq Scan on atest12
!                Filter: (b <<< 5)
!    ->  Seq Scan on atest12 atest12_1
!          Filter: (b <<< 5)
! (8 rows)
! 
  -- Now regress_priv_user1 grants sufficient access to regress_priv_user2.
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (a, b) ON atest12 TO PUBLIC;
  SET SESSION AUTHORIZATION regress_priv_user2;
  -- regress_priv_user2 should continue to get a good row estimate.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
!                    QUERY PLAN                    
! -------------------------------------------------
!  Nested Loop
!    ->  Seq Scan on atest12 atest12_1
!          Filter: (b <<< 5)
!    ->  Index Scan using atest12_a_idx on atest12
!          Index Cond: (a = atest12_1.b)
!          Filter: (b <<< 5)
! (6 rows)
! 
  -- But not for this, due to lack of table-wide permissions needed
  -- to make use of the expression index's statistics.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
    WHERE x.a = y.b and abs(y.a) <<< 5;
!               QUERY PLAN              
! --------------------------------------
!  Hash Join
!    Hash Cond: (x.a = y.b)
!    ->  Seq Scan on atest12 x
!    ->  Hash
!          ->  Seq Scan on atest12 y
!                Filter: (abs(a) <<< 5)
! (6 rows)
! 
  -- clean up (regress_priv_user1's objects are all dropped later)
  DROP FUNCTION leak2(integer, integer) CASCADE;
! NOTICE:  drop cascades to operator >>>(integer,integer)
  -- groups
  SET SESSION AUTHORIZATION regress_priv_user3;
  CREATE TABLE atest3 (one int, two int, three int);
  GRANT DELETE ON atest3 TO GROUP regress_priv_group2;
  SET SESSION AUTHORIZATION regress_priv_user1;
  SELECT * FROM atest3; -- fail
! ERROR:  permission denied for table atest3
  DELETE FROM atest3; -- ok
  -- views
  SET SESSION AUTHORIZATION regress_priv_user3;
  CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok
  /* The next *should* fail, but it's not implemented that way yet. */
  CREATE VIEW atestv2 AS SELECT * FROM atest2;
  CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok
  /* Empty view is a corner case that failed in 9.2. */
  CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- ok
  SELECT * FROM atestv1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
  SELECT * FROM atestv2; -- fail
! ERROR:  permission denied for table atest2
  GRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
  GRANT SELECT ON atestv2 TO regress_priv_user2;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT * FROM atestv1; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
  SELECT * FROM atestv2; -- fail
! ERROR:  permission denied for view atestv2
  SELECT * FROM atestv3; -- ok
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
  SELECT * FROM atestv0; -- fail
! ERROR:  permission denied for view atestv0
  -- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
  select * from
    ((select a.q1 as x from int8_tbl a offset 0)
     union all
     (select b.q2 as x from int8_tbl b offset 0)) ss
  where false;
! ERROR:  permission denied for table int8_tbl
  set constraint_exclusion = on;
  select * from
    ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
     union all
     (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
  where x < 0;
! ERROR:  permission denied for table int8_tbl
  reset constraint_exclusion;
  CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested view
  SELECT * FROM atestv4; -- ok
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
  GRANT SELECT ON atestv4 TO regress_priv_user2;
  SET SESSION AUTHORIZATION regress_priv_user2;
  -- Two complex cases:
  SELECT * FROM atestv3; -- fail
! ERROR:  permission denied for view atestv3
  SELECT * FROM atestv4; -- ok (even though regress_priv_user2 cannot access underlying atestv3)
!  one | two | three 
! -----+-----+-------
! (0 rows)
! 
  SELECT * FROM atest2; -- ok
!  col1 | col2 
! ------+------
!  bar  | t
! (1 row)
! 
  SELECT * FROM atestv2; -- fail (even though regress_priv_user2 can access underlying atest2)
! ERROR:  permission denied for table atest2
  -- Test column level permissions
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atest5 (one int, two int unique, three int, four int unique);
  CREATE TABLE atest6 (one int, two int, blue int);
  GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regress_priv_user4;
  GRANT ALL (one) ON atest5 TO regress_priv_user3;
  INSERT INTO atest5 VALUES (1,2,3);
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT * FROM atest5; -- fail
! ERROR:  permission denied for table atest5
  SELECT one FROM atest5; -- ok
!  one 
! -----
!    1
! (1 row)
! 
  COPY atest5 (one) TO stdout; -- ok
! 1
  SELECT two FROM atest5; -- fail
! ERROR:  permission denied for table atest5
  COPY atest5 (two) TO stdout; -- fail
! ERROR:  permission denied for table atest5
  SELECT atest5 FROM atest5; -- fail
! ERROR:  permission denied for table atest5
  COPY atest5 (one,two) TO stdout; -- fail
! ERROR:  permission denied for table atest5
  SELECT 1 FROM atest5; -- ok
!  ?column? 
! ----------
!         1
! (1 row)
! 
  SELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- ok
!  ?column? 
! ----------
!         1
! (1 row)
! 
  SELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- fail
! ERROR:  permission denied for table atest5
  SELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- fail
! ERROR:  permission denied for table atest5
  SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
! ERROR:  permission denied for table atest5
  SELECT 1 FROM atest5 WHERE two = 2; -- fail
! ERROR:  permission denied for table atest5
  SELECT * FROM atest1, atest5; -- fail
! ERROR:  permission denied for table atest5
  SELECT atest1.* FROM atest1, atest5; -- ok
!  a |  b  
! ---+-----
!  1 | two
!  1 | two
! (2 rows)
! 
  SELECT atest1.*,atest5.one FROM atest1, atest5; -- ok
!  a |  b  | one 
! ---+-----+-----
!  1 | two |   1
!  1 | two |   1
! (2 rows)
! 
  SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- fail
! ERROR:  permission denied for table atest5
  SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- ok
!  a |  b  | one 
! ---+-----+-----
!  1 | two |   1
!  1 | two |   1
! (2 rows)
! 
  SELECT one, two FROM atest5; -- fail
! ERROR:  permission denied for table atest5
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (one,two) ON atest6 TO regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail still
! ERROR:  permission denied for table atest5
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (two) ON atest5 TO regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok now
!  one | two 
! -----+-----
! (0 rows)
! 
  -- test column-level privileges for INSERT and UPDATE
  INSERT INTO atest5 (two) VALUES (3); -- ok
  COPY atest5 FROM stdin; -- fail
! ERROR:  permission denied for table atest5
  COPY atest5 (two) FROM stdin; -- ok
  INSERT INTO atest5 (three) VALUES (4); -- fail
! ERROR:  permission denied for table atest5
  INSERT INTO atest5 VALUES (5,5,5); -- fail
! ERROR:  permission denied for table atest5
  UPDATE atest5 SET three = 10; -- ok
  UPDATE atest5 SET one = 8; -- fail
! ERROR:  permission denied for table atest5
  UPDATE atest5 SET three = 5, one = 2; -- fail
! ERROR:  permission denied for table atest5
  -- Check that column level privs are enforced in RETURNING
  -- Ok.
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10;
  -- Error. No SELECT on column three.
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.three;
! ERROR:  permission denied for table atest5
  -- Ok.  May SELECT on column "one":
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.one;
!  one 
! -----
!     
! (1 row)
! 
  -- Check that column level privileges are enforced for EXCLUDED
  -- Ok. we may select one
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.one;
  -- Error. No select rights on three
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.three;
! ERROR:  permission denied for table atest5
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set one = 8; -- fails (due to UPDATE)
! ERROR:  permission denied for table atest5
  INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UPDATE set three = 10; -- fails (due to INSERT)
! ERROR:  permission denied for table atest5
  -- Check that the columns in the inference require select privileges
  INSERT INTO atest5(four) VALUES (4); -- fail
! ERROR:  permission denied for table atest5
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT INSERT (four) ON atest5 TO regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- fails (due to SELECT)
! ERROR:  permission denied for table atest5
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- fails (due to SELECT)
! ERROR:  permission denied for table atest5
  INSERT INTO atest5(four) VALUES (4); -- ok
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (four) ON atest5 TO regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- ok
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- ok
  SET SESSION AUTHORIZATION regress_priv_user1;
  REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
  GRANT SELECT (one,two,blue) ON atest6 TO regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT one FROM atest5; -- fail
! ERROR:  permission denied for table atest5
  UPDATE atest5 SET one = 1; -- fail
! ERROR:  permission denied for table atest5
  SELECT atest6 FROM atest6; -- ok
!  atest6 
! --------
! (0 rows)
! 
  COPY atest6 TO stdout; -- ok
  -- check error reporting with column privs
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), primary key (c1, c2));
  GRANT SELECT (c1) ON t1 TO regress_priv_user2;
  GRANT INSERT (c1, c2, c3) ON t1 TO regress_priv_user2;
  GRANT UPDATE (c1, c2, c3) ON t1 TO regress_priv_user2;
  -- seed data
  INSERT INTO t1 VALUES (1, 1, 1);
  INSERT INTO t1 VALUES (1, 2, 1);
  INSERT INTO t1 VALUES (2, 1, 2);
  INSERT INTO t1 VALUES (2, 2, 2);
  INSERT INTO t1 VALUES (3, 1, 3);
  SET SESSION AUTHORIZATION regress_priv_user2;
  INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shown
! ERROR:  duplicate key value violates unique constraint "t1_pkey"
  UPDATE t1 SET c2 = 1; -- fail, but row not shown
! ERROR:  duplicate key value violates unique constraint "t1_pkey"
  INSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being inserted
! ERROR:  null value in column "c1" violates not-null constraint
! DETAIL:  Failing row contains (c1, c2) = (null, null).
  INSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECT
! ERROR:  null value in column "c1" violates not-null constraint
! DETAIL:  Failing row contains (c1, c3) = (null, null).
  INSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECT
! ERROR:  null value in column "c2" violates not-null constraint
! DETAIL:  Failing row contains (c1) = (5).
  UPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modified
! ERROR:  new row for relation "t1" violates check constraint "t1_c3_check"
! DETAIL:  Failing row contains (c1, c3) = (1, 10).
  SET SESSION AUTHORIZATION regress_priv_user1;
  DROP TABLE t1;
  -- test column-level privileges when involved with DELETE
  SET SESSION AUTHORIZATION regress_priv_user1;
  ALTER TABLE atest6 ADD COLUMN three integer;
  GRANT DELETE ON atest5 TO regress_priv_user3;
  GRANT SELECT (two) ON atest5 TO regress_priv_user3;
  REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
  GRANT SELECT (one) ON atest5 TO regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT atest6 FROM atest6; -- fail
! ERROR:  permission denied for table atest6
  SELECT one FROM atest5 NATURAL JOIN atest6; -- fail
! ERROR:  permission denied for table atest5
  SET SESSION AUTHORIZATION regress_priv_user1;
  ALTER TABLE atest6 DROP COLUMN three;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT atest6 FROM atest6; -- ok
!  atest6 
! --------
! (0 rows)
! 
  SELECT one FROM atest5 NATURAL JOIN atest6; -- ok
!  one 
! -----
! (0 rows)
! 
  SET SESSION AUTHORIZATION regress_priv_user1;
  ALTER TABLE atest6 DROP COLUMN two;
  REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT * FROM atest6; -- fail
! ERROR:  permission denied for table atest6
  SELECT 1 FROM atest6; -- fail
! ERROR:  permission denied for table atest6
  SET SESSION AUTHORIZATION regress_priv_user3;
  DELETE FROM atest5 WHERE one = 1; -- fail
! ERROR:  permission denied for table atest5
  DELETE FROM atest5 WHERE two = 2; -- ok
  -- check inheritance cases
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS;
  CREATE TABLE atestp2 (fx int, fy int) WITH OIDS;
  CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
  GRANT SELECT(fx,fy,oid) ON atestp2 TO regress_priv_user2;
  GRANT SELECT(fx) ON atestc TO regress_priv_user2;
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT fx FROM atestp2; -- ok
!  fx 
! ----
! (0 rows)
! 
  SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
  SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
  SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
  SELECT fy FROM atestc; -- fail
! ERROR:  permission denied for table atestc
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT(fy,oid) ON atestc TO regress_priv_user2;
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT fx FROM atestp2; -- still ok
!  fx 
! ----
! (0 rows)
! 
  SELECT fy FROM atestp2; -- ok
!  fy 
! ----
! (0 rows)
! 
  SELECT atestp2 FROM atestp2; -- ok
!  atestp2 
! ---------
! (0 rows)
! 
  SELECT oid FROM atestp2; -- ok
!  oid 
! -----
! (0 rows)
! 
  -- privileges on functions, languages
  -- switch to superuser
  \c -
--- 168,866 ----
  (1 row)
  
  SELECT * FROM atest1; -- ok
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1;
!                       ^
  SELECT * FROM atest2; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2;
!                       ^
  INSERT INTO atest1 VALUES (2, 'two'); -- fail
! ERROR:  relation "atest1" does not exist
! LINE 1: INSERT INTO atest1 VALUES (2, 'two');
!                     ^
  INSERT INTO atest2 VALUES ('foo', true); -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: INSERT INTO atest2 VALUES ('foo', true);
!                     ^
  INSERT INTO atest1 SELECT 1, b FROM atest1; -- fail
! ERROR:  relation "atest1" does not exist
! LINE 1: INSERT INTO atest1 SELECT 1, b FROM atest1;
!                     ^
  UPDATE atest1 SET a = 1 WHERE a = 2; -- fail
! ERROR:  relation "atest1" does not exist
! LINE 1: UPDATE atest1 SET a = 1 WHERE a = 2;
!                ^
  UPDATE atest2 SET col2 = NULL; -- ok
+ ERROR:  relation "atest2" does not exist
+ LINE 1: UPDATE atest2 SET col2 = NULL;
+                ^
  UPDATE atest2 SET col2 = NOT col2; -- fails; requires SELECT on atest2
! ERROR:  relation "atest2" does not exist
! LINE 1: UPDATE atest2 SET col2 = NOT col2;
!                ^
  UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5; -- ok
+ ERROR:  relation "atest2" does not exist
+ LINE 1: UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5...
+                ^
  SELECT * FROM atest1 FOR UPDATE; -- fail
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1 FOR UPDATE;
!                       ^
  SELECT * FROM atest2 FOR UPDATE; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2 FOR UPDATE;
!                       ^
  DELETE FROM atest2; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: DELETE FROM atest2;
!                     ^
  TRUNCATE atest2; -- fail
! ERROR:  relation "atest2" does not exist
  BEGIN;
  LOCK atest2 IN ACCESS EXCLUSIVE MODE; -- ok
+ ERROR:  relation "atest2" does not exist
  COMMIT;
  COPY atest2 FROM stdin; -- fail
! ERROR:  relation "atest2" does not exist
  -- checks in subquery, both fail
  SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ...
!                       ^
  SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ...
!                       ^
  SET SESSION AUTHORIZATION regress_priv_user4;
  COPY atest2 FROM stdin; -- ok
+ ERROR:  relation "atest2" does not exist
+ bar	true
+ \.
+ invalid command \.
  SELECT * FROM atest1; -- ok
! ERROR:  syntax error at or near "bar"
! LINE 1: bar true
!         ^
  -- test leaky-function protections in selfuncs
  -- regress_priv_user1 will own a table and provide views for it.
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atest12 as
    SELECT x AS a, 10001 - x AS b FROM generate_series(1,10000) x;
+ ERROR:  no schema has been selected to create in
  CREATE INDEX ON atest12 (a);
+ ERROR:  relation "atest12" does not exist
  CREATE INDEX ON atest12 (abs(a));
+ ERROR:  relation "atest12" does not exist
  VACUUM ANALYZE atest12;
+ ERROR:  relation "atest12" does not exist
  CREATE FUNCTION leak(integer,integer) RETURNS boolean
    AS $$begin return $1 < $2; end$$
    LANGUAGE plpgsql immutable;
+ ERROR:  no schema has been selected to create in
  CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,
                       restrict = scalarltsel);
+ ERROR:  no schema has been selected to create in
  -- views with leaky operator
  CREATE VIEW atest12v AS
    SELECT * FROM atest12 WHERE b <<< 5;
+ ERROR:  relation "atest12" does not exist
+ LINE 2:   SELECT * FROM atest12 WHERE b <<< 5;
+                         ^
  CREATE VIEW atest12sbv WITH (security_barrier=true) AS
    SELECT * FROM atest12 WHERE b <<< 5;
+ ERROR:  relation "atest12" does not exist
+ LINE 2:   SELECT * FROM atest12 WHERE b <<< 5;
+                         ^
  GRANT SELECT ON atest12v TO PUBLIC;
+ ERROR:  relation "atest12v" does not exist
  GRANT SELECT ON atest12sbv TO PUBLIC;
+ ERROR:  relation "atest12sbv" does not exist
  -- This plan should use nestloop, knowing that few rows will be selected.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
! ERROR:  relation "atest12v" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHE...
!                                           ^
  -- And this one.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
    WHERE x.a = y.b and abs(y.a) <<< 5;
! ERROR:  relation "atest12" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
!                                           ^
  -- This should also be a nestloop, but the security barrier forces the inner
  -- scan to be materialized
  EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
! ERROR:  relation "atest12sbv" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y...
!                                           ^
  -- Check if regress_priv_user2 can break security.
  SET SESSION AUTHORIZATION regress_priv_user2;
  CREATE FUNCTION leak2(integer,integer) RETURNS boolean
    AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$
    LANGUAGE plpgsql immutable;
+ ERROR:  no schema has been selected to create in
  CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,
                       restrict = scalargtsel);
+ ERROR:  no schema has been selected to create in
  -- This should not show any "leak" notices before failing.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
! ERROR:  relation "atest12" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
!                                           ^
  -- These plans should continue to use a nestloop, since they execute with the
  -- privileges of the view owner.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
! ERROR:  relation "atest12v" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHE...
!                                           ^
  EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
! ERROR:  relation "atest12sbv" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y...
!                                           ^
  -- A non-security barrier view does not guard against information leakage.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
    WHERE x.a = y.b and abs(y.a) <<< 5;
! ERROR:  relation "atest12v" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
!                                           ^
  -- But a security barrier view isolates the leaky operator.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
    WHERE x.a = y.b and abs(y.a) <<< 5;
! ERROR:  relation "atest12sbv" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
!                                           ^
  -- Now regress_priv_user1 grants sufficient access to regress_priv_user2.
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (a, b) ON atest12 TO PUBLIC;
+ ERROR:  relation "atest12" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  -- regress_priv_user2 should continue to get a good row estimate.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
! ERROR:  relation "atest12v" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHE...
!                                           ^
  -- But not for this, due to lack of table-wide permissions needed
  -- to make use of the expression index's statistics.
  EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
    WHERE x.a = y.b and abs(y.a) <<< 5;
! ERROR:  relation "atest12" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
!                                           ^
  -- clean up (regress_priv_user1's objects are all dropped later)
  DROP FUNCTION leak2(integer, integer) CASCADE;
! ERROR:  function leak2(integer, integer) does not exist
  -- groups
  SET SESSION AUTHORIZATION regress_priv_user3;
  CREATE TABLE atest3 (one int, two int, three int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atest3 (one int, two int, three int);
+                      ^
  GRANT DELETE ON atest3 TO GROUP regress_priv_group2;
+ ERROR:  relation "atest3" does not exist
  SET SESSION AUTHORIZATION regress_priv_user1;
  SELECT * FROM atest3; -- fail
! ERROR:  relation "atest3" does not exist
! LINE 1: SELECT * FROM atest3;
!                       ^
  DELETE FROM atest3; -- ok
+ ERROR:  relation "atest3" does not exist
+ LINE 1: DELETE FROM atest3;
+                     ^
  -- views
  SET SESSION AUTHORIZATION regress_priv_user3;
  CREATE VIEW atestv1 AS SELECT * FROM atest1; -- ok
+ ERROR:  relation "atest1" does not exist
+ LINE 1: CREATE VIEW atestv1 AS SELECT * FROM atest1;
+                                              ^
  /* The next *should* fail, but it's not implemented that way yet. */
  CREATE VIEW atestv2 AS SELECT * FROM atest2;
+ ERROR:  relation "atest2" does not exist
+ LINE 2: CREATE VIEW atestv2 AS SELECT * FROM atest2;
+                                              ^
  CREATE VIEW atestv3 AS SELECT * FROM atest3; -- ok
+ ERROR:  relation "atest3" does not exist
+ LINE 1: CREATE VIEW atestv3 AS SELECT * FROM atest3;
+                                              ^
  /* Empty view is a corner case that failed in 9.2. */
  CREATE VIEW atestv0 AS SELECT 0 as x WHERE false; -- ok
+ ERROR:  no schema has been selected to create in
  SELECT * FROM atestv1; -- ok
! ERROR:  relation "atestv1" does not exist
! LINE 1: SELECT * FROM atestv1;
!                       ^
  SELECT * FROM atestv2; -- fail
! ERROR:  relation "atestv2" does not exist
! LINE 1: SELECT * FROM atestv2;
!                       ^
  GRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
+ ERROR:  relation "atestv1" does not exist
  GRANT SELECT ON atestv2 TO regress_priv_user2;
+ ERROR:  relation "atestv2" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT * FROM atestv1; -- ok
! ERROR:  relation "atestv1" does not exist
! LINE 1: SELECT * FROM atestv1;
!                       ^
  SELECT * FROM atestv2; -- fail
! ERROR:  relation "atestv2" does not exist
! LINE 1: SELECT * FROM atestv2;
!                       ^
  SELECT * FROM atestv3; -- ok
! ERROR:  relation "atestv3" does not exist
! LINE 1: SELECT * FROM atestv3;
!                       ^
  SELECT * FROM atestv0; -- fail
! ERROR:  relation "atestv0" does not exist
! LINE 1: SELECT * FROM atestv0;
!                       ^
  -- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
  select * from
    ((select a.q1 as x from int8_tbl a offset 0)
     union all
     (select b.q2 as x from int8_tbl b offset 0)) ss
  where false;
! ERROR:  relation "int8_tbl" does not exist
! LINE 2:   ((select a.q1 as x from int8_tbl a offset 0)
!                                   ^
  set constraint_exclusion = on;
  select * from
    ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
     union all
     (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
  where x < 0;
! ERROR:  relation "int8_tbl" does not exist
! LINE 2:   ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
!                                             ^
  reset constraint_exclusion;
  CREATE VIEW atestv4 AS SELECT * FROM atestv3; -- nested view
+ ERROR:  relation "atestv3" does not exist
+ LINE 1: CREATE VIEW atestv4 AS SELECT * FROM atestv3;
+                                              ^
  SELECT * FROM atestv4; -- ok
! ERROR:  relation "atestv4" does not exist
! LINE 1: SELECT * FROM atestv4;
!                       ^
  GRANT SELECT ON atestv4 TO regress_priv_user2;
+ ERROR:  relation "atestv4" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  -- Two complex cases:
  SELECT * FROM atestv3; -- fail
! ERROR:  relation "atestv3" does not exist
! LINE 1: SELECT * FROM atestv3;
!                       ^
  SELECT * FROM atestv4; -- ok (even though regress_priv_user2 cannot access underlying atestv3)
! ERROR:  relation "atestv4" does not exist
! LINE 1: SELECT * FROM atestv4;
!                       ^
  SELECT * FROM atest2; -- ok
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT * FROM atest2;
!                       ^
  SELECT * FROM atestv2; -- fail (even though regress_priv_user2 can access underlying atest2)
! ERROR:  relation "atestv2" does not exist
! LINE 1: SELECT * FROM atestv2;
!                       ^
  -- Test column level permissions
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atest5 (one int, two int unique, three int, four int unique);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atest5 (one int, two int unique, three int, fou...
+                      ^
  CREATE TABLE atest6 (one int, two int, blue int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atest6 (one int, two int, blue int);
+                      ^
  GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regress_priv_user4;
+ ERROR:  relation "atest5" does not exist
  GRANT ALL (one) ON atest5 TO regress_priv_user3;
+ ERROR:  relation "atest5" does not exist
  INSERT INTO atest5 VALUES (1,2,3);
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5 VALUES (1,2,3);
+                     ^
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT * FROM atest5; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT * FROM atest5;
!                       ^
  SELECT one FROM atest5; -- ok
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one FROM atest5;
!                         ^
  COPY atest5 (one) TO stdout; -- ok
! ERROR:  relation "atest5" does not exist
  SELECT two FROM atest5; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT two FROM atest5;
!                         ^
  COPY atest5 (two) TO stdout; -- fail
! ERROR:  relation "atest5" does not exist
  SELECT atest5 FROM atest5; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT atest5 FROM atest5;
!                            ^
  COPY atest5 (one,two) TO stdout; -- fail
! ERROR:  relation "atest5" does not exist
  SELECT 1 FROM atest5; -- ok
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT 1 FROM atest5;
!                       ^
  SELECT 1 FROM atest5 a JOIN atest5 b USING (one); -- ok
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT 1 FROM atest5 a JOIN atest5 b USING (one);
!                       ^
  SELECT 1 FROM atest5 a JOIN atest5 b USING (two); -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT 1 FROM atest5 a JOIN atest5 b USING (two);
!                       ^
  SELECT 1 FROM atest5 a NATURAL JOIN atest5 b; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT 1 FROM atest5 a NATURAL JOIN atest5 b;
!                       ^
  SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one...
!                                    ^
  SELECT 1 FROM atest5 WHERE two = 2; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT 1 FROM atest5 WHERE two = 2;
!                       ^
  SELECT * FROM atest1, atest5; -- fail
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT * FROM atest1, atest5;
!                       ^
  SELECT atest1.* FROM atest1, atest5; -- ok
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT atest1.* FROM atest1, atest5;
!                              ^
  SELECT atest1.*,atest5.one FROM atest1, atest5; -- ok
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT atest1.*,atest5.one FROM atest1, atest5;
!                                         ^
  SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two); -- fail
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest...
!                                         ^
  SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one); -- ok
! ERROR:  relation "atest1" does not exist
! LINE 1: SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest...
!                                         ^
  SELECT one, two FROM atest5; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one, two FROM atest5;
!                              ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (one,two) ON atest6 TO regress_priv_user4;
+ ERROR:  relation "atest6" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT one, two FROM atest5 NATURAL JOIN atest6; -- fail still
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one, two FROM atest5 NATURAL JOIN atest6;
!                              ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (two) ON atest5 TO regress_priv_user4;
+ ERROR:  relation "atest5" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT one, two FROM atest5 NATURAL JOIN atest6; -- ok now
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one, two FROM atest5 NATURAL JOIN atest6;
!                              ^
  -- test column-level privileges for INSERT and UPDATE
  INSERT INTO atest5 (two) VALUES (3); -- ok
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5 (two) VALUES (3);
+                     ^
  COPY atest5 FROM stdin; -- fail
! ERROR:  relation "atest5" does not exist
  COPY atest5 (two) FROM stdin; -- ok
+ ERROR:  relation "atest5" does not exist
+ 1
+ \.
+ invalid command \.
  INSERT INTO atest5 (three) VALUES (4); -- fail
! ERROR:  syntax error at or near "1"
! LINE 1: 1
!         ^
  INSERT INTO atest5 VALUES (5,5,5); -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5 VALUES (5,5,5);
!                     ^
  UPDATE atest5 SET three = 10; -- ok
+ ERROR:  relation "atest5" does not exist
+ LINE 1: UPDATE atest5 SET three = 10;
+                ^
  UPDATE atest5 SET one = 8; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: UPDATE atest5 SET one = 8;
!                ^
  UPDATE atest5 SET three = 5, one = 2; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: UPDATE atest5 SET three = 5, one = 2;
!                ^
  -- Check that column level privs are enforced in RETURNING
  -- Ok.
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10;
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                     ^
  -- Error. No SELECT on column three.
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.three;
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
!                     ^
  -- Ok.  May SELECT on column "one":
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.one;
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
!                     ^
  -- Check that column level privileges are enforced for EXCLUDED
  -- Ok. we may select one
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.one;
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
+                     ^
  -- Error. No select rights on three
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.three;
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
!                     ^
  INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set one = 8; -- fails (due to UPDATE)
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDA...
!                     ^
  INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UPDATE set three = 10; -- fails (due to INSERT)
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UP...
!                     ^
  -- Check that the columns in the inference require select privileges
  INSERT INTO atest5(four) VALUES (4); -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(four) VALUES (4);
!                     ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT INSERT (four) ON atest5 TO regress_priv_user4;
+ ERROR:  relation "atest5" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- fails (due to SELECT)
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UP...
!                     ^
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- fails (due to SELECT)
! ERROR:  relation "atest5" does not exist
! LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAIN...
!                     ^
  INSERT INTO atest5(four) VALUES (4); -- ok
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5(four) VALUES (4);
+                     ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT (four) ON atest5 TO regress_priv_user4;
+ ERROR:  relation "atest5" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3; -- ok
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UP...
+                     ^
  INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3; -- ok
+ ERROR:  relation "atest5" does not exist
+ LINE 1: INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAIN...
+                     ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
+ ERROR:  relation "atest5" does not exist
  GRANT SELECT (one,two,blue) ON atest6 TO regress_priv_user4;
+ ERROR:  relation "atest6" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT one FROM atest5; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one FROM atest5;
!                         ^
  UPDATE atest5 SET one = 1; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: UPDATE atest5 SET one = 1;
!                ^
  SELECT atest6 FROM atest6; -- ok
! ERROR:  relation "atest6" does not exist
! LINE 1: SELECT atest6 FROM atest6;
!                            ^
  COPY atest6 TO stdout; -- ok
+ ERROR:  relation "atest6" does not exist
  -- check error reporting with column privs
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), primary key (c1, c2));
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), prim...
+                      ^
  GRANT SELECT (c1) ON t1 TO regress_priv_user2;
+ ERROR:  relation "t1" does not exist
  GRANT INSERT (c1, c2, c3) ON t1 TO regress_priv_user2;
+ ERROR:  relation "t1" does not exist
  GRANT UPDATE (c1, c2, c3) ON t1 TO regress_priv_user2;
+ ERROR:  relation "t1" does not exist
  -- seed data
  INSERT INTO t1 VALUES (1, 1, 1);
+ ERROR:  relation "t1" does not exist
+ LINE 1: INSERT INTO t1 VALUES (1, 1, 1);
+                     ^
  INSERT INTO t1 VALUES (1, 2, 1);
+ ERROR:  relation "t1" does not exist
+ LINE 1: INSERT INTO t1 VALUES (1, 2, 1);
+                     ^
  INSERT INTO t1 VALUES (2, 1, 2);
+ ERROR:  relation "t1" does not exist
+ LINE 1: INSERT INTO t1 VALUES (2, 1, 2);
+                     ^
  INSERT INTO t1 VALUES (2, 2, 2);
+ ERROR:  relation "t1" does not exist
+ LINE 1: INSERT INTO t1 VALUES (2, 2, 2);
+                     ^
  INSERT INTO t1 VALUES (3, 1, 3);
+ ERROR:  relation "t1" does not exist
+ LINE 1: INSERT INTO t1 VALUES (3, 1, 3);
+                     ^
  SET SESSION AUTHORIZATION regress_priv_user2;
  INSERT INTO t1 (c1, c2) VALUES (1, 1); -- fail, but row not shown
! ERROR:  relation "t1" does not exist
! LINE 1: INSERT INTO t1 (c1, c2) VALUES (1, 1);
!                     ^
  UPDATE t1 SET c2 = 1; -- fail, but row not shown
! ERROR:  relation "t1" does not exist
! LINE 1: UPDATE t1 SET c2 = 1;
!                ^
  INSERT INTO t1 (c1, c2) VALUES (null, null); -- fail, but see columns being inserted
! ERROR:  relation "t1" does not exist
! LINE 1: INSERT INTO t1 (c1, c2) VALUES (null, null);
!                     ^
  INSERT INTO t1 (c3) VALUES (null); -- fail, but see columns being inserted or have SELECT
! ERROR:  relation "t1" does not exist
! LINE 1: INSERT INTO t1 (c3) VALUES (null);
!                     ^
  INSERT INTO t1 (c1) VALUES (5); -- fail, but see columns being inserted or have SELECT
! ERROR:  relation "t1" does not exist
! LINE 1: INSERT INTO t1 (c1) VALUES (5);
!                     ^
  UPDATE t1 SET c3 = 10; -- fail, but see columns with SELECT rights, or being modified
! ERROR:  relation "t1" does not exist
! LINE 1: UPDATE t1 SET c3 = 10;
!                ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  DROP TABLE t1;
+ ERROR:  table "t1" does not exist
  -- test column-level privileges when involved with DELETE
  SET SESSION AUTHORIZATION regress_priv_user1;
  ALTER TABLE atest6 ADD COLUMN three integer;
+ ERROR:  relation "atest6" does not exist
  GRANT DELETE ON atest5 TO regress_priv_user3;
+ ERROR:  relation "atest5" does not exist
  GRANT SELECT (two) ON atest5 TO regress_priv_user3;
+ ERROR:  relation "atest5" does not exist
  REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
+ ERROR:  relation "atest5" does not exist
  GRANT SELECT (one) ON atest5 TO regress_priv_user4;
+ ERROR:  relation "atest5" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT atest6 FROM atest6; -- fail
! ERROR:  relation "atest6" does not exist
! LINE 1: SELECT atest6 FROM atest6;
!                            ^
  SELECT one FROM atest5 NATURAL JOIN atest6; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one FROM atest5 NATURAL JOIN atest6;
!                         ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  ALTER TABLE atest6 DROP COLUMN three;
+ ERROR:  relation "atest6" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT atest6 FROM atest6; -- ok
! ERROR:  relation "atest6" does not exist
! LINE 1: SELECT atest6 FROM atest6;
!                            ^
  SELECT one FROM atest5 NATURAL JOIN atest6; -- ok
! ERROR:  relation "atest5" does not exist
! LINE 1: SELECT one FROM atest5 NATURAL JOIN atest6;
!                         ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  ALTER TABLE atest6 DROP COLUMN two;
+ ERROR:  relation "atest6" does not exist
  REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
+ ERROR:  relation "atest6" does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT * FROM atest6; -- fail
! ERROR:  relation "atest6" does not exist
! LINE 1: SELECT * FROM atest6;
!                       ^
  SELECT 1 FROM atest6; -- fail
! ERROR:  relation "atest6" does not exist
! LINE 1: SELECT 1 FROM atest6;
!                       ^
  SET SESSION AUTHORIZATION regress_priv_user3;
  DELETE FROM atest5 WHERE one = 1; -- fail
! ERROR:  relation "atest5" does not exist
! LINE 1: DELETE FROM atest5 WHERE one = 1;
!                     ^
  DELETE FROM atest5 WHERE two = 2; -- ok
+ ERROR:  relation "atest5" does not exist
+ LINE 1: DELETE FROM atest5 WHERE two = 2;
+                     ^
  -- check inheritance cases
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS;
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atestp1 (f1 int, f2 int) WITH OIDS;
+                      ^
  CREATE TABLE atestp2 (fx int, fy int) WITH OIDS;
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atestp2 (fx int, fy int) WITH OIDS;
+                      ^
  CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
+                      ^
  GRANT SELECT(fx,fy,oid) ON atestp2 TO regress_priv_user2;
+ ERROR:  relation "atestp2" does not exist
  GRANT SELECT(fx) ON atestc TO regress_priv_user2;
+ ERROR:  relation "atestc" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT fx FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fx FROM atestp2;
!                        ^
  SELECT fy FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fy FROM atestp2;
!                        ^
  SELECT atestp2 FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT atestp2 FROM atestp2;
!                             ^
  SELECT oid FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT oid FROM atestp2;
!                         ^
  SELECT fy FROM atestc; -- fail
! ERROR:  relation "atestc" does not exist
! LINE 1: SELECT fy FROM atestc;
!                        ^
  SET SESSION AUTHORIZATION regress_priv_user1;
  GRANT SELECT(fy,oid) ON atestc TO regress_priv_user2;
+ ERROR:  relation "atestc" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT fx FROM atestp2; -- still ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fx FROM atestp2;
!                        ^
  SELECT fy FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT fy FROM atestp2;
!                        ^
  SELECT atestp2 FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT atestp2 FROM atestp2;
!                             ^
  SELECT oid FROM atestp2; -- ok
! ERROR:  relation "atestp2" does not exist
! LINE 1: SELECT oid FROM atestp2;
!                         ^
  -- privileges on functions, languages
  -- switch to superuser
  \c -
***************
*** 707,789 ****
  GRANT USAGE ON LANGUAGE sql TO regress_priv_user2; -- fail
  WARNING:  no privileges were granted for "sql"
  CREATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
  CREATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
  CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
  CREATE PROCEDURE priv_testproc1(int) AS 'select $1;' LANGUAGE sql;
  REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
  GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
  REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC; -- fail, not a function
! ERROR:  priv_testproc1(integer) is not a function
  REVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
  GRANT EXECUTE ON PROCEDURE priv_testproc1(int) TO regress_priv_user2;
  GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3; -- semantic error
! ERROR:  invalid privilege type USAGE for function
  GRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3; -- semantic error
! ERROR:  invalid privilege type USAGE for function
  GRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3; -- semantic error
! ERROR:  invalid privilege type USAGE for procedure
  GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc1(int) TO regress_priv_user4;
  GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
  ERROR:  function priv_testfunc_nosuch(integer) does not exist
  GRANT ALL PRIVILEGES ON FUNCTION priv_testagg1(int) TO regress_priv_user4;
  GRANT ALL PRIVILEGES ON PROCEDURE priv_testproc1(int) TO regress_priv_user4;
  CREATE FUNCTION priv_testfunc4(boolean) RETURNS text
    AS 'select col1 from atest2 where col2 = $1;'
    LANGUAGE sql SECURITY DEFINER;
  GRANT EXECUTE ON FUNCTION priv_testfunc4(boolean) TO regress_priv_user3;
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT priv_testfunc1(5), priv_testfunc2(5); -- ok
!  priv_testfunc1 | priv_testfunc2 
! ----------------+----------------
!              10 |             15
! (1 row)
! 
  CREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- fail
! ERROR:  permission denied for language sql
  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
!  priv_testagg1 
! ---------------
!              6
! (1 row)
! 
  CALL priv_testproc1(6); -- ok
  SET SESSION AUTHORIZATION regress_priv_user3;
  SELECT priv_testfunc1(5); -- fail
! ERROR:  permission denied for function priv_testfunc1
  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- fail
! ERROR:  permission denied for aggregate priv_testagg1
  CALL priv_testproc1(6); -- fail
! ERROR:  permission denied for procedure priv_testproc1
  SELECT col1 FROM atest2 WHERE col2 = true; -- fail
! ERROR:  permission denied for table atest2
  SELECT priv_testfunc4(true); -- ok
!  priv_testfunc4 
! ----------------
!  bar
! (1 row)
! 
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT priv_testfunc1(5); -- ok
!  priv_testfunc1 
! ----------------
!              10
! (1 row)
! 
  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
!  priv_testagg1 
! ---------------
!              6
! (1 row)
! 
  CALL priv_testproc1(6); -- ok
  DROP FUNCTION priv_testfunc1(int); -- fail
! ERROR:  must be owner of function priv_testfunc1
  DROP AGGREGATE priv_testagg1(int); -- fail
! ERROR:  must be owner of aggregate priv_testagg1
  DROP PROCEDURE priv_testproc1(int); -- fail
! ERROR:  must be owner of procedure priv_testproc1
  \c -
  DROP FUNCTION priv_testfunc1(int); -- ok
  -- restore to sanity
  GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
  -- verify privilege checks on array-element coercions
--- 873,983 ----
  GRANT USAGE ON LANGUAGE sql TO regress_priv_user2; -- fail
  WARNING:  no privileges were granted for "sql"
  CREATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql;
+ ERROR:  no schema has been selected to create in
  CREATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 * $1;' LANGUAGE sql;
+ ERROR:  no schema has been selected to create in
  CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
+ ERROR:  no schema has been selected to create in
  CREATE PROCEDURE priv_testproc1(int) AS 'select $1;' LANGUAGE sql;
+ ERROR:  no schema has been selected to create in
  REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
+ ERROR:  function priv_testfunc1(integer) does not exist
  GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
+ ERROR:  function priv_testfunc1(integer) does not exist
  REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC; -- fail, not a function
! ERROR:  function priv_testproc1(integer) does not exist
  REVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
+ ERROR:  procedure priv_testproc1(integer) does not exist
  GRANT EXECUTE ON PROCEDURE priv_testproc1(int) TO regress_priv_user2;
+ ERROR:  procedure priv_testproc1(integer) does not exist
  GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3; -- semantic error
! ERROR:  function priv_testfunc1(integer) does not exist
  GRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3; -- semantic error
! ERROR:  function priv_testagg1(integer) does not exist
  GRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3; -- semantic error
! ERROR:  procedure priv_testproc1(integer) does not exist
  GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc1(int) TO regress_priv_user4;
+ ERROR:  function priv_testfunc1(integer) does not exist
  GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
  ERROR:  function priv_testfunc_nosuch(integer) does not exist
  GRANT ALL PRIVILEGES ON FUNCTION priv_testagg1(int) TO regress_priv_user4;
+ ERROR:  function priv_testagg1(integer) does not exist
  GRANT ALL PRIVILEGES ON PROCEDURE priv_testproc1(int) TO regress_priv_user4;
+ ERROR:  procedure priv_testproc1(integer) does not exist
  CREATE FUNCTION priv_testfunc4(boolean) RETURNS text
    AS 'select col1 from atest2 where col2 = $1;'
    LANGUAGE sql SECURITY DEFINER;
+ ERROR:  no schema has been selected to create in
  GRANT EXECUTE ON FUNCTION priv_testfunc4(boolean) TO regress_priv_user3;
+ ERROR:  function priv_testfunc4(boolean) does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT priv_testfunc1(5), priv_testfunc2(5); -- ok
! ERROR:  function priv_testfunc1(integer) does not exist
! LINE 1: SELECT priv_testfunc1(5), priv_testfunc2(5);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  CREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;' LANGUAGE sql; -- fail
! ERROR:  no schema has been selected to create in
  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
! ERROR:  function priv_testagg1(integer) does not exist
! LINE 1: SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  CALL priv_testproc1(6); -- ok
+ ERROR:  procedure priv_testproc1(integer) does not exist
+ LINE 1: CALL priv_testproc1(6);
+              ^
+ HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
  SET SESSION AUTHORIZATION regress_priv_user3;
  SELECT priv_testfunc1(5); -- fail
! ERROR:  function priv_testfunc1(integer) does not exist
! LINE 1: SELECT priv_testfunc1(5);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- fail
! ERROR:  function priv_testagg1(integer) does not exist
! LINE 1: SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  CALL priv_testproc1(6); -- fail
! ERROR:  procedure priv_testproc1(integer) does not exist
! LINE 1: CALL priv_testproc1(6);
!              ^
! HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
  SELECT col1 FROM atest2 WHERE col2 = true; -- fail
! ERROR:  relation "atest2" does not exist
! LINE 1: SELECT col1 FROM atest2 WHERE col2 = true;
!                          ^
  SELECT priv_testfunc4(true); -- ok
! ERROR:  function priv_testfunc4(boolean) does not exist
! LINE 1: SELECT priv_testfunc4(true);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  SET SESSION AUTHORIZATION regress_priv_user4;
  SELECT priv_testfunc1(5); -- ok
! ERROR:  function priv_testfunc1(integer) does not exist
! LINE 1: SELECT priv_testfunc1(5);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x); -- ok
! ERROR:  function priv_testagg1(integer) does not exist
! LINE 1: SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  CALL priv_testproc1(6); -- ok
+ ERROR:  procedure priv_testproc1(integer) does not exist
+ LINE 1: CALL priv_testproc1(6);
+              ^
+ HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.
  DROP FUNCTION priv_testfunc1(int); -- fail
! ERROR:  function priv_testfunc1(integer) does not exist
  DROP AGGREGATE priv_testagg1(int); -- fail
! ERROR:  aggregate priv_testagg1(integer) does not exist
  DROP PROCEDURE priv_testproc1(int); -- fail
! ERROR:  procedure priv_testproc1(integer) does not exist
  \c -
  DROP FUNCTION priv_testfunc1(int); -- ok
+ ERROR:  function priv_testfunc1(integer) does not exist
  -- restore to sanity
  GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
  -- verify privilege checks on array-element coercions
***************
*** 823,912 ****
  SET SESSION AUTHORIZATION regress_priv_user1;
  -- commands that should fail
  CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
! ERROR:  permission denied for type priv_testdomain1
  CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
! ERROR:  permission denied for type priv_testdomain1
  CREATE DOMAIN priv_testdomain3a AS int;
  CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3a AS $$ SELECT $1::priv_testdomain3a $$ LANGUAGE SQL;
  CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
! ERROR:  permission denied for type priv_testdomain1
  DROP FUNCTION castfunc(int) CASCADE;
  DROP DOMAIN priv_testdomain3a;
  CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
! ERROR:  permission denied for type priv_testdomain1
  CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
! ERROR:  permission denied for type priv_testdomain1
  CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
! ERROR:  permission denied for type priv_testdomain1
  CREATE TABLE test5a (a int, b priv_testdomain1);
! ERROR:  permission denied for type priv_testdomain1
  CREATE TABLE test6a OF priv_testtype1;
! ERROR:  permission denied for type priv_testtype1
  CREATE TABLE test10a (a int[], b priv_testtype1[]);
! ERROR:  permission denied for type priv_testtype1
  CREATE TABLE test9a (a int, b int);
  ALTER TABLE test9a ADD COLUMN c priv_testdomain1;
! ERROR:  permission denied for type priv_testdomain1
  ALTER TABLE test9a ALTER COLUMN b TYPE priv_testdomain1;
! ERROR:  permission denied for type priv_testdomain1
  CREATE TYPE test7a AS (a int, b priv_testdomain1);
! ERROR:  permission denied for type priv_testdomain1
  CREATE TYPE test8a AS (a int, b int);
  ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
! ERROR:  permission denied for type priv_testdomain1
  ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
! ERROR:  permission denied for type priv_testdomain1
  CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
! ERROR:  permission denied for type priv_testdomain1
  REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
! ERROR:  permission denied for type priv_testtype1
  SET SESSION AUTHORIZATION regress_priv_user2;
  -- commands that should succeed
  CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
  CREATE DOMAIN priv_testdomain2b AS priv_testdomain1;
  CREATE DOMAIN priv_testdomain3b AS int;
  CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3b AS $$ SELECT $1::priv_testdomain3b $$ LANGUAGE SQL;
  CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
! WARNING:  cast will be ignored because the source data type is a domain
  CREATE FUNCTION priv_testfunc5b(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
  CREATE FUNCTION priv_testfunc6b(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
  CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
  CREATE TABLE test5b (a int, b priv_testdomain1);
  CREATE TABLE test6b OF priv_testtype1;
  CREATE TABLE test10b (a int[], b priv_testtype1[]);
  CREATE TABLE test9b (a int, b int);
  ALTER TABLE test9b ADD COLUMN c priv_testdomain1;
  ALTER TABLE test9b ALTER COLUMN b TYPE priv_testdomain1;
  CREATE TYPE test7b AS (a int, b priv_testdomain1);
  CREATE TYPE test8b AS (a int, b int);
  ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
  ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
  CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
  REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
! WARNING:  no privileges could be revoked for "priv_testtype1"
  \c -
  DROP AGGREGATE priv_testagg1b(priv_testdomain1);
  DROP DOMAIN priv_testdomain2b;
  DROP OPERATOR !! (NONE, priv_testdomain1);
  DROP FUNCTION priv_testfunc5b(a priv_testdomain1);
  DROP FUNCTION priv_testfunc6b(b int);
  DROP TABLE test5b;
  DROP TABLE test6b;
  DROP TABLE test9b;
  DROP TABLE test10b;
  DROP TYPE test7b;
  DROP TYPE test8b;
  DROP CAST (priv_testdomain1 AS priv_testdomain3b);
  DROP FUNCTION castfunc(int) CASCADE;
  DROP DOMAIN priv_testdomain3b;
  DROP TABLE test11b;
  DROP TYPE priv_testtype1; -- ok
  DROP DOMAIN priv_testdomain1; -- ok
  -- truncate
  SET SESSION AUTHORIZATION regress_priv_user5;
  TRUNCATE atest2; -- ok
  TRUNCATE atest3; -- fail
! ERROR:  permission denied for table atest3
  -- has_table_privilege function
  -- bad-input checks
  select has_table_privilege(NULL,'pg_authid','select');
--- 1017,1166 ----
  SET SESSION AUTHORIZATION regress_priv_user1;
  -- commands that should fail
  CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
! ERROR:  no schema has been selected to create in
  CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
! ERROR:  type "priv_testdomain1" does not exist
  CREATE DOMAIN priv_testdomain3a AS int;
+ ERROR:  no schema has been selected to create in
  CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3a AS $$ SELECT $1::priv_testdomain3a $$ LANGUAGE SQL;
+ ERROR:  no schema has been selected to create in
  CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
! ERROR:  type "priv_testdomain1" does not exist
  DROP FUNCTION castfunc(int) CASCADE;
+ ERROR:  function castfunc(integer) does not exist
  DROP DOMAIN priv_testdomain3a;
+ ERROR:  type "priv_testdomain3a" does not exist
  CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
! ERROR:  no schema has been selected to create in
  CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
! ERROR:  no schema has been selected to create in
  CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
! ERROR:  no schema has been selected to create in
  CREATE TABLE test5a (a int, b priv_testdomain1);
! ERROR:  no schema has been selected to create in
! LINE 1: CREATE TABLE test5a (a int, b priv_testdomain1);
!                      ^
  CREATE TABLE test6a OF priv_testtype1;
! ERROR:  no schema has been selected to create in
! LINE 1: CREATE TABLE test6a OF priv_testtype1;
!                      ^
  CREATE TABLE test10a (a int[], b priv_testtype1[]);
! ERROR:  no schema has been selected to create in
! LINE 1: CREATE TABLE test10a (a int[], b priv_testtype1[]);
!                      ^
  CREATE TABLE test9a (a int, b int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE test9a (a int, b int);
+                      ^
  ALTER TABLE test9a ADD COLUMN c priv_testdomain1;
! ERROR:  relation "test9a" does not exist
  ALTER TABLE test9a ALTER COLUMN b TYPE priv_testdomain1;
! ERROR:  relation "test9a" does not exist
  CREATE TYPE test7a AS (a int, b priv_testdomain1);
! ERROR:  no schema has been selected to create in
  CREATE TYPE test8a AS (a int, b int);
+ ERROR:  no schema has been selected to create in
  ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
! ERROR:  relation "test8a" does not exist
  ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
! ERROR:  relation "test8a" does not exist
  CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
! ERROR:  type "priv_testdomain1" does not exist
! LINE 1: CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
!                                            ^
  REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
! ERROR:  type "priv_testtype1" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  -- commands that should succeed
  CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
+ ERROR:  no schema has been selected to create in
  CREATE DOMAIN priv_testdomain2b AS priv_testdomain1;
+ ERROR:  type "priv_testdomain1" does not exist
  CREATE DOMAIN priv_testdomain3b AS int;
+ ERROR:  no schema has been selected to create in
  CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3b AS $$ SELECT $1::priv_testdomain3b $$ LANGUAGE SQL;
+ ERROR:  no schema has been selected to create in
  CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
! ERROR:  type "priv_testdomain1" does not exist
  CREATE FUNCTION priv_testfunc5b(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
+ ERROR:  no schema has been selected to create in
  CREATE FUNCTION priv_testfunc6b(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
+ ERROR:  no schema has been selected to create in
  CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
+ ERROR:  no schema has been selected to create in
  CREATE TABLE test5b (a int, b priv_testdomain1);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE test5b (a int, b priv_testdomain1);
+                      ^
  CREATE TABLE test6b OF priv_testtype1;
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE test6b OF priv_testtype1;
+                      ^
  CREATE TABLE test10b (a int[], b priv_testtype1[]);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE test10b (a int[], b priv_testtype1[]);
+                      ^
  CREATE TABLE test9b (a int, b int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE test9b (a int, b int);
+                      ^
  ALTER TABLE test9b ADD COLUMN c priv_testdomain1;
+ ERROR:  relation "test9b" does not exist
  ALTER TABLE test9b ALTER COLUMN b TYPE priv_testdomain1;
+ ERROR:  relation "test9b" does not exist
  CREATE TYPE test7b AS (a int, b priv_testdomain1);
+ ERROR:  no schema has been selected to create in
  CREATE TYPE test8b AS (a int, b int);
+ ERROR:  no schema has been selected to create in
  ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
+ ERROR:  relation "test8b" does not exist
  ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
+ ERROR:  relation "test8b" does not exist
  CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
+ ERROR:  type "priv_testdomain1" does not exist
+ LINE 1: CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
+                                            ^
  REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
! ERROR:  type "priv_testtype1" does not exist
  \c -
  DROP AGGREGATE priv_testagg1b(priv_testdomain1);
+ ERROR:  aggregate priv_testagg1b(priv_testdomain1) does not exist
  DROP DOMAIN priv_testdomain2b;
+ ERROR:  type "priv_testdomain2b" does not exist
  DROP OPERATOR !! (NONE, priv_testdomain1);
+ ERROR:  operator does not exist: !! priv_testdomain1
  DROP FUNCTION priv_testfunc5b(a priv_testdomain1);
+ ERROR:  function priv_testfunc5b(priv_testdomain1) does not exist
  DROP FUNCTION priv_testfunc6b(b int);
+ ERROR:  function priv_testfunc6b(integer) does not exist
  DROP TABLE test5b;
+ ERROR:  table "test5b" does not exist
  DROP TABLE test6b;
+ ERROR:  table "test6b" does not exist
  DROP TABLE test9b;
+ ERROR:  table "test9b" does not exist
  DROP TABLE test10b;
+ ERROR:  table "test10b" does not exist
  DROP TYPE test7b;
+ ERROR:  type "test7b" does not exist
  DROP TYPE test8b;
+ ERROR:  type "test8b" does not exist
  DROP CAST (priv_testdomain1 AS priv_testdomain3b);
+ ERROR:  type "priv_testdomain3b" does not exist
  DROP FUNCTION castfunc(int) CASCADE;
+ ERROR:  function castfunc(integer) does not exist
  DROP DOMAIN priv_testdomain3b;
+ ERROR:  type "priv_testdomain3b" does not exist
  DROP TABLE test11b;
+ ERROR:  table "test11b" does not exist
  DROP TYPE priv_testtype1; -- ok
  DROP DOMAIN priv_testdomain1; -- ok
  -- truncate
  SET SESSION AUTHORIZATION regress_priv_user5;
  TRUNCATE atest2; -- ok
+ ERROR:  relation "atest2" does not exist
  TRUNCATE atest3; -- fail
! ERROR:  relation "atest3" does not exist
  -- has_table_privilege function
  -- bad-input checks
  select has_table_privilege(NULL,'pg_authid','select');
***************
*** 1109,1193 ****
  (1 row)
  
  select has_table_privilege(current_user,'atest1','select');
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
  select has_table_privilege(current_user,'atest1','insert');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  select has_table_privilege(t2.oid,'atest1','update')
  from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  select has_table_privilege(t2.oid,'atest1','delete')
  from (select oid from pg_roles where rolname = current_user) as t2;
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  select has_table_privilege(current_user,t1.oid,'references')
  from (select oid from pg_class where relname = 'atest1') as t1;
   has_table_privilege 
  ---------------------
!  f
! (1 row)
  
  select has_table_privilege(t2.oid,t1.oid,'select')
  from (select oid from pg_class where relname = 'atest1') as t1,
    (select oid from pg_roles where rolname = current_user) as t2;
   has_table_privilege 
  ---------------------
!  t
! (1 row)
  
  select has_table_privilege(t2.oid,t1.oid,'insert')
  from (select oid from pg_class where relname = 'atest1') as t1,
    (select oid from pg_roles where rolname = current_user) as t2;
   has_table_privilege 
  ---------------------
!  f
! (1 row)
  
  select has_table_privilege('atest1','update');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  select has_table_privilege('atest1','delete');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  select has_table_privilege('atest1','truncate');
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  select has_table_privilege(t1.oid,'select')
  from (select oid from pg_class where relname = 'atest1') as t1;
   has_table_privilege 
  ---------------------
!  t
! (1 row)
  
  select has_table_privilege(t1.oid,'trigger')
  from (select oid from pg_class where relname = 'atest1') as t1;
   has_table_privilege 
  ---------------------
!  f
! (1 row)
  
  -- has_column_privilege function
  -- bad-input checks (as non-super-user)
--- 1363,1414 ----
  (1 row)
  
  select has_table_privilege(current_user,'atest1','select');
! ERROR:  relation "atest1" does not exist
  select has_table_privilege(current_user,'atest1','insert');
! ERROR:  relation "atest1" does not exist
  select has_table_privilege(t2.oid,'atest1','update')
  from (select oid from pg_roles where rolname = current_user) as t2;
! ERROR:  relation "atest1" does not exist
  select has_table_privilege(t2.oid,'atest1','delete')
  from (select oid from pg_roles where rolname = current_user) as t2;
! ERROR:  relation "atest1" does not exist
  select has_table_privilege(current_user,t1.oid,'references')
  from (select oid from pg_class where relname = 'atest1') as t1;
   has_table_privilege 
  ---------------------
! (0 rows)
  
  select has_table_privilege(t2.oid,t1.oid,'select')
  from (select oid from pg_class where relname = 'atest1') as t1,
    (select oid from pg_roles where rolname = current_user) as t2;
   has_table_privilege 
  ---------------------
! (0 rows)
  
  select has_table_privilege(t2.oid,t1.oid,'insert')
  from (select oid from pg_class where relname = 'atest1') as t1,
    (select oid from pg_roles where rolname = current_user) as t2;
   has_table_privilege 
  ---------------------
! (0 rows)
  
  select has_table_privilege('atest1','update');
! ERROR:  relation "atest1" does not exist
  select has_table_privilege('atest1','delete');
! ERROR:  relation "atest1" does not exist
  select has_table_privilege('atest1','truncate');
! ERROR:  relation "atest1" does not exist
  select has_table_privilege(t1.oid,'select')
  from (select oid from pg_class where relname = 'atest1') as t1;
   has_table_privilege 
  ---------------------
! (0 rows)
  
  select has_table_privilege(t1.oid,'trigger')
  from (select oid from pg_class where relname = 'atest1') as t1;
   has_table_privilege 
  ---------------------
! (0 rows)
  
  -- has_column_privilege function
  -- bad-input checks (as non-super-user)
***************
*** 1240,1296 ****
  (1 row)
  
  revoke select on table mytable from regress_priv_user3;
  select has_column_privilege('mytable',2::int2,'select');
   has_column_privilege 
  ----------------------
!  
  (1 row)
  
  drop table mytable;
  -- Grant options
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atest4 (a int);
  GRANT SELECT ON atest4 TO regress_priv_user2 WITH GRANT OPTION;
  GRANT UPDATE ON atest4 TO regress_priv_user2;
  GRANT SELECT ON atest4 TO GROUP regress_priv_group1 WITH GRANT OPTION;
  SET SESSION AUTHORIZATION regress_priv_user2;
  GRANT SELECT ON atest4 TO regress_priv_user3;
  GRANT UPDATE ON atest4 TO regress_priv_user3; -- fail
! WARNING:  no privileges were granted for "atest4"
  SET SESSION AUTHORIZATION regress_priv_user1;
  REVOKE SELECT ON atest4 FROM regress_priv_user3; -- does nothing
  SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
  REVOKE SELECT ON atest4 FROM regress_priv_user2; -- fail
! ERROR:  dependent privileges exist
! HINT:  Use CASCADE to revoke them too.
  REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE; -- ok
  SELECT has_table_privilege('regress_priv_user2', 'atest4', 'SELECT'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
  SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- false
!  has_table_privilege 
! ---------------------
!  f
! (1 row)
! 
  SELECT has_table_privilege('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true
!  has_table_privilege 
! ---------------------
!  t
! (1 row)
! 
  -- Admin options
  SET SESSION AUTHORIZATION regress_priv_user4;
  CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
  	'GRANT regress_priv_group2 TO regress_priv_user5';
  GRANT regress_priv_group2 TO regress_priv_user5; -- ok: had ADMIN OPTION
  SET ROLE regress_priv_group2;
  GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE suspended privilege
--- 1461,1511 ----
  (1 row)
  
  revoke select on table mytable from regress_priv_user3;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  select has_column_privilege('mytable',2::int2,'select');
   has_column_privilege 
  ----------------------
!  t
  (1 row)
  
  drop table mytable;
  -- Grant options
  SET SESSION AUTHORIZATION regress_priv_user1;
  CREATE TABLE atest4 (a int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE atest4 (a int);
+                      ^
  GRANT SELECT ON atest4 TO regress_priv_user2 WITH GRANT OPTION;
+ ERROR:  relation "atest4" does not exist
  GRANT UPDATE ON atest4 TO regress_priv_user2;
+ ERROR:  relation "atest4" does not exist
  GRANT SELECT ON atest4 TO GROUP regress_priv_group1 WITH GRANT OPTION;
+ ERROR:  relation "atest4" does not exist
  SET SESSION AUTHORIZATION regress_priv_user2;
  GRANT SELECT ON atest4 TO regress_priv_user3;
+ ERROR:  relation "atest4" does not exist
  GRANT UPDATE ON atest4 TO regress_priv_user3; -- fail
! ERROR:  relation "atest4" does not exist
  SET SESSION AUTHORIZATION regress_priv_user1;
  REVOKE SELECT ON atest4 FROM regress_priv_user3; -- does nothing
+ ERROR:  relation "atest4" does not exist
  SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- true
! ERROR:  relation "atest4" does not exist
  REVOKE SELECT ON atest4 FROM regress_priv_user2; -- fail
! ERROR:  relation "atest4" does not exist
  REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE; -- ok
+ ERROR:  relation "atest4" does not exist
  SELECT has_table_privilege('regress_priv_user2', 'atest4', 'SELECT'); -- true
! ERROR:  relation "atest4" does not exist
  SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT'); -- false
! ERROR:  relation "atest4" does not exist
  SELECT has_table_privilege('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true
! ERROR:  relation "atest4" does not exist
  -- Admin options
  SET SESSION AUTHORIZATION regress_priv_user4;
  CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
  	'GRANT regress_priv_group2 TO regress_priv_user5';
+ ERROR:  no schema has been selected to create in
  GRANT regress_priv_group2 TO regress_priv_user5; -- ok: had ADMIN OPTION
  SET ROLE regress_priv_group2;
  GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE suspended privilege
***************
*** 1299,1310 ****
  GRANT regress_priv_group2 TO regress_priv_user5; -- fails: no ADMIN OPTION
  ERROR:  must have admin option on role "regress_priv_group2"
  SELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMIN
! NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
!  dogrant_ok 
! ------------
!  
! (1 row)
! 
  SET ROLE regress_priv_group2;
  GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE did not help
  ERROR:  must have admin option on role "regress_priv_group2"
--- 1514,1523 ----
  GRANT regress_priv_group2 TO regress_priv_user5; -- fails: no ADMIN OPTION
  ERROR:  must have admin option on role "regress_priv_group2"
  SELECT dogrant_ok();			-- ok: SECURITY DEFINER conveys ADMIN
! ERROR:  function dogrant_ok() does not exist
! LINE 1: SELECT dogrant_ok();
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  SET ROLE regress_priv_group2;
  GRANT regress_priv_group2 TO regress_priv_user5; -- fails: SET ROLE did not help
  ERROR:  must have admin option on role "regress_priv_group2"
***************
*** 1313,1331 ****
  NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
  CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS
  	'GRANT regress_priv_group2 TO regress_priv_user5';
  SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINER
! ERROR:  must have admin option on role "regress_priv_group2"
! CONTEXT:  SQL function "dogrant_fails" statement 1
  DROP FUNCTION dogrant_fails();
  SET SESSION AUTHORIZATION regress_priv_user4;
  DROP FUNCTION dogrant_ok();
  REVOKE regress_priv_group2 FROM regress_priv_user5;
  -- has_sequence_privilege tests
  \c -
  CREATE SEQUENCE x_seq;
  GRANT USAGE on x_seq to regress_priv_user2;
  SELECT has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');
! ERROR:  "atest1" is not a sequence
  SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');
  ERROR:  unrecognized privilege type: "INSERT"
  SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'SELECT');
--- 1526,1549 ----
  NOTICE:  role "regress_priv_user5" is already a member of role "regress_priv_group2"
  CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS
  	'GRANT regress_priv_group2 TO regress_priv_user5';
+ ERROR:  no schema has been selected to create in
  SELECT dogrant_fails();			-- fails: no self-admin in SECURITY DEFINER
! ERROR:  function dogrant_fails() does not exist
! LINE 1: SELECT dogrant_fails();
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  DROP FUNCTION dogrant_fails();
+ ERROR:  function dogrant_fails() does not exist
  SET SESSION AUTHORIZATION regress_priv_user4;
  DROP FUNCTION dogrant_ok();
+ ERROR:  function dogrant_ok() does not exist
  REVOKE regress_priv_group2 FROM regress_priv_user5;
  -- has_sequence_privilege tests
  \c -
  CREATE SEQUENCE x_seq;
  GRANT USAGE on x_seq to regress_priv_user2;
  SELECT has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');
! ERROR:  relation "atest1" does not exist
  SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');
  ERROR:  unrecognized privilege type: "INSERT"
  SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'SELECT');
***************
*** 1336,1346 ****
  
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT has_sequence_privilege('x_seq', 'USAGE');
!  has_sequence_privilege 
! ------------------------
!  t
! (1 row)
! 
  -- largeobject privilege tests
  \c -
  SET SESSION AUTHORIZATION regress_priv_user1;
--- 1554,1560 ----
  
  SET SESSION AUTHORIZATION regress_priv_user2;
  SELECT has_sequence_privilege('x_seq', 'USAGE');
! ERROR:  relation "x_seq" does not exist
  -- largeobject privilege tests
  \c -
  SET SESSION AUTHORIZATION regress_priv_user1;
***************
*** 1920,1996 ****
  \c -
  set session role regress_priv_user1;
  create table dep_priv_test (a int);
  grant select on dep_priv_test to regress_priv_user2 with grant option;
  grant select on dep_priv_test to regress_priv_user3 with grant option;
  set session role regress_priv_user2;
  grant select on dep_priv_test to regress_priv_user4 with grant option;
  set session role regress_priv_user3;
  grant select on dep_priv_test to regress_priv_user4 with grant option;
  set session role regress_priv_user4;
  grant select on dep_priv_test to regress_priv_user5;
  \dp dep_priv_test
!                                                Access privileges
!  Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------------------+-------------------+----------
!  public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
!         |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
!         |               |       | regress_priv_user3=r*/regress_priv_user1     +|                   | 
!         |               |       | regress_priv_user4=r*/regress_priv_user2     +|                   | 
!         |               |       | regress_priv_user4=r*/regress_priv_user3     +|                   | 
!         |               |       | regress_priv_user5=r/regress_priv_user4       |                   | 
! (1 row)
  
  set session role regress_priv_user2;
  revoke select on dep_priv_test from regress_priv_user4 cascade;
  \dp dep_priv_test
!                                                Access privileges
!  Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------------------+-------------------+----------
!  public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
!         |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
!         |               |       | regress_priv_user3=r*/regress_priv_user1     +|                   | 
!         |               |       | regress_priv_user4=r*/regress_priv_user3     +|                   | 
!         |               |       | regress_priv_user5=r/regress_priv_user4       |                   | 
! (1 row)
  
  set session role regress_priv_user3;
  revoke select on dep_priv_test from regress_priv_user4 cascade;
  \dp dep_priv_test
!                                                Access privileges
!  Schema |     Name      | Type  |               Access privileges               | Column privileges | Policies 
! --------+---------------+-------+-----------------------------------------------+-------------------+----------
!  public | dep_priv_test | table | regress_priv_user1=arwdDxt/regress_priv_user1+|                   | 
!         |               |       | regress_priv_user2=r*/regress_priv_user1     +|                   | 
!         |               |       | regress_priv_user3=r*/regress_priv_user1      |                   | 
! (1 row)
  
  set session role regress_priv_user1;
  drop table dep_priv_test;
  -- clean up
  \c
  drop sequence x_seq;
  DROP AGGREGATE priv_testagg1(int);
  DROP FUNCTION priv_testfunc2(int);
  DROP FUNCTION priv_testfunc4(boolean);
  DROP PROCEDURE priv_testproc1(int);
  DROP VIEW atestv0;
  DROP VIEW atestv1;
  DROP VIEW atestv2;
  -- this should cascade to drop atestv4
  DROP VIEW atestv3 CASCADE;
! NOTICE:  drop cascades to view atestv4
  -- this should complain "does not exist"
  DROP VIEW atestv4;
  ERROR:  view "atestv4" does not exist
  DROP TABLE atest1;
  DROP TABLE atest2;
  DROP TABLE atest3;
  DROP TABLE atest4;
  DROP TABLE atest5;
  DROP TABLE atest6;
  DROP TABLE atestc;
  DROP TABLE atestp1;
  DROP TABLE atestp2;
  SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
   lo_unlink 
  -----------
--- 2134,2223 ----
  \c -
  set session role regress_priv_user1;
  create table dep_priv_test (a int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: create table dep_priv_test (a int);
+                      ^
  grant select on dep_priv_test to regress_priv_user2 with grant option;
+ ERROR:  relation "dep_priv_test" does not exist
  grant select on dep_priv_test to regress_priv_user3 with grant option;
+ ERROR:  relation "dep_priv_test" does not exist
  set session role regress_priv_user2;
  grant select on dep_priv_test to regress_priv_user4 with grant option;
+ ERROR:  relation "dep_priv_test" does not exist
  set session role regress_priv_user3;
  grant select on dep_priv_test to regress_priv_user4 with grant option;
+ ERROR:  relation "dep_priv_test" does not exist
  set session role regress_priv_user4;
  grant select on dep_priv_test to regress_priv_user5;
+ ERROR:  relation "dep_priv_test" does not exist
  \dp dep_priv_test
!                             Access privileges
!  Schema | Name | Type | Access privileges | Column privileges | Policies 
! --------+------+------+-------------------+-------------------+----------
! (0 rows)
  
  set session role regress_priv_user2;
  revoke select on dep_priv_test from regress_priv_user4 cascade;
+ ERROR:  relation "dep_priv_test" does not exist
  \dp dep_priv_test
!                             Access privileges
!  Schema | Name | Type | Access privileges | Column privileges | Policies 
! --------+------+------+-------------------+-------------------+----------
! (0 rows)
  
  set session role regress_priv_user3;
  revoke select on dep_priv_test from regress_priv_user4 cascade;
+ ERROR:  relation "dep_priv_test" does not exist
  \dp dep_priv_test
!                             Access privileges
!  Schema | Name | Type | Access privileges | Column privileges | Policies 
! --------+------+------+-------------------+-------------------+----------
! (0 rows)
  
  set session role regress_priv_user1;
  drop table dep_priv_test;
+ ERROR:  table "dep_priv_test" does not exist
  -- clean up
  \c
  drop sequence x_seq;
  DROP AGGREGATE priv_testagg1(int);
+ ERROR:  aggregate priv_testagg1(integer) does not exist
  DROP FUNCTION priv_testfunc2(int);
+ ERROR:  function priv_testfunc2(integer) does not exist
  DROP FUNCTION priv_testfunc4(boolean);
+ ERROR:  function priv_testfunc4(boolean) does not exist
  DROP PROCEDURE priv_testproc1(int);
+ ERROR:  procedure priv_testproc1(integer) does not exist
  DROP VIEW atestv0;
+ ERROR:  view "atestv0" does not exist
  DROP VIEW atestv1;
+ ERROR:  view "atestv1" does not exist
  DROP VIEW atestv2;
+ ERROR:  view "atestv2" does not exist
  -- this should cascade to drop atestv4
  DROP VIEW atestv3 CASCADE;
! ERROR:  view "atestv3" does not exist
  -- this should complain "does not exist"
  DROP VIEW atestv4;
  ERROR:  view "atestv4" does not exist
  DROP TABLE atest1;
+ ERROR:  table "atest1" does not exist
  DROP TABLE atest2;
+ ERROR:  table "atest2" does not exist
  DROP TABLE atest3;
+ ERROR:  table "atest3" does not exist
  DROP TABLE atest4;
+ ERROR:  table "atest4" does not exist
  DROP TABLE atest5;
+ ERROR:  table "atest5" does not exist
  DROP TABLE atest6;
+ ERROR:  table "atest6" does not exist
  DROP TABLE atestc;
+ ERROR:  table "atestc" does not exist
  DROP TABLE atestp1;
+ ERROR:  table "atestp1" does not exist
  DROP TABLE atestp2;
+ ERROR:  table "atestp2" does not exist
  SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
   lo_unlink 
  -----------
***************
*** 2021,2034 ****
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should pass
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  \c
  REVOKE SELECT ON lock_table FROM regress_locktable_user;
--- 2248,2262 ----
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  \c
  REVOKE SELECT ON lock_table FROM regress_locktable_user;
***************
*** 2037,2050 ****
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  \c
  REVOKE INSERT ON lock_table FROM regress_locktable_user;
--- 2265,2279 ----
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  \c
  REVOKE INSERT ON lock_table FROM regress_locktable_user;
***************
*** 2053,2065 ****
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
  COMMIT;
  \c
  REVOKE UPDATE ON lock_table FROM regress_locktable_user;
--- 2282,2296 ----
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  \c
  REVOKE UPDATE ON lock_table FROM regress_locktable_user;
***************
*** 2068,2080 ****
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
  COMMIT;
  \c
  REVOKE DELETE ON lock_table FROM regress_locktable_user;
--- 2299,2313 ----
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  \c
  REVOKE DELETE ON lock_table FROM regress_locktable_user;
***************
*** 2083,2095 ****
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  permission denied for table lock_table
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
  COMMIT;
  \c
  REVOKE TRUNCATE ON lock_table FROM regress_locktable_user;
--- 2316,2330 ----
  SET SESSION AUTHORIZATION regress_locktable_user;
  BEGIN;
  LOCK TABLE lock_table IN ROW EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS SHARE MODE; -- should fail
! ERROR:  relation "lock_table" does not exist
  ROLLBACK;
  BEGIN;
  LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE; -- should pass
+ ERROR:  relation "lock_table" does not exist
  COMMIT;
  \c
  REVOKE TRUNCATE ON lock_table FROM regress_locktable_user;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/matview.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/matview.out	CENSORED
***************
*** 186,198 ****
  (3 rows)
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tm;
  REFRESH MATERIALIZED VIEW mvtest_tvm;
  SELECT * FROM mvtest_tm ORDER BY type;
   type | totamt 
  ------+--------
   x    |      5
   y    |     12
!  z    |     24
  (3 rows)
  
  SELECT * FROM mvtest_tvm ORDER BY type;
--- 186,199 ----
  (3 rows)
  
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_tm;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  REFRESH MATERIALIZED VIEW mvtest_tvm;
  SELECT * FROM mvtest_tm ORDER BY type;
   type | totamt 
  ------+--------
   x    |      5
   y    |     12
!  z    |     11
  (3 rows)
  
  SELECT * FROM mvtest_tvm ORDER BY type;
***************
*** 274,280 ****
  SELECT * FROM mvtest_tmm;
   grandtot 
  ----------
!        41
  (1 row)
  
  SELECT * FROM mvtest_tvmm;
--- 275,281 ----
  SELECT * FROM mvtest_tmm;
   grandtot 
  ----------
!        28
  (1 row)
  
  SELECT * FROM mvtest_tvmm;
***************
*** 304,310 ****
  ------+------+------
   x    |    5 |    5
   y    |   12 |   12
!  z    |   24 |   24
  (3 rows)
  
  -- make sure that dependencies are reported properly when they block the drop
--- 305,311 ----
  ------+------+------
   x    |    5 |    5
   y    |   12 |   12
!  z    |   11 |   24
  (3 rows)
  
  -- make sure that dependencies are reported properly when they block the drop
***************
*** 405,410 ****
--- 406,412 ----
  INSERT INTO mvtest_foo VALUES(3, 4, 5);
  REFRESH MATERIALIZED VIEW mvtest_mv;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  DROP TABLE mvtest_foo CASCADE;
  NOTICE:  drop cascades to materialized view mvtest_mv
  -- allow subquery to reference unpopulated matview if WITH NO DATA is specified
***************
*** 423,433 ****
  CREATE UNIQUE INDEX mvtest_boxmv_id ON mvtest_boxmv (id);
  UPDATE mvtest_boxes SET b = '(2,2),(1,1)' WHERE id = 2;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_boxmv;
  SELECT * FROM mvtest_boxmv ORDER BY id;
   id |              b              
  ----+-----------------------------
    1 | (32,32),(31,31)
!   2 | (2,2),(1,1)
    3 | (1.9999996,1.9999996),(1,1)
  (3 rows)
  
--- 425,436 ----
  CREATE UNIQUE INDEX mvtest_boxmv_id ON mvtest_boxmv (id);
  UPDATE mvtest_boxes SET b = '(2,2),(1,1)' WHERE id = 2;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_boxmv;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  SELECT * FROM mvtest_boxmv ORDER BY id;
   id |              b              
  ----+-----------------------------
    1 | (32,32),(31,31)
!   2 | (2.0000004,2.0000004),(1,1)
    3 | (1.9999996,1.9999996),(1,1)
  (3 rows)
  
***************
*** 449,454 ****
--- 452,458 ----
  REFRESH MATERIALIZED VIEW mvtest_mv_v;
  UPDATE mvtest_v SET j = 3 WHERE x = 1;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_v;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  REFRESH MATERIALIZED VIEW mvtest_mv_v_2;
  REFRESH MATERIALIZED VIEW mvtest_mv_v_3;
  REFRESH MATERIALIZED VIEW mvtest_mv_v_4;
***************
*** 461,467 ****
  SELECT * FROM mvtest_mv_v;
   ii | jj 
  ----+----
!   1 |  3
  (1 row)
  
  SELECT * FROM mvtest_mv_v_2;
--- 465,471 ----
  SELECT * FROM mvtest_mv_v;
   ii | jj 
  ----+----
!   1 |  2
  (1 row)
  
  SELECT * FROM mvtest_mv_v_2;
***************
*** 553,567 ****
  SET ROLE regress_user_mvtest;
  CREATE TABLE mvtest_foo_data AS SELECT i, md5(random()::text)
    FROM generate_series(1, 10) i;
  CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
  CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
! ERROR:  relation "mvtest_mv_foo" already exists
  CREATE MATERIALIZED VIEW IF NOT EXISTS mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
! NOTICE:  relation "mvtest_mv_foo" already exists, skipping
  CREATE UNIQUE INDEX ON mvtest_mv_foo (i);
  RESET ROLE;
  REFRESH MATERIALIZED VIEW mvtest_mv_foo;
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_foo;
  DROP OWNED BY regress_user_mvtest CASCADE;
  DROP ROLE regress_user_mvtest;
  -- make sure that create WITH NO DATA works via SPI
--- 557,582 ----
  SET ROLE regress_user_mvtest;
  CREATE TABLE mvtest_foo_data AS SELECT i, md5(random()::text)
    FROM generate_series(1, 10) i;
+ ERROR:  no schema has been selected to create in
  CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
+ ERROR:  relation "mvtest_foo_data" does not exist
+ LINE 1: ... MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo...
+                                                              ^
  CREATE MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
! ERROR:  relation "mvtest_foo_data" does not exist
! LINE 1: ... MATERIALIZED VIEW mvtest_mv_foo AS SELECT * FROM mvtest_foo...
!                                                              ^
  CREATE MATERIALIZED VIEW IF NOT EXISTS mvtest_mv_foo AS SELECT * FROM mvtest_foo_data;
! ERROR:  relation "mvtest_foo_data" does not exist
! LINE 1: ...VIEW IF NOT EXISTS mvtest_mv_foo AS SELECT * FROM mvtest_foo...
!                                                              ^
  CREATE UNIQUE INDEX ON mvtest_mv_foo (i);
+ ERROR:  relation "mvtest_mv_foo" does not exist
  RESET ROLE;
  REFRESH MATERIALIZED VIEW mvtest_mv_foo;
+ ERROR:  relation "mvtest_mv_foo" does not exist
  REFRESH MATERIALIZED VIEW CONCURRENTLY mvtest_mv_foo;
+ ERROR:  relation "mvtest_mv_foo" does not exist
  DROP OWNED BY regress_user_mvtest CASCADE;
  DROP ROLE regress_user_mvtest;
  -- make sure that create WITH NO DATA works via SPI

======================================================================

*** contrib/mmts/../../src/test/regress/expected/atx.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/atx.out	CENSORED
***************
*** 434,445 ****
  $body$ language plpgsql;
  commit;
  select atx_2_update_func();
!  atx_2_update_func 
! -------------------
!                100
! (1 row)
! 
  drop table atx_2_t1;
  drop table atx_2_t2;
  -- 3
  drop table if exists atx_3_t1;
--- 434,445 ----
  $body$ language plpgsql;
  commit;
  select atx_2_update_func();
! ERROR:  SPI_finish failed: SPI_ERROR_UNCONNECTED
! CONTEXT:  PL/pgSQL function atx_2_tmp_trigger_func() line 5 during exception cleanup
! SQL statement "update atx_2_t1 set name = txid_current()::text where id in ( select id from tmp1 )"
! PL/pgSQL function atx_2_update_func() line 6 at SQL statement
  drop table atx_2_t1;
+ ERROR:  StartTransactionCommand: unexpected state STARTED
  drop table atx_2_t2;
  -- 3
  drop table if exists atx_3_t1;
***************
*** 545,554 ****
--- 545,556 ----
      create temp table tmp1 on commit drop as select atx_4_t1.id from atx_4_t1 left join atx_4_t2 on atx_4_t1.id = atx_4_t2.id where atx_4_t2.id is null;
      delete from atx_4_t1 where id in ( select id from tmp1 );
    end;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
    begin autonomous;
      create temp table tmp1 on commit drop as select atx_4_t2.id from atx_4_t2 left join atx_4_t1 on atx_4_t1.id = atx_4_t2.id where atx_4_t1.id is null;
      delete from atx_4_t2 where id in ( select id from tmp1 );
    end;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  commit;
  drop table atx_4_t1;
  drop table atx_4_t2;
***************
*** 1148,1153 ****
--- 1150,1156 ----
  RESET client_min_messages;
  create database regression_atx_test_database;
  ALTER DATABASE "regression_atx_test_database" SET lc_messages TO 'C';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  \c regression_atx_test_database
  create table atx_test as select 1 as id;
  begin;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/atx3.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/atx3.out	CENSORED
***************
*** 28,37 ****
  end;
  $body$ language plpgsql;
  select atx_28_update_func();
!  atx_28_update_func 
! --------------------
!                   1
! (1 row)
! 
  drop table atx_28_t1;
  drop function atx_28_update_func();
--- 28,33 ----
  end;
  $body$ language plpgsql;
  select atx_28_update_func();
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  drop table atx_28_t1;
  drop function atx_28_update_func();

======================================================================

*** contrib/mmts/../../src/test/regress/expected/atx5.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/atx5.out	CENSORED
***************
*** 24,33 ****
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
!  x 
! ---
! (0 rows)
! 
  SET client_min_messages = 'warning';
  DROP FUNCTION IF EXISTS atx_test_30_one();
  DROP FUNCTION IF EXISTS atx_test_30_two();
--- 24,30 ----
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
! ERROR:  cannot PREPARE a transaction that has exported snapshots
  SET client_min_messages = 'warning';
  DROP FUNCTION IF EXISTS atx_test_30_one();
  DROP FUNCTION IF EXISTS atx_test_30_two();

======================================================================

*** contrib/mmts/../../src/test/regress/expected/alter_operator.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/alter_operator.out	CENSORED
***************
*** 130,136 ****
  CREATE USER regress_alter_op_user;
  SET SESSION AUTHORIZATION regress_alter_op_user;
  ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
! ERROR:  must be owner of operator ===
  -- Clean up
  RESET SESSION AUTHORIZATION;
  DROP USER regress_alter_op_user;
--- 130,136 ----
  CREATE USER regress_alter_op_user;
  SET SESSION AUTHORIZATION regress_alter_op_user;
  ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
! ERROR:  operator does not exist: boolean === boolean
  -- Clean up
  RESET SESSION AUTHORIZATION;
  DROP USER regress_alter_op_user;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/rules.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/rules.out	CENSORED
***************
*** 1283,1288 ****
--- 1283,1297 ----
  -- temporarily disable fancy output, so view changes create less diff noise
  \a\t
  SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schema' ORDER BY viewname;
+ _pg_prepared_xacts| SELECT p.transaction,
+     p.gid,
+     p.prepared,
+     u.rolname AS owner,
+     d.datname AS database,
+     p.state3pc
+    FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
+      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
+      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
  iexit| SELECT ih.name,
      ih.thepath,
      interpt_pp(ih.thepath, r.thepath) AS exit
***************
*** 1440,1454 ****
      p.parameter_types,
      p.from_sql
     FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
! pg_prepared_xacts| SELECT p.transaction,
!     p.gid,
!     p.prepared,
!     u.rolname AS owner,
!     d.datname AS database,
!     p.state3pc
!    FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
!      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
!      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
  pg_publication_tables| SELECT p.pubname,
      n.nspname AS schemaname,
      c.relname AS tablename
--- 1449,1462 ----
      p.parameter_types,
      p.from_sql
     FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
! pg_prepared_xacts| SELECT _pg_prepared_xacts.transaction,
!     _pg_prepared_xacts.gid,
!     _pg_prepared_xacts.prepared,
!     _pg_prepared_xacts.owner,
!     _pg_prepared_xacts.database,
!     _pg_prepared_xacts.state3pc
!    FROM _pg_prepared_xacts
!   WHERE (_pg_prepared_xacts.gid !~~ 'MTM-%'::text);
  pg_publication_tables| SELECT p.pubname,
      n.nspname AS schemaname,
      c.relname AS tablename

======================================================================

*** contrib/mmts/../../src/test/regress/expected/publication.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/publication.out	CENSORED
***************
*** 10,17 ****
  SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
   obj_description  
  ------------------
   test publication
! (1 row)
  
  CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);
  ALTER PUBLICATION testpub_default SET (publish = update);
--- 10,18 ----
  SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
   obj_description  
  ------------------
+  
   test publication
! (2 rows)
  
  CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);
  ALTER PUBLICATION testpub_default SET (publish = update);
***************
*** 24,41 ****
                                           List of publications
          Name        |          Owner           | All tables | Inserts | Updates | Deletes | Truncates 
  --------------------+--------------------------+------------+---------+---------+---------+-----------
   testpib_ins_trunct | regress_publication_user | f          | t       | f       | f       | f
   testpub_default    | regress_publication_user | f          | f       | t       | f       | f
! (2 rows)
  
  ALTER PUBLICATION testpub_default SET (publish = 'insert, update, delete');
  \dRp
                                           List of publications
          Name        |          Owner           | All tables | Inserts | Updates | Deletes | Truncates 
  --------------------+--------------------------+------------+---------+---------+---------+-----------
   testpib_ins_trunct | regress_publication_user | f          | t       | f       | f       | f
   testpub_default    | regress_publication_user | f          | t       | t       | t       | f
! (2 rows)
  
  --- adding tables
  CREATE SCHEMA pub_test;
--- 25,44 ----
                                           List of publications
          Name        |          Owner           | All tables | Inserts | Updates | Deletes | Truncates 
  --------------------+--------------------------+------------+---------+---------+---------+-----------
+  multimaster        | alex                     | f          | t       | f       | f       | t
   testpib_ins_trunct | regress_publication_user | f          | t       | f       | f       | f
   testpub_default    | regress_publication_user | f          | f       | t       | f       | f
! (3 rows)
  
  ALTER PUBLICATION testpub_default SET (publish = 'insert, update, delete');
  \dRp
                                           List of publications
          Name        |          Owner           | All tables | Inserts | Updates | Deletes | Truncates 
  --------------------+--------------------------+------------+---------+---------+---------+-----------
+  multimaster        | alex                     | f          | t       | f       | f       | t
   testpib_ins_trunct | regress_publication_user | f          | t       | f       | f       | f
   testpub_default    | regress_publication_user | f          | t       | t       | t       | f
! (3 rows)
  
  --- adding tables
  CREATE SCHEMA pub_test;
***************
*** 198,208 ****
  SET ROLE regress_publication_user2;
  CREATE PUBLICATION testpub2;  -- ok
  ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- fail
! ERROR:  must be owner of table testpub_tbl1
  SET ROLE regress_publication_user;
  GRANT regress_publication_user TO regress_publication_user2;
  SET ROLE regress_publication_user2;
  ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- ok
  DROP PUBLICATION testpub2;
  SET ROLE regress_publication_user;
  REVOKE CREATE ON DATABASE regression FROM regress_publication_user2;
--- 201,212 ----
  SET ROLE regress_publication_user2;
  CREATE PUBLICATION testpub2;  -- ok
  ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- fail
! ERROR:  relation "testpub_tbl1" does not exist
  SET ROLE regress_publication_user;
  GRANT regress_publication_user TO regress_publication_user2;
  SET ROLE regress_publication_user2;
  ALTER PUBLICATION testpub2 ADD TABLE testpub_tbl1;  -- ok
+ ERROR:  relation "testpub_tbl1" does not exist
  DROP PUBLICATION testpub2;
  SET ROLE regress_publication_user;
  REVOKE CREATE ON DATABASE regression FROM regress_publication_user2;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/subscription.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/subscription.out	CENSORED
***************
*** 34,41 ****
  SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
    obj_description  
  -------------------
   test subscription
! (1 row)
  
  -- fail - name already exists
  CREATE SUBSCRIPTION testsub CONNECTION 'dbname=doesnotexist' PUBLICATION testpub WITH (connect = false);
--- 34,43 ----
  SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
    obj_description  
  -------------------
+  
+  
   test subscription
! (3 rows)
  
  -- fail - name already exists
  CREATE SUBSCRIPTION testsub CONNECTION 'dbname=doesnotexist' PUBLICATION testpub WITH (connect = false);
***************
*** 76,86 ****
  ERROR:  invalid connection string syntax: missing "=" after "foobar" in connection info string
  
  \dRs+
!                                          List of subscriptions
!   Name   |           Owner           | Enabled | Publication | Synchronous commit |      Conninfo       
! ---------+---------------------------+---------+-------------+--------------------+---------------------
!  testsub | regress_subscription_user | f       | {testpub}   | off                | dbname=doesnotexist
! (1 row)
  
  ALTER SUBSCRIPTION testsub SET PUBLICATION testpub2, testpub3 WITH (refresh = false);
  ALTER SUBSCRIPTION testsub CONNECTION 'dbname=doesnotexist2';
--- 78,90 ----
  ERROR:  invalid connection string syntax: missing "=" after "foobar" in connection info string
  
  \dRs+
!                                                         List of subscriptions
!    Name    |           Owner           | Enabled |  Publication  | Synchronous commit |                   Conninfo                    
! -----------+---------------------------+---------+---------------+--------------------+-----------------------------------------------
!  mtm_sub_2 | alex                      | f       | {multimaster} | off                | port=55433 host=127.0.0.1 dbname='regression'
!  mtm_sub_3 | alex                      | f       | {multimaster} | off                | port=55434 host=127.0.0.1 dbname='regression'
!  testsub   | regress_subscription_user | f       | {testpub}     | off                | dbname=doesnotexist
! (3 rows)
  
  ALTER SUBSCRIPTION testsub SET PUBLICATION testpub2, testpub3 WITH (refresh = false);
  ALTER SUBSCRIPTION testsub CONNECTION 'dbname=doesnotexist2';
***************
*** 91,118 ****
  ALTER SUBSCRIPTION testsub SET (create_slot = false);
  ERROR:  unrecognized subscription parameter: create_slot
  \dRs+
!                                               List of subscriptions
!   Name   |           Owner           | Enabled |     Publication     | Synchronous commit |       Conninfo       
! ---------+---------------------------+---------+---------------------+--------------------+----------------------
!  testsub | regress_subscription_user | f       | {testpub2,testpub3} | off                | dbname=doesnotexist2
! (1 row)
  
  BEGIN;
  ALTER SUBSCRIPTION testsub ENABLE;
  \dRs
!                         List of subscriptions
!   Name   |           Owner           | Enabled |     Publication     
! ---------+---------------------------+---------+---------------------
!  testsub | regress_subscription_user | t       | {testpub2,testpub3}
! (1 row)
  
  ALTER SUBSCRIPTION testsub DISABLE;
  \dRs
!                         List of subscriptions
!   Name   |           Owner           | Enabled |     Publication     
! ---------+---------------------------+---------+---------------------
!  testsub | regress_subscription_user | f       | {testpub2,testpub3}
! (1 row)
  
  COMMIT;
  -- fail - must be owner of subscription
--- 95,128 ----
  ALTER SUBSCRIPTION testsub SET (create_slot = false);
  ERROR:  unrecognized subscription parameter: create_slot
  \dRs+
!                                                            List of subscriptions
!    Name    |           Owner           | Enabled |     Publication     | Synchronous commit |                   Conninfo                    
! -----------+---------------------------+---------+---------------------+--------------------+-----------------------------------------------
!  mtm_sub_2 | alex                      | f       | {multimaster}       | off                | port=55433 host=127.0.0.1 dbname='regression'
!  mtm_sub_3 | alex                      | f       | {multimaster}       | off                | port=55434 host=127.0.0.1 dbname='regression'
!  testsub   | regress_subscription_user | f       | {testpub2,testpub3} | off                | dbname=doesnotexist2
! (3 rows)
  
  BEGIN;
  ALTER SUBSCRIPTION testsub ENABLE;
  \dRs
!                          List of subscriptions
!    Name    |           Owner           | Enabled |     Publication     
! -----------+---------------------------+---------+---------------------
!  mtm_sub_2 | alex                      | f       | {multimaster}
!  mtm_sub_3 | alex                      | f       | {multimaster}
!  testsub   | regress_subscription_user | t       | {testpub2,testpub3}
! (3 rows)
  
  ALTER SUBSCRIPTION testsub DISABLE;
  \dRs
!                          List of subscriptions
!    Name    |           Owner           | Enabled |     Publication     
! -----------+---------------------------+---------+---------------------
!  mtm_sub_2 | alex                      | f       | {multimaster}
!  mtm_sub_3 | alex                      | f       | {multimaster}
!  testsub   | regress_subscription_user | f       | {testpub2,testpub3}
! (3 rows)
  
  COMMIT;
  -- fail - must be owner of subscription
***************
*** 126,136 ****
  ERROR:  invalid value for parameter "synchronous_commit": "foobar"
  HINT:  Available values: local, remote_write, remote_apply, on, off.
  \dRs+
!                                                 List of subscriptions
!     Name     |           Owner           | Enabled |     Publication     | Synchronous commit |       Conninfo       
! -------------+---------------------------+---------+---------------------+--------------------+----------------------
   testsub_foo | regress_subscription_user | f       | {testpub2,testpub3} | local              | dbname=doesnotexist2
! (1 row)
  
  -- rename back to keep the rest simple
  ALTER SUBSCRIPTION testsub_foo RENAME TO testsub;
--- 136,148 ----
  ERROR:  invalid value for parameter "synchronous_commit": "foobar"
  HINT:  Available values: local, remote_write, remote_apply, on, off.
  \dRs+
!                                                             List of subscriptions
!     Name     |           Owner           | Enabled |     Publication     | Synchronous commit |                   Conninfo                    
! -------------+---------------------------+---------+---------------------+--------------------+-----------------------------------------------
!  mtm_sub_2   | alex                      | f       | {multimaster}       | off                | port=55433 host=127.0.0.1 dbname='regression'
!  mtm_sub_3   | alex                      | f       | {multimaster}       | off                | port=55434 host=127.0.0.1 dbname='regression'
   testsub_foo | regress_subscription_user | f       | {testpub2,testpub3} | local              | dbname=doesnotexist2
! (3 rows)
  
  -- rename back to keep the rest simple
  ALTER SUBSCRIPTION testsub_foo RENAME TO testsub;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/select_views.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/select_views.out	CENSORED
***************
*** 1317,1445 ****
  --           prior to the security policy of the view.
  --
  SELECT * FROM my_property_normal WHERE f_leak(passwd);
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal WHERE f_leak(passwd);
!                           QUERY PLAN                          
! --------------------------------------------------------------
!  Seq Scan on customer
!    Filter: (f_leak(passwd) AND (name = (CURRENT_USER)::text))
! (2 rows)
! 
  SELECT * FROM my_property_secure WHERE f_leak(passwd);
! NOTICE:  f_leak => passwd123
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure WHERE f_leak(passwd);
!                   QUERY PLAN                   
! -----------------------------------------------
!  Subquery Scan on my_property_secure
!    Filter: f_leak(my_property_secure.passwd)
!    ->  Seq Scan on customer
!          Filter: (name = (CURRENT_USER)::text)
! (4 rows)
! 
  --
  -- scenario: qualifiers can be pushed down if they contain leaky functions,
  --           provided they aren't passed data from inside the view.
  --
  SELECT * FROM my_property_normal v
  		WHERE f_leak('passwd') AND f_leak(passwd);
! NOTICE:  f_leak => passwd
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => passwd
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => passwd
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal v
  		WHERE f_leak('passwd') AND f_leak(passwd);
!                                        QUERY PLAN                                        
! -----------------------------------------------------------------------------------------
!  Seq Scan on customer
!    Filter: (f_leak('passwd'::text) AND f_leak(passwd) AND (name = (CURRENT_USER)::text))
! (2 rows)
! 
  SELECT * FROM my_property_secure v
  		WHERE f_leak('passwd') AND f_leak(passwd);
! NOTICE:  f_leak => passwd
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => passwd
! NOTICE:  f_leak => passwd
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure v
  		WHERE f_leak('passwd') AND f_leak(passwd);
!                                  QUERY PLAN                                 
! ----------------------------------------------------------------------------
!  Subquery Scan on v
!    Filter: f_leak(v.passwd)
!    ->  Seq Scan on customer
!          Filter: (f_leak('passwd'::text) AND (name = (CURRENT_USER)::text))
! (4 rows)
! 
  --
  -- scenario: if a qualifier references only one-side of a particular join-
  --           tree, it shall be distributed to the most deep scan plan as
  --           possible as we can.
  --
  SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
! NOTICE:  f_leak => 1111-2222-3333-4444
! NOTICE:  f_leak => 5555-6666-7777-8888
! NOTICE:  f_leak => 9801-2345-6789-0123
!  cid |     name      |       tel        |  passwd   |        cnum         | climit 
! -----+---------------+------------------+-----------+---------------------+--------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
!                      QUERY PLAN                      
! -----------------------------------------------------
!  Hash Join
!    Hash Cond: (r.cid = l.cid)
!    ->  Seq Scan on credit_card r
!          Filter: f_leak(cnum)
!    ->  Hash
!          ->  Seq Scan on customer l
!                Filter: (name = (CURRENT_USER)::text)
! (7 rows)
! 
  SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
! NOTICE:  f_leak => 1111-2222-3333-4444
!  cid |     name      |       tel        |  passwd   |        cnum         | climit 
! -----+---------------+------------------+-----------+---------------------+--------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000
! (1 row)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
!                         QUERY PLAN                         
! -----------------------------------------------------------
!  Subquery Scan on my_credit_card_secure
!    Filter: f_leak(my_credit_card_secure.cnum)
!    ->  Hash Join
!          Hash Cond: (r.cid = l.cid)
!          ->  Seq Scan on credit_card r
!          ->  Hash
!                ->  Seq Scan on customer l
!                      Filter: (name = (CURRENT_USER)::text)
! (8 rows)
! 
  --
  -- scenario: an external qualifier can be pushed-down by in-front-of the
  --           views with "security_barrier" attribute, except for operators
--- 1317,1382 ----
  --           prior to the security policy of the view.
  --
  SELECT * FROM my_property_normal WHERE f_leak(passwd);
! ERROR:  relation "my_property_normal" does not exist
! LINE 1: SELECT * FROM my_property_normal WHERE f_leak(passwd);
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal WHERE f_leak(passwd);
! ERROR:  relation "my_property_normal" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal WHERE f...
!                                           ^
  SELECT * FROM my_property_secure WHERE f_leak(passwd);
! ERROR:  relation "my_property_secure" does not exist
! LINE 1: SELECT * FROM my_property_secure WHERE f_leak(passwd);
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure WHERE f_leak(passwd);
! ERROR:  relation "my_property_secure" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure WHERE f...
!                                           ^
  --
  -- scenario: qualifiers can be pushed down if they contain leaky functions,
  --           provided they aren't passed data from inside the view.
  --
  SELECT * FROM my_property_normal v
  		WHERE f_leak('passwd') AND f_leak(passwd);
! ERROR:  relation "my_property_normal" does not exist
! LINE 1: SELECT * FROM my_property_normal v
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal v
  		WHERE f_leak('passwd') AND f_leak(passwd);
! ERROR:  relation "my_property_normal" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_property_normal v
!                                           ^
  SELECT * FROM my_property_secure v
  		WHERE f_leak('passwd') AND f_leak(passwd);
! ERROR:  relation "my_property_secure" does not exist
! LINE 1: SELECT * FROM my_property_secure v
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure v
  		WHERE f_leak('passwd') AND f_leak(passwd);
! ERROR:  relation "my_property_secure" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_property_secure v
!                                           ^
  --
  -- scenario: if a qualifier references only one-side of a particular join-
  --           tree, it shall be distributed to the most deep scan plan as
  --           possible as we can.
  --
  SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_normal" does not exist
! LINE 1: SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_normal" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_normal WHER...
!                                           ^
  SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_secure" does not exist
! LINE 1: SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHERE f_leak(cnum);
! ERROR:  relation "my_credit_card_secure" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_secure WHER...
!                                           ^
  --
  -- scenario: an external qualifier can be pushed-down by in-front-of the
  --           views with "security_barrier" attribute, except for operators
***************
*** 1447,1552 ****
  --
  SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! NOTICE:  f_leak => 1111-2222-3333-4444
!  cid |     name      |       tel        |  passwd   |        cnum         | climit |    ymd     | usage 
! -----+---------------+------------------+-----------+---------------------+--------+------------+-------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-05-2011 |    90
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-18-2011 |   110
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-21-2011 |   200
! (3 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!                                   QUERY PLAN                                  
! ------------------------------------------------------------------------------
!  Nested Loop
!    Join Filter: (l.cid = r.cid)
!    ->  Seq Scan on credit_usage r
!          Filter: ((ymd >= '10-01-2011'::date) AND (ymd < '11-01-2011'::date))
!    ->  Materialize
!          ->  Subquery Scan on l
!                Filter: f_leak(l.cnum)
!                ->  Hash Join
!                      Hash Cond: (r_1.cid = l_1.cid)
!                      ->  Seq Scan on credit_card r_1
!                      ->  Hash
!                            ->  Seq Scan on customer l_1
!                                  Filter: (name = (CURRENT_USER)::text)
! (13 rows)
! 
  SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! NOTICE:  f_leak => 1111-2222-3333-4444
! NOTICE:  f_leak => 1111-2222-3333-4444
! NOTICE:  f_leak => 1111-2222-3333-4444
!  cid |     name      |       tel        |  passwd   |        cnum         | climit |    ymd     | usage 
! -----+---------------+------------------+-----------+---------------------+--------+------------+-------
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-05-2011 |    90
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-18-2011 |   110
!  101 | regress_alice | +81-12-3456-7890 | passwd123 | 1111-2222-3333-4444 |   4000 | 10-21-2011 |   200
! (3 rows)
! 
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
!                                      QUERY PLAN                                     
! ------------------------------------------------------------------------------------
!  Subquery Scan on my_credit_card_usage_secure
!    Filter: f_leak(my_credit_card_usage_secure.cnum)
!    ->  Nested Loop
!          Join Filter: (l.cid = r.cid)
!          ->  Seq Scan on credit_usage r
!                Filter: ((ymd >= '10-01-2011'::date) AND (ymd < '11-01-2011'::date))
!          ->  Materialize
!                ->  Hash Join
!                      Hash Cond: (r_1.cid = l.cid)
!                      ->  Seq Scan on credit_card r_1
!                      ->  Hash
!                            ->  Seq Scan on customer l
!                                  Filter: (name = (CURRENT_USER)::text)
! (13 rows)
! 
  --
  -- Test for the case when security_barrier gets changed between rewriter
  -- and planner stage.
  --
  PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(passwd);
  PREPARE p2 AS SELECT * FROM my_property_secure WHERE f_leak(passwd);
  EXECUTE p1;
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  EXECUTE p2;
! NOTICE:  f_leak => passwd123
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  RESET SESSION AUTHORIZATION;
  ALTER VIEW my_property_normal SET (security_barrier=true);
  ALTER VIEW my_property_secure SET (security_barrier=false);
  SET SESSION AUTHORIZATION regress_alice;
  EXECUTE p1;		-- To be perform as a view with security-barrier
! NOTICE:  f_leak => passwd123
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  EXECUTE p2;		-- To be perform as a view without security-barrier
! NOTICE:  f_leak => passwd123
! NOTICE:  f_leak => beafsteak
! NOTICE:  f_leak => hamburger
!  cid |     name      |       tel        |  passwd   
! -----+---------------+------------------+-----------
!  101 | regress_alice | +81-12-3456-7890 | passwd123
! (1 row)
! 
  -- Cleanup.
  RESET SESSION AUTHORIZATION;
  DROP ROLE regress_alice;
--- 1384,1431 ----
  --
  SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_normal" does not exist
! LINE 1: SELECT * FROM my_credit_card_usage_normal
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_normal
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_normal" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_norma...
!                                           ^
  SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_secure" does not exist
! LINE 1: SELECT * FROM my_credit_card_usage_secure
!                       ^
  EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secure
         WHERE f_leak(cnum) AND ymd >= '2011-10-01' AND ymd < '2011-11-01';
! ERROR:  relation "my_credit_card_usage_secure" does not exist
! LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM my_credit_card_usage_secur...
!                                           ^
  --
  -- Test for the case when security_barrier gets changed between rewriter
  -- and planner stage.
  --
  PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(passwd);
+ ERROR:  relation "my_property_normal" does not exist
+ LINE 1: PREPARE p1 AS SELECT * FROM my_property_normal WHERE f_leak(...
+                                     ^
  PREPARE p2 AS SELECT * FROM my_property_secure WHERE f_leak(passwd);
+ ERROR:  relation "my_property_secure" does not exist
+ LINE 1: PREPARE p2 AS SELECT * FROM my_property_secure WHERE f_leak(...
+                                     ^
  EXECUTE p1;
! ERROR:  prepared statement "p1" does not exist
  EXECUTE p2;
! ERROR:  prepared statement "p2" does not exist
  RESET SESSION AUTHORIZATION;
  ALTER VIEW my_property_normal SET (security_barrier=true);
  ALTER VIEW my_property_secure SET (security_barrier=false);
  SET SESSION AUTHORIZATION regress_alice;
  EXECUTE p1;		-- To be perform as a view with security-barrier
! ERROR:  prepared statement "p1" does not exist
  EXECUTE p2;		-- To be perform as a view without security-barrier
! ERROR:  prepared statement "p2" does not exist
  -- Cleanup.
  RESET SESSION AUTHORIZATION;
  DROP ROLE regress_alice;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/foreign_key.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/foreign_key.out	CENSORED
***************
*** 1786,1800 ****
  grant references on fk_notpartitioned_pk to regress_other_partitioned_fk_owner;
  set role regress_other_partitioned_fk_owner;
  create table other_partitioned_fk(a int, b int) partition by list (a);
  create table other_partitioned_fk_1 partition of other_partitioned_fk
    for values in (2048);
  insert into other_partitioned_fk
    select 2048, x from generate_series(1,10) x;
  -- this should fail
  alter table other_partitioned_fk add foreign key (a, b)
    references fk_notpartitioned_pk(a, b);
! ERROR:  insert or update on table "other_partitioned_fk_1" violates foreign key constraint "other_partitioned_fk_a_fkey"
! DETAIL:  Key (a, b)=(2048, 1) is not present in table "fk_notpartitioned_pk".
  -- add the missing keys and retry
  reset role;
  insert into fk_notpartitioned_pk (a, b)
--- 1786,1808 ----
  grant references on fk_notpartitioned_pk to regress_other_partitioned_fk_owner;
  set role regress_other_partitioned_fk_owner;
  create table other_partitioned_fk(a int, b int) partition by list (a);
+ ERROR:  no schema has been selected to create in
+ LINE 1: create table other_partitioned_fk(a int, b int) partition by...
+                      ^
  create table other_partitioned_fk_1 partition of other_partitioned_fk
    for values in (2048);
+ ERROR:  no schema has been selected to create in
+ LINE 1: create table other_partitioned_fk_1 partition of other_parti...
+                      ^
  insert into other_partitioned_fk
    select 2048, x from generate_series(1,10) x;
+ ERROR:  relation "other_partitioned_fk" does not exist
+ LINE 1: insert into other_partitioned_fk
+                     ^
  -- this should fail
  alter table other_partitioned_fk add foreign key (a, b)
    references fk_notpartitioned_pk(a, b);
! ERROR:  relation "other_partitioned_fk" does not exist
  -- add the missing keys and retry
  reset role;
  insert into fk_notpartitioned_pk (a, b)
***************
*** 1802,1809 ****
--- 1810,1819 ----
  set role regress_other_partitioned_fk_owner;
  alter table other_partitioned_fk add foreign key (a, b)
    references fk_notpartitioned_pk(a, b);
+ ERROR:  relation "other_partitioned_fk" does not exist
  -- clean up
  drop table other_partitioned_fk;
+ ERROR:  table "other_partitioned_fk" does not exist
  reset role;
  revoke all on fk_notpartitioned_pk from regress_other_partitioned_fk_owner;
  drop role regress_other_partitioned_fk_owner;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/cluster.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/cluster.out	CENSORED
***************
*** 354,431 ****
  SELECT * FROM clstr_1 UNION ALL
    SELECT * FROM clstr_2 UNION ALL
    SELECT * FROM clstr_3;
!  a 
! ---
!  1
!  2
!  2
!  1
!  2
!  1
! (6 rows)
! 
  -- cluster a single table using the indisclustered bit previously set
  DELETE FROM clstr_1;
  INSERT INTO clstr_1 VALUES (2);
  INSERT INTO clstr_1 VALUES (1);
  CLUSTER clstr_1;
  SELECT * FROM clstr_1;
!  a 
! ---
!  1
!  2
! (2 rows)
! 
  -- Test MVCC-safety of cluster. There isn't much we can do to verify the
  -- results with a single backend...
  CREATE TABLE clustertest (key int PRIMARY KEY);
  INSERT INTO clustertest VALUES (10);
  INSERT INTO clustertest VALUES (20);
  INSERT INTO clustertest VALUES (30);
  INSERT INTO clustertest VALUES (40);
  INSERT INTO clustertest VALUES (50);
  -- Use a transaction so that updates are not committed when CLUSTER sees 'em
  BEGIN;
  -- Test update where the old row version is found first in the scan
  UPDATE clustertest SET key = 100 WHERE key = 10;
  -- Test update where the new row version is found first in the scan
  UPDATE clustertest SET key = 35 WHERE key = 40;
  -- Test longer update chain
  UPDATE clustertest SET key = 60 WHERE key = 50;
  UPDATE clustertest SET key = 70 WHERE key = 60;
  UPDATE clustertest SET key = 80 WHERE key = 70;
  SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!  100
!   35
!   80
! (5 rows)
! 
  CLUSTER clustertest_pkey ON clustertest;
  SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!   35
!   80
!  100
! (5 rows)
! 
  COMMIT;
  SELECT * FROM clustertest;
!  key 
! -----
!   20
!   30
!   35
!   80
!  100
! (5 rows)
! 
  -- check that temp tables can be clustered
  create temp table clstr_temp (col1 int primary key, col2 text);
  insert into clstr_temp values (2, 'two'), (1, 'one');
--- 354,435 ----
  SELECT * FROM clstr_1 UNION ALL
    SELECT * FROM clstr_2 UNION ALL
    SELECT * FROM clstr_3;
! ERROR:  relation "clstr_1" does not exist
! LINE 1: SELECT * FROM clstr_1 UNION ALL
!                       ^
  -- cluster a single table using the indisclustered bit previously set
  DELETE FROM clstr_1;
+ ERROR:  relation "clstr_1" does not exist
+ LINE 1: DELETE FROM clstr_1;
+                     ^
  INSERT INTO clstr_1 VALUES (2);
+ ERROR:  relation "clstr_1" does not exist
+ LINE 1: INSERT INTO clstr_1 VALUES (2);
+                     ^
  INSERT INTO clstr_1 VALUES (1);
+ ERROR:  relation "clstr_1" does not exist
+ LINE 1: INSERT INTO clstr_1 VALUES (1);
+                     ^
  CLUSTER clstr_1;
+ ERROR:  relation "clstr_1" does not exist
  SELECT * FROM clstr_1;
! ERROR:  relation "clstr_1" does not exist
! LINE 1: SELECT * FROM clstr_1;
!                       ^
  -- Test MVCC-safety of cluster. There isn't much we can do to verify the
  -- results with a single backend...
  CREATE TABLE clustertest (key int PRIMARY KEY);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE clustertest (key int PRIMARY KEY);
+                      ^
  INSERT INTO clustertest VALUES (10);
+ ERROR:  relation "clustertest" does not exist
+ LINE 1: INSERT INTO clustertest VALUES (10);
+                     ^
  INSERT INTO clustertest VALUES (20);
+ ERROR:  relation "clustertest" does not exist
+ LINE 1: INSERT INTO clustertest VALUES (20);
+                     ^
  INSERT INTO clustertest VALUES (30);
+ ERROR:  relation "clustertest" does not exist
+ LINE 1: INSERT INTO clustertest VALUES (30);
+                     ^
  INSERT INTO clustertest VALUES (40);
+ ERROR:  relation "clustertest" does not exist
+ LINE 1: INSERT INTO clustertest VALUES (40);
+                     ^
  INSERT INTO clustertest VALUES (50);
+ ERROR:  relation "clustertest" does not exist
+ LINE 1: INSERT INTO clustertest VALUES (50);
+                     ^
  -- Use a transaction so that updates are not committed when CLUSTER sees 'em
  BEGIN;
  -- Test update where the old row version is found first in the scan
  UPDATE clustertest SET key = 100 WHERE key = 10;
+ ERROR:  relation "clustertest" does not exist
+ LINE 1: UPDATE clustertest SET key = 100 WHERE key = 10;
+                ^
  -- Test update where the new row version is found first in the scan
  UPDATE clustertest SET key = 35 WHERE key = 40;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  -- Test longer update chain
  UPDATE clustertest SET key = 60 WHERE key = 50;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  UPDATE clustertest SET key = 70 WHERE key = 60;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  UPDATE clustertest SET key = 80 WHERE key = 70;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT * FROM clustertest;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  CLUSTER clustertest_pkey ON clustertest;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT * FROM clustertest;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COMMIT;
  SELECT * FROM clustertest;
! ERROR:  relation "clustertest" does not exist
! LINE 1: SELECT * FROM clustertest;
!                       ^
  -- check that temp tables can be clustered
  create temp table clstr_temp (col1 int primary key, col2 text);
  insert into clstr_temp values (2, 'two'), (1, 'one');
***************
*** 468,473 ****
--- 472,478 ----
  reset maintenance_work_mem;
  -- clean up
  DROP TABLE clustertest;
+ ERROR:  table "clustertest" does not exist
  DROP TABLE clstr_1;
  DROP TABLE clstr_2;
  DROP TABLE clstr_3;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/dependency.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/dependency.out	CENSORED
***************
*** 57,136 ****
  -- this one is allowed
  DROP OWNED BY regress_dep_user0;
  CREATE TABLE deptest1 (f1 int unique);
  GRANT ALL ON deptest1 TO regress_dep_user1 WITH GRANT OPTION;
  SET SESSION AUTHORIZATION regress_dep_user1;
  CREATE TABLE deptest (a serial primary key, b text);
  GRANT ALL ON deptest1 TO regress_dep_user2;
  RESET SESSION AUTHORIZATION;
  \z deptest1
!                                                Access privileges
!  Schema |   Name   | Type  |                 Access privileges                  | Column privileges | Policies 
! --------+----------+-------+----------------------------------------------------+-------------------+----------
!  public | deptest1 | table | regress_dep_user0=arwdDxt/regress_dep_user0       +|                   | 
!         |          |       | regress_dep_user1=a*r*w*d*D*x*t*/regress_dep_user0+|                   | 
!         |          |       | regress_dep_user2=arwdDxt/regress_dep_user1        |                   | 
! (1 row)
  
  DROP OWNED BY regress_dep_user1;
  -- all grants revoked
  \z deptest1
!                                            Access privileges
!  Schema |   Name   | Type  |              Access privileges              | Column privileges | Policies 
! --------+----------+-------+---------------------------------------------+-------------------+----------
!  public | deptest1 | table | regress_dep_user0=arwdDxt/regress_dep_user0 |                   | 
! (1 row)
  
  -- table was dropped
  \d deptest
  -- Test REASSIGN OWNED
  GRANT ALL ON deptest1 TO regress_dep_user1;
  GRANT CREATE ON DATABASE regression TO regress_dep_user1;
  SET SESSION AUTHORIZATION regress_dep_user1;
  CREATE SCHEMA deptest;
  CREATE TABLE deptest (a serial primary key, b text);
  ALTER DEFAULT PRIVILEGES FOR ROLE regress_dep_user1 IN SCHEMA deptest
    GRANT ALL ON TABLES TO regress_dep_user2;
  CREATE FUNCTION deptest_func() RETURNS void LANGUAGE plpgsql
    AS $$ BEGIN END; $$;
  CREATE TYPE deptest_enum AS ENUM ('red');
  CREATE TYPE deptest_range AS RANGE (SUBTYPE = int4);
  CREATE TABLE deptest2 (f1 int);
  -- make a serial column the hard way
  CREATE SEQUENCE ss1;
  ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
  ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
  -- When reassigning ownership of a composite type, its pg_class entry
  -- should match
  CREATE TYPE deptest_t AS (a int);
  SELECT typowner = relowner
  FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
   ?column? 
  ----------
!  t
! (1 row)
  
  RESET SESSION AUTHORIZATION;
  REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user2;
  \dt deptest
!               List of relations
!  Schema |  Name   | Type  |       Owner       
! --------+---------+-------+-------------------
!  public | deptest | table | regress_dep_user2
! (1 row)
  
  SELECT typowner = relowner
  FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
   ?column? 
  ----------
!  t
! (1 row)
  
  -- doesn't work: grant still exists
  DROP USER regress_dep_user1;
  ERROR:  role "regress_dep_user1" cannot be dropped because some objects depend on it
  DETAIL:  owner of default privileges on new relations belonging to role regress_dep_user1 in schema deptest
  privileges for database regression
- privileges for table deptest1
  DROP OWNED BY regress_dep_user1;
  DROP USER regress_dep_user1;
  \set VERBOSITY terse
--- 57,150 ----
  -- this one is allowed
  DROP OWNED BY regress_dep_user0;
  CREATE TABLE deptest1 (f1 int unique);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE deptest1 (f1 int unique);
+                      ^
  GRANT ALL ON deptest1 TO regress_dep_user1 WITH GRANT OPTION;
+ ERROR:  relation "deptest1" does not exist
  SET SESSION AUTHORIZATION regress_dep_user1;
  CREATE TABLE deptest (a serial primary key, b text);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE deptest (a serial primary key, b text);
+                      ^
  GRANT ALL ON deptest1 TO regress_dep_user2;
+ ERROR:  relation "deptest1" does not exist
  RESET SESSION AUTHORIZATION;
  \z deptest1
!                             Access privileges
!  Schema | Name | Type | Access privileges | Column privileges | Policies 
! --------+------+------+-------------------+-------------------+----------
! (0 rows)
  
  DROP OWNED BY regress_dep_user1;
  -- all grants revoked
  \z deptest1
!                             Access privileges
!  Schema | Name | Type | Access privileges | Column privileges | Policies 
! --------+------+------+-------------------+-------------------+----------
! (0 rows)
  
  -- table was dropped
  \d deptest
  -- Test REASSIGN OWNED
  GRANT ALL ON deptest1 TO regress_dep_user1;
+ ERROR:  relation "deptest1" does not exist
  GRANT CREATE ON DATABASE regression TO regress_dep_user1;
  SET SESSION AUTHORIZATION regress_dep_user1;
  CREATE SCHEMA deptest;
  CREATE TABLE deptest (a serial primary key, b text);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE deptest (a serial primary key, b text);
+                      ^
  ALTER DEFAULT PRIVILEGES FOR ROLE regress_dep_user1 IN SCHEMA deptest
    GRANT ALL ON TABLES TO regress_dep_user2;
  CREATE FUNCTION deptest_func() RETURNS void LANGUAGE plpgsql
    AS $$ BEGIN END; $$;
+ ERROR:  no schema has been selected to create in
  CREATE TYPE deptest_enum AS ENUM ('red');
+ ERROR:  no schema has been selected to create in
  CREATE TYPE deptest_range AS RANGE (SUBTYPE = int4);
+ ERROR:  no schema has been selected to create in
  CREATE TABLE deptest2 (f1 int);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE deptest2 (f1 int);
+                      ^
  -- make a serial column the hard way
  CREATE SEQUENCE ss1;
+ ERROR:  no schema has been selected to create in
  ALTER TABLE deptest2 ALTER f1 SET DEFAULT nextval('ss1');
+ ERROR:  relation "deptest2" does not exist
  ALTER SEQUENCE ss1 OWNED BY deptest2.f1;
+ ERROR:  relation "ss1" does not exist
  -- When reassigning ownership of a composite type, its pg_class entry
  -- should match
  CREATE TYPE deptest_t AS (a int);
+ ERROR:  no schema has been selected to create in
  SELECT typowner = relowner
  FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
   ?column? 
  ----------
! (0 rows)
  
  RESET SESSION AUTHORIZATION;
  REASSIGN OWNED BY regress_dep_user1 TO regress_dep_user2;
  \dt deptest
!       List of relations
!  Schema | Name | Type | Owner 
! --------+------+------+-------
! (0 rows)
  
  SELECT typowner = relowner
  FROM pg_type JOIN pg_class c ON typrelid = c.oid WHERE typname = 'deptest_t';
   ?column? 
  ----------
! (0 rows)
  
  -- doesn't work: grant still exists
  DROP USER regress_dep_user1;
  ERROR:  role "regress_dep_user1" cannot be dropped because some objects depend on it
  DETAIL:  owner of default privileges on new relations belonging to role regress_dep_user1 in schema deptest
  privileges for database regression
  DROP OWNED BY regress_dep_user1;
  DROP USER regress_dep_user1;
  \set VERBOSITY terse

======================================================================

*** contrib/mmts/../../src/test/regress/expected/guc.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/guc.out	CENSORED
***************
*** 537,543 ****
--- 537,545 ----
  SET vacuum_cost_delay = 13;
  CREATE TEMP TABLE tmp_foo (data text) ON COMMIT DELETE ROWS;
  CREATE ROLE regress_guc_user;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SET SESSION AUTHORIZATION regress_guc_user;
+ ERROR:  role "regress_guc_user" does not exist
  -- look changes
  SELECT pg_listening_channels();
   pg_listening_channels 
***************
*** 572,578 ****
  SELECT current_user = 'regress_guc_user';
   ?column? 
  ----------
!  t
  (1 row)
  
  -- discard everything
--- 574,580 ----
  SELECT current_user = 'regress_guc_user';
   ?column? 
  ----------
!  f
  (1 row)
  
  -- discard everything
***************
*** 611,616 ****
--- 613,619 ----
  (1 row)
  
  DROP ROLE regress_guc_user;
+ ERROR:  role "regress_guc_user" does not exist
  --
  -- search_path should react to changes in pg_namespace
  --

======================================================================

*** contrib/mmts/../../src/test/regress/expected/equivclass.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/equivclass.out	CENSORED
***************
*** 407,422 ****
  explain (costs off)
    select * from ec0 a, ec1 b
    where a.ff = b.ff and a.ff = 43::bigint::int8alias1;
!                  QUERY PLAN                  
! ---------------------------------------------
!  Nested Loop
!    ->  Index Scan using ec0_pkey on ec0 a
!          Index Cond: (ff = '43'::int8alias1)
!    ->  Index Scan using ec1_pkey on ec1 b
!          Index Cond: (ff = a.ff)
!          Filter: (f1 < '5'::int8alias1)
! (6 rows)
! 
  reset session authorization;
  revoke select on ec0 from regress_user_ectest;
  revoke select on ec1 from regress_user_ectest;
--- 407,415 ----
  explain (costs off)
    select * from ec0 a, ec1 b
    where a.ff = b.ff and a.ff = 43::bigint::int8alias1;
! ERROR:  relation "ec0" does not exist
! LINE 2:   select * from ec0 a, ec1 b
!                         ^
  reset session authorization;
  revoke select on ec0 from regress_user_ectest;
  revoke select on ec1 from regress_user_ectest;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/plancache.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/plancache.out	CENSORED
***************
*** 237,257 ****
  NOTICE:  1
  NOTICE:  2
  NOTICE:  3
!  cachebug 
! ----------
!  
! (1 row)
! 
  select cachebug();
! NOTICE:  drop cascades to view vv
  NOTICE:  1
  NOTICE:  2
  NOTICE:  3
!  cachebug 
! ----------
!  
! (1 row)
! 
  -- Check that addition or removal of any partition is correctly dealt with by
  -- default partition table when it is being used in prepared statement.
  create table pc_list_parted (a int) partition by list(a);
--- 237,249 ----
  NOTICE:  1
  NOTICE:  2
  NOTICE:  3
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  select cachebug();
! NOTICE:  table "temptable" does not exist, skipping
  NOTICE:  1
  NOTICE:  2
  NOTICE:  3
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  -- Check that addition or removal of any partition is correctly dealt with by
  -- default partition table when it is being used in prepared statement.
  create table pc_list_parted (a int) partition by list(a);

======================================================================

*** contrib/mmts/../../src/test/regress/expected/plpgsql.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/plpgsql.out	CENSORED
***************
*** 4323,4328 ****
--- 4323,4330 ----
  
  create function error1(text) returns text language sql as
  $$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
+ ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
+ CONTEXT:  SQL function "error1"
  create function error2(p_name_table text) returns text language plpgsql as $$
  begin
    return error1(p_name_table);
***************
*** 4331,4349 ****
  create table public.stuffs (stuff text);
  SAVEPOINT a;
  select error2('nonexistent.stuffs');
! ERROR:  schema "nonexistent" does not exist
! CONTEXT:  SQL function "error1" statement 1
! PL/pgSQL function error2(text) line 3 at RETURN
  ROLLBACK TO a;
  select error2('public.stuffs');
!  error2 
! --------
!  stuffs
! (1 row)
! 
  rollback;
  drop function error2(p_name_table text);
  drop function error1(text);
  -- Test for proper handling of cast-expression caching
  create function sql_to_date(integer) returns date as $$
  select $1::text::date
--- 4333,4356 ----
  create table public.stuffs (stuff text);
  SAVEPOINT a;
  select error2('nonexistent.stuffs');
! ERROR:  function error1(text) does not exist
! LINE 1: SELECT error1(p_name_table)
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! QUERY:  SELECT error1(p_name_table)
! CONTEXT:  PL/pgSQL function error2(text) line 3 at RETURN
  ROLLBACK TO a;
  select error2('public.stuffs');
! ERROR:  function error1(text) does not exist
! LINE 1: SELECT error1(p_name_table)
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
! QUERY:  SELECT error1(p_name_table)
! CONTEXT:  PL/pgSQL function error2(text) line 3 at RETURN
  rollback;
  drop function error2(p_name_table text);
  drop function error1(text);
+ ERROR:  function error1(text) does not exist
  -- Test for proper handling of cast-expression caching
  create function sql_to_date(integer) returns date as $$
  select $1::text::date

======================================================================

*** contrib/mmts/../../src/test/regress/expected/copy2.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/copy2.out	CENSORED
***************
*** 258,354 ****
  CREATE TABLE vistest (LIKE testeoc);
  COPY vistest FROM stdin CSV;
  COMMIT;
  SELECT * FROM vistest;
!  a  
! ----
!  a0
!  b
! (2 rows)
! 
  BEGIN;
  TRUNCATE vistest;
  COPY vistest FROM stdin CSV;
  SELECT * FROM vistest;
!  a  
! ----
!  a1
!  b
! (2 rows)
! 
  SAVEPOINT s1;
  TRUNCATE vistest;
  COPY vistest FROM stdin CSV;
  SELECT * FROM vistest;
!  a  
! ----
!  d1
!  e
! (2 rows)
! 
  COMMIT;
  SELECT * FROM vistest;
!  a  
! ----
!  d1
!  e
! (2 rows)
! 
  BEGIN;
  TRUNCATE vistest;
  COPY vistest FROM stdin CSV FREEZE;
  SELECT * FROM vistest;
!  a  
! ----
!  a2
!  b
! (2 rows)
! 
  SAVEPOINT s1;
  TRUNCATE vistest;
  COPY vistest FROM stdin CSV FREEZE;
  SELECT * FROM vistest;
!  a  
! ----
!  d2
!  e
! (2 rows)
! 
  COMMIT;
  SELECT * FROM vistest;
!  a  
! ----
!  d2
!  e
! (2 rows)
! 
  BEGIN;
  TRUNCATE vistest;
  COPY vistest FROM stdin CSV FREEZE;
  SELECT * FROM vistest;
!  a 
! ---
!  x
!  y
! (2 rows)
! 
  COMMIT;
  TRUNCATE vistest;
  COPY vistest FROM stdin CSV FREEZE;
! ERROR:  cannot perform FREEZE because the table was not created or truncated in the current subtransaction
! BEGIN;
  TRUNCATE vistest;
  SAVEPOINT s1;
  COPY vistest FROM stdin CSV FREEZE;
! ERROR:  cannot perform FREEZE because the table was not created or truncated in the current subtransaction
  COMMIT;
  BEGIN;
  INSERT INTO vistest VALUES ('z');
  SAVEPOINT s1;
  TRUNCATE vistest;
  ROLLBACK TO SAVEPOINT s1;
  COPY vistest FROM stdin CSV FREEZE;
! ERROR:  cannot perform FREEZE because the table was not created or truncated in the current subtransaction
  COMMIT;
  CREATE FUNCTION truncate_in_subxact() RETURNS VOID AS
  $$
  BEGIN
--- 258,393 ----
  CREATE TABLE vistest (LIKE testeoc);
  COPY vistest FROM stdin CSV;
  COMMIT;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  SELECT * FROM vistest;
! ERROR:  relation "vistest" does not exist
! LINE 1: SELECT * FROM vistest;
!                       ^
  BEGIN;
  TRUNCATE vistest;
+ ERROR:  relation "vistest" does not exist
  COPY vistest FROM stdin CSV;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
+ a1
+ b
+ \.
+ invalid command \.
  SELECT * FROM vistest;
! ERROR:  syntax error at or near "a1"
! LINE 1: a1
!         ^
  SAVEPOINT s1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  TRUNCATE vistest;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COPY vistest FROM stdin CSV;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
+ d1
+ e
+ \.
+ invalid command \.
  SELECT * FROM vistest;
! ERROR:  syntax error at or near "d1"
! LINE 1: d1
!         ^
  COMMIT;
  SELECT * FROM vistest;
! ERROR:  relation "vistest" does not exist
! LINE 1: SELECT * FROM vistest;
!                       ^
  BEGIN;
  TRUNCATE vistest;
+ ERROR:  relation "vistest" does not exist
  COPY vistest FROM stdin CSV FREEZE;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
+ a2
+ b
+ \.
+ invalid command \.
  SELECT * FROM vistest;
! ERROR:  syntax error at or near "a2"
! LINE 1: a2
!         ^
  SAVEPOINT s1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  TRUNCATE vistest;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COPY vistest FROM stdin CSV FREEZE;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
+ d2
+ e
+ \.
+ invalid command \.
  SELECT * FROM vistest;
! ERROR:  syntax error at or near "d2"
! LINE 1: d2
!         ^
  COMMIT;
  SELECT * FROM vistest;
! ERROR:  relation "vistest" does not exist
! LINE 1: SELECT * FROM vistest;
!                       ^
  BEGIN;
  TRUNCATE vistest;
+ ERROR:  relation "vistest" does not exist
  COPY vistest FROM stdin CSV FREEZE;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
+ x
+ y
+ \.
+ invalid command \.
  SELECT * FROM vistest;
! ERROR:  syntax error at or near "x"
! LINE 1: x
!         ^
  COMMIT;
  TRUNCATE vistest;
+ ERROR:  relation "vistest" does not exist
  COPY vistest FROM stdin CSV FREEZE;
! ERROR:  relation "vistest" does not exist
! p
! g
! \.
! invalid command \.
! BEGIN;
! ERROR:  syntax error at or near "p"
! LINE 1: p
!         ^
  TRUNCATE vistest;
+ ERROR:  relation "vistest" does not exist
  SAVEPOINT s1;
+ ERROR:  SAVEPOINT can only be used in transaction blocks
  COPY vistest FROM stdin CSV FREEZE;
! ERROR:  relation "vistest" does not exist
! m
! k
! \.
! invalid command \.
  COMMIT;
+ ERROR:  syntax error at or near "m"
+ LINE 1: m
+         ^
  BEGIN;
  INSERT INTO vistest VALUES ('z');
+ ERROR:  relation "vistest" does not exist
+ LINE 1: INSERT INTO vistest VALUES ('z');
+                     ^
  SAVEPOINT s1;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  TRUNCATE vistest;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK TO SAVEPOINT s1;
+ ERROR:  savepoint "s1" does not exist
  COPY vistest FROM stdin CSV FREEZE;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! d3
! e
! \.
! invalid command \.
  COMMIT;
+ ERROR:  syntax error at or near "d3"
+ LINE 1: d3
+         ^
  CREATE FUNCTION truncate_in_subxact() RETURNS VOID AS
  $$
  BEGIN
***************
*** 358,387 ****
  	INSERT INTO vistest VALUES ('subxact failure');
  END;
  $$ language plpgsql;
  BEGIN;
  INSERT INTO vistest VALUES ('z');
  SELECT truncate_in_subxact();
!  truncate_in_subxact 
! ---------------------
!  
! (1 row)
! 
  COPY vistest FROM stdin CSV FREEZE;
  SELECT * FROM vistest;
!  a  
! ----
!  d4
!  e
! (2 rows)
! 
  COMMIT;
  SELECT * FROM vistest;
!  a  
! ----
!  d4
!  e
! (2 rows)
! 
  -- Test FORCE_NOT_NULL and FORCE_NULL options
  CREATE TEMP TABLE forcetest (
      a INT NOT NULL,
--- 397,424 ----
  	INSERT INTO vistest VALUES ('subxact failure');
  END;
  $$ language plpgsql;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  BEGIN;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  INSERT INTO vistest VALUES ('z');
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT truncate_in_subxact();
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  COPY vistest FROM stdin CSV FREEZE;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
+ d4
+ e
+ \.
+ invalid command \.
  SELECT * FROM vistest;
! ERROR:  syntax error at or near "d4"
! LINE 1: d4
!         ^
  COMMIT;
  SELECT * FROM vistest;
! ERROR:  relation "vistest" does not exist
! LINE 1: SELECT * FROM vistest;
!                       ^
  -- Test FORCE_NOT_NULL and FORCE_NULL options
  CREATE TEMP TABLE forcetest (
      a INT NOT NULL,
***************
*** 501,539 ****
  SET SESSION AUTHORIZATION regress_rls_copy_user;
  -- all columns
  COPY rls_t1 TO stdout;
! 2	3	2
! 4	1	4
  COPY rls_t1 (a, b, c) TO stdout;
! 2	3	2
! 4	1	4
  -- subset of columns
  COPY rls_t1 (a) TO stdout;
! 2
! 4
  COPY rls_t1 (a, b) TO stdout;
! 2	3
! 4	1
  -- column reordering
  COPY rls_t1 (b, a) TO stdout;
! 3	2
! 1	4
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_rls_copy_user_colperms;
  -- attempt all columns (should fail)
  COPY rls_t1 TO stdout;
! ERROR:  permission denied for table rls_t1
  COPY rls_t1 (a, b, c) TO stdout;
! ERROR:  permission denied for table rls_t1
  -- try to copy column with no privileges (should fail)
  COPY rls_t1 (c) TO stdout;
! ERROR:  permission denied for table rls_t1
  -- subset of columns (should succeed)
  COPY rls_t1 (a) TO stdout;
! 2
! 4
  COPY rls_t1 (a, b) TO stdout;
! 2	3
! 4	1
  RESET SESSION AUTHORIZATION;
  -- test with INSTEAD OF INSERT trigger on a view
  CREATE TABLE instead_of_insert_tbl(id serial, name text);
--- 538,569 ----
  SET SESSION AUTHORIZATION regress_rls_copy_user;
  -- all columns
  COPY rls_t1 TO stdout;
! ERROR:  relation "rls_t1" does not exist
  COPY rls_t1 (a, b, c) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  -- subset of columns
  COPY rls_t1 (a) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  COPY rls_t1 (a, b) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  -- column reordering
  COPY rls_t1 (b, a) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  RESET SESSION AUTHORIZATION;
  SET SESSION AUTHORIZATION regress_rls_copy_user_colperms;
  -- attempt all columns (should fail)
  COPY rls_t1 TO stdout;
! ERROR:  relation "rls_t1" does not exist
  COPY rls_t1 (a, b, c) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  -- try to copy column with no privileges (should fail)
  COPY rls_t1 (c) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  -- subset of columns (should succeed)
  COPY rls_t1 (a) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  COPY rls_t1 (a, b) TO stdout;
! ERROR:  relation "rls_t1" does not exist
  RESET SESSION AUTHORIZATION;
  -- test with INSTEAD OF INSERT trigger on a view
  CREATE TABLE instead_of_insert_tbl(id serial, name text);
***************
*** 577,583 ****
--- 607,615 ----
  -- clean up
  DROP TABLE forcetest;
  DROP TABLE vistest;
+ ERROR:  table "vistest" does not exist
  DROP FUNCTION truncate_in_subxact();
+ ERROR:  function truncate_in_subxact() does not exist
  DROP TABLE x, y;
  DROP TABLE rls_t1 CASCADE;
  DROP ROLE regress_rls_copy_user;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/temp.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/temp.out	CENSORED
***************
*** 139,162 ****
  CREATE TEMP TABLE temptest3(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
  CREATE TEMP TABLE temptest4(col int REFERENCES temptest3);
  COMMIT;
- ERROR:  unsupported ON COMMIT and foreign key combination
- DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  -- Test manipulation of temp schema's placement in search path
  create table public.whereami (f1 text);
  insert into public.whereami values ('public');
  create temp table whereami (f1 text);
  insert into whereami values ('temp');
  create function public.whoami() returns text
    as $$select 'public'::text$$ language sql;
  create function pg_temp.whoami() returns text
    as $$select 'temp'::text$$ language sql;
  -- default should have pg_temp implicitly first, but only for tables
  select * from whereami;
!   f1  
! ------
!  temp
! (1 row)
! 
  select whoami();
   whoami 
  --------
--- 139,160 ----
  CREATE TEMP TABLE temptest3(col int PRIMARY KEY) ON COMMIT DELETE ROWS;
  CREATE TEMP TABLE temptest4(col int REFERENCES temptest3);
  COMMIT;
  -- Test manipulation of temp schema's placement in search path
  create table public.whereami (f1 text);
  insert into public.whereami values ('public');
  create temp table whereami (f1 text);
  insert into whereami values ('temp');
+ ERROR:  unsupported ON COMMIT and foreign key combination
+ DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  create function public.whoami() returns text
    as $$select 'public'::text$$ language sql;
  create function pg_temp.whoami() returns text
    as $$select 'temp'::text$$ language sql;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary objects
  -- default should have pg_temp implicitly first, but only for tables
  select * from whereami;
! ERROR:  unsupported ON COMMIT and foreign key combination
! DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  select whoami();
   whoami 
  --------
***************
*** 166,176 ****
  -- can list temp first explicitly, but it still doesn't affect functions
  set search_path = pg_temp, public;
  select * from whereami;
!   f1  
! ------
!  temp
! (1 row)
! 
  select whoami();
   whoami 
  --------
--- 164,171 ----
  -- can list temp first explicitly, but it still doesn't affect functions
  set search_path = pg_temp, public;
  select * from whereami;
! ERROR:  unsupported ON COMMIT and foreign key combination
! DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  select whoami();
   whoami 
  --------
***************
*** 193,203 ****
  
  -- you can invoke a temp function explicitly, though
  select pg_temp.whoami();
!  whoami 
! --------
!  temp
! (1 row)
! 
  drop table public.whereami;
  -- For partitioned temp tables, ON COMMIT actions ignore storage-less
  -- partitioned tables.
--- 188,197 ----
  
  -- you can invoke a temp function explicitly, though
  select pg_temp.whoami();
! ERROR:  function pg_temp.whoami() does not exist
! LINE 1: select pg_temp.whoami();
!                ^
! HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
  drop table public.whereami;
  -- For partitioned temp tables, ON COMMIT actions ignore storage-less
  -- partitioned tables.
***************
*** 209,221 ****
    for values in (1) on commit delete rows;
  insert into temp_parted_oncommit values (1);
  commit;
  -- partitions are emptied by the previous commit
  select * from temp_parted_oncommit;
!  a 
! ---
! (0 rows)
! 
  drop table temp_parted_oncommit;
  -- Check dependencies between ON COMMIT actions with a partitioned
  -- table and its partitions.  Using ON COMMIT DROP on a parent removes
  -- the whole set.
--- 203,217 ----
    for values in (1) on commit delete rows;
  insert into temp_parted_oncommit values (1);
  commit;
+ ERROR:  unsupported ON COMMIT and foreign key combination
+ DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  -- partitions are emptied by the previous commit
  select * from temp_parted_oncommit;
! ERROR:  relation "temp_parted_oncommit" does not exist
! LINE 1: select * from temp_parted_oncommit;
!                       ^
  drop table temp_parted_oncommit;
+ ERROR:  table "temp_parted_oncommit" does not exist
  -- Check dependencies between ON COMMIT actions with a partitioned
  -- table and its partitions.  Using ON COMMIT DROP on a parent removes
  -- the whole set.
***************
*** 230,235 ****
--- 226,233 ----
    for values in (2) on commit drop;
  insert into temp_parted_oncommit_test values (1), (2);
  commit;
+ ERROR:  unsupported ON COMMIT and foreign key combination
+ DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  -- no relations remain in this case.
  select relname from pg_class where relname like 'temp_parted_oncommit_test%';
   relname 
***************
*** 249,271 ****
    for values in (2) on commit drop;
  insert into temp_parted_oncommit_test values (1), (2);
  commit;
  -- Data from the remaining partition is still here as its rows are
  -- preserved.
  select * from temp_parted_oncommit_test;
!  a 
! ---
!  1
! (1 row)
! 
  -- two relations remain in this case.
  select relname from pg_class where relname like 'temp_parted_oncommit_test%';
!           relname           
! ----------------------------
!  temp_parted_oncommit_test
!  temp_parted_oncommit_test1
! (2 rows)
  
  drop table temp_parted_oncommit_test;
  -- Check dependencies between ON COMMIT actions with inheritance trees.
  -- Using ON COMMIT DROP on a parent removes the whole set.
  begin;
--- 247,268 ----
    for values in (2) on commit drop;
  insert into temp_parted_oncommit_test values (1), (2);
  commit;
+ ERROR:  unsupported ON COMMIT and foreign key combination
+ DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  -- Data from the remaining partition is still here as its rows are
  -- preserved.
  select * from temp_parted_oncommit_test;
! ERROR:  relation "temp_parted_oncommit_test" does not exist
! LINE 1: select * from temp_parted_oncommit_test;
!                       ^
  -- two relations remain in this case.
  select relname from pg_class where relname like 'temp_parted_oncommit_test%';
!  relname 
! ---------
! (0 rows)
  
  drop table temp_parted_oncommit_test;
+ ERROR:  table "temp_parted_oncommit_test" does not exist
  -- Check dependencies between ON COMMIT actions with inheritance trees.
  -- Using ON COMMIT DROP on a parent removes the whole set.
  begin;
***************
*** 274,279 ****
--- 271,278 ----
    inherits(temp_inh_oncommit_test) on commit delete rows;
  insert into temp_inh_oncommit_test1 values (1);
  commit;
+ ERROR:  unsupported ON COMMIT and foreign key combination
+ DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  -- no relations remain in this case
  select relname from pg_class where relname like 'temp_inh_oncommit_test%';
   relname 
***************
*** 288,306 ****
  insert into temp_inh_oncommit_test1 values (1);
  insert into temp_inh_oncommit_test values (1);
  commit;
  select * from temp_inh_oncommit_test;
!  a 
! ---
! (0 rows)
! 
  -- one relation remains
  select relname from pg_class where relname like 'temp_inh_oncommit_test%';
!         relname         
! ------------------------
!  temp_inh_oncommit_test
! (1 row)
  
  drop table temp_inh_oncommit_test;
  -- Tests with two-phase commit
  -- Transactions creating objects in a temporary namespace cannot be used
  -- with two-phase commit.
--- 287,306 ----
  insert into temp_inh_oncommit_test1 values (1);
  insert into temp_inh_oncommit_test values (1);
  commit;
+ ERROR:  unsupported ON COMMIT and foreign key combination
+ DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  select * from temp_inh_oncommit_test;
! ERROR:  relation "temp_inh_oncommit_test" does not exist
! LINE 1: select * from temp_inh_oncommit_test;
!                       ^
  -- one relation remains
  select relname from pg_class where relname like 'temp_inh_oncommit_test%';
!  relname 
! ---------
! (0 rows)
  
  drop table temp_inh_oncommit_test;
+ ERROR:  table "temp_inh_oncommit_test" does not exist
  -- Tests with two-phase commit
  -- Transactions creating objects in a temporary namespace cannot be used
  -- with two-phase commit.
***************
*** 314,323 ****
  -- Function drop
  create function pg_temp.twophase_func() returns void as
    $$ select '2pc_func'::text $$ language sql;
  begin;
  drop function pg_temp.twophase_func();
  prepare transaction 'twophase_func';
- ERROR:  cannot PREPARE a transaction that has operated on temporary objects
  -- Operator creation
  begin;
  create operator pg_temp.@@ (leftarg = int4, rightarg = int4, procedure = int4mi);
--- 314,324 ----
  -- Function drop
  create function pg_temp.twophase_func() returns void as
    $$ select '2pc_func'::text $$ language sql;
+ ERROR:  cannot PREPARE a transaction that has operated on temporary objects
  begin;
  drop function pg_temp.twophase_func();
+ ERROR:  function pg_temp.twophase_func() does not exist
  prepare transaction 'twophase_func';
  -- Operator creation
  begin;
  create operator pg_temp.@@ (leftarg = int4, rightarg = int4, procedure = int4mi);
***************
*** 327,341 ****
  begin;
  create type pg_temp.twophase_type as (a int);
  prepare transaction 'twophase_type';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  begin;
  create view pg_temp.twophase_view as select 1;
  prepare transaction 'twophase_view';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  begin;
  create sequence pg_temp.twophase_seq;
  prepare transaction 'twophase_sequence';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  -- Temporary tables cannot be used with two-phase commit.
  create temp table twophase_tab (a int);
  begin;
--- 328,342 ----
  begin;
  create type pg_temp.twophase_type as (a int);
  prepare transaction 'twophase_type';
! ERROR:  cannot PREPARE a transaction that has operated on temporary objects
  begin;
  create view pg_temp.twophase_view as select 1;
  prepare transaction 'twophase_view';
! ERROR:  cannot PREPARE a transaction that has operated on temporary objects
  begin;
  create sequence pg_temp.twophase_seq;
  prepare transaction 'twophase_sequence';
! ERROR:  cannot PREPARE a transaction that has operated on temporary objects
  -- Temporary tables cannot be used with two-phase commit.
  create temp table twophase_tab (a int);
  begin;
***************
*** 345,363 ****
  (0 rows)
  
  prepare transaction 'twophase_tab';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  begin;
  insert into twophase_tab values (1);
  prepare transaction 'twophase_tab';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  begin;
  lock twophase_tab in access exclusive mode;
  prepare transaction 'twophase_tab';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  begin;
  drop table twophase_tab;
  prepare transaction 'twophase_tab';
! ERROR:  cannot PREPARE a transaction that has operated on temporary tables
  -- Corner case: current_schema may create a temporary schema if namespace
  -- creation is pending, so check after that.  First reset the connection
  -- to remove the temporary namespace, and make sure that non-parallel plans
--- 346,367 ----
  (0 rows)
  
  prepare transaction 'twophase_tab';
! ERROR:  unsupported ON COMMIT and foreign key combination
! DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  begin;
  insert into twophase_tab values (1);
  prepare transaction 'twophase_tab';
! ERROR:  unsupported ON COMMIT and foreign key combination
! DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  begin;
  lock twophase_tab in access exclusive mode;
  prepare transaction 'twophase_tab';
! ERROR:  unsupported ON COMMIT and foreign key combination
! DETAIL:  Table "temptest4" references "temptest3", but they do not have the same ON COMMIT setting.
  begin;
  drop table twophase_tab;
  prepare transaction 'twophase_tab';
! ERROR:  [multimaster] failed to prepare transaction at peer node
  -- Corner case: current_schema may create a temporary schema if namespace
  -- creation is pending, so check after that.  First reset the connection
  -- to remove the temporary namespace, and make sure that non-parallel plans

======================================================================

*** contrib/mmts/../../src/test/regress/expected/domain.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/domain.out	CENSORED
***************
*** 316,398 ****
  create domain dcomptypea as comptype[];
  create table dcomptable (d1 dcomptypea unique);
  insert into dcomptable values (array[row(1,2)]::dcomptypea);
  insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
  insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
  insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
! ERROR:  duplicate key value violates unique constraint "dcomptable_d1_key"
! DETAIL:  Key (d1)=({"(1,2)"}) already exists.
  insert into dcomptable (d1[1]) values(row(9,10));
  insert into dcomptable (d1[1].r) values(11);
  select * from dcomptable;
!          d1         
! --------------------
!  {"(1,2)"}
!  {"(3,4)","(5,6)"}
!  {"(7,8)","(9,10)"}
!  {"(9,10)"}
!  {"(11,)"}
! (5 rows)
  
  select d1[2], d1[1].r, d1[1].i from dcomptable;
!    d1   | r  | i  
! --------+----+----
!         |  1 |  2
!  (5,6)  |  3 |  4
!  (9,10) |  7 |  8
!         |  9 | 10
!         | 11 |   
! (5 rows)
  
  update dcomptable set d1[2] = row(d1[2].i, d1[2].r);
  select * from dcomptable;
!          d1         
! --------------------
!  {"(1,2)","(,)"}
!  {"(3,4)","(6,5)"}
!  {"(7,8)","(10,9)"}
!  {"(9,10)","(,)"}
!  {"(11,)","(,)"}
! (5 rows)
  
  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;
  select * from dcomptable;
!          d1         
! --------------------
!  {"(11,)","(,)"}
!  {"(2,2)","(,)"}
!  {"(4,4)","(6,5)"}
!  {"(8,8)","(10,9)"}
!  {"(10,10)","(,)"}
! (5 rows)
  
  alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
  alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- fail
- ERROR:  column "d1" of table "dcomptable" contains values that violate the new constraint
  select array[row(2,1)]::dcomptypea;  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable values (array[row(1,2)]::comptype[]);
  insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable (d1[1].r) values(99);
  insert into dcomptable (d1[1].r, d1[1].i) values(99, 100);
  insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;  -- fail
- ERROR:  value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
    where d1[1].i > 0;
  select * from dcomptable;
!          d1         
! --------------------
!  {"(11,)","(,)"}
!  {"(99,)"}
!  {"(1,3)","(,)"}
!  {"(3,5)","(6,5)"}
!  {"(7,9)","(10,9)"}
!  {"(9,11)","(,)"}
!  {"(0,3)"}
!  {"(98,101)"}
! (8 rows)
  
  explain (verbose, costs off)
    update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
--- 316,375 ----
  create domain dcomptypea as comptype[];
  create table dcomptable (d1 dcomptypea unique);
  insert into dcomptable values (array[row(1,2)]::dcomptypea);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[]);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype]);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  insert into dcomptable values (array[row(1,2)]::dcomptypea);  -- fail on uniqueness
! ERROR:  [multimaster] failed to prepare transaction at peer node
  insert into dcomptable (d1[1]) values(row(9,10));
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  insert into dcomptable (d1[1].r) values(11);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  select * from dcomptable;
!  d1 
! ----
! (0 rows)
  
  select d1[2], d1[1].r, d1[1].i from dcomptable;
!  d1 | r | i 
! ----+---+---
! (0 rows)
  
  update dcomptable set d1[2] = row(d1[2].i, d1[2].r);
  select * from dcomptable;
!  d1 
! ----
! (0 rows)
  
  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;
  select * from dcomptable;
!  d1 
! ----
! (0 rows)
  
  alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i);
  alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i);  -- fail
  select array[row(2,1)]::dcomptypea;  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable values (array[row(1,2)]::comptype[]);
+ ERROR:  value for domain dcomptypea violates check constraint "c2"
  insert into dcomptable values (array[row(2,1)]::comptype[]);  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  insert into dcomptable (d1[1].r) values(99);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  insert into dcomptable (d1[1].r, d1[1].i) values(99, 100);
+ ERROR:  value for domain dcomptypea violates check constraint "c2"
  insert into dcomptable (d1[1].r, d1[1].i) values(100, 99);  -- fail
  ERROR:  value for domain dcomptypea violates check constraint "c1"
  update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0;  -- fail
  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
    where d1[1].i > 0;
  select * from dcomptable;
!  d1 
! ----
! (0 rows)
  
  explain (verbose, costs off)
    update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
***************
*** 708,714 ****
--- 685,693 ----
  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
  ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
  UPDATE thethings SET stuff = 10;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  ALTER DOMAIN things VALIDATE CONSTRAINT meow;
+ ERROR:  column "stuff" of table "thethings" contains values that violate the new constraint
  -- Confirm ALTER DOMAIN with RULES.
  create table domtab (col1 integer);
  create domain dom as integer;
***************
*** 879,884 ****
--- 858,864 ----
  create domain ddtest1d as ddtest1;
  create table ddtest2(f1 ddtest1d);
  insert into ddtest2 values('(-1)');
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter domain posint add constraint c1 check(value >= 0);
  ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
  drop table ddtest2;
***************
*** 887,892 ****
--- 867,873 ----
  create domain ddtest1d as ddtest1[];
  create table ddtest2(f1 ddtest1d);
  insert into ddtest2 values('{(-1)}');
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  alter domain posint add constraint c1 check(value >= 0);
  ERROR:  cannot alter type "posint" because column "ddtest2.f1" uses it
  drop table ddtest2;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/without_oid.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/without_oid.out	CENSORED
***************
*** 84,103 ****
  PREPARE table_source(int) AS
      SELECT a + b AS c1, a - b AS c2, $1 AS c3 FROM create_table_test;
  CREATE TABLE execute_with WITH OIDS AS EXECUTE table_source(1);
  CREATE TABLE execute_without WITHOUT OIDS AS EXECUTE table_source(2);
  SELECT count(oid) FROM execute_with;
!  count 
! -------
!      2
! (1 row)
! 
  -- should fail
  SELECT count(oid) FROM execute_without;
! ERROR:  column "oid" does not exist
  LINE 1: SELECT count(oid) FROM execute_without;
!                      ^
  DROP TABLE create_table_test;
  DROP TABLE create_table_test2;
  DROP TABLE create_table_test3;
  DROP TABLE execute_with;
  DROP TABLE execute_without;
--- 84,105 ----
  PREPARE table_source(int) AS
      SELECT a + b AS c1, a - b AS c2, $1 AS c3 FROM create_table_test;
  CREATE TABLE execute_with WITH OIDS AS EXECUTE table_source(1);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  CREATE TABLE execute_without WITHOUT OIDS AS EXECUTE table_source(2);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT count(oid) FROM execute_with;
! ERROR:  relation "execute_with" does not exist
! LINE 1: SELECT count(oid) FROM execute_with;
!                                ^
  -- should fail
  SELECT count(oid) FROM execute_without;
! ERROR:  relation "execute_without" does not exist
  LINE 1: SELECT count(oid) FROM execute_without;
!                                ^
  DROP TABLE create_table_test;
  DROP TABLE create_table_test2;
  DROP TABLE create_table_test3;
  DROP TABLE execute_with;
+ ERROR:  table "execute_with" does not exist
  DROP TABLE execute_without;
+ ERROR:  table "execute_without" does not exist

======================================================================

*** contrib/mmts/../../src/test/regress/expected/conversion.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/conversion.out	CENSORED
***************
*** 4,33 ****
  CREATE USER regress_conversion_user WITH NOCREATEDB NOCREATEROLE;
  SET SESSION AUTHORIZATION regress_conversion_user;
  CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  --
  -- cannot make same name conversion in same schema
  --
  CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ERROR:  conversion "myconv" already exists
  --
  -- create default conversion with qualified name
  --
  CREATE DEFAULT CONVERSION public.mydef FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
  --
  -- cannot make default conversion with same schema/for_encoding/to_encoding
  --
  CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ERROR:  default conversion for LATIN1 to UTF8 already exists
  -- test comments
  COMMENT ON CONVERSION myconv_bad IS 'foo';
  ERROR:  conversion "myconv_bad" does not exist
  COMMENT ON CONVERSION myconv IS 'bar';
  COMMENT ON CONVERSION myconv IS NULL;
  --
  -- drop user defined conversion
  --
  DROP CONVERSION myconv;
  DROP CONVERSION mydef;
  --
  -- Note: the built-in conversions are exercised in opr_sanity.sql,
  -- so there's no need to do that here.
--- 4,39 ----
  CREATE USER regress_conversion_user WITH NOCREATEDB NOCREATEROLE;
  SET SESSION AUTHORIZATION regress_conversion_user;
  CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
+ ERROR:  no schema has been selected to create in
  --
  -- cannot make same name conversion in same schema
  --
  CREATE CONVERSION myconv FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ERROR:  no schema has been selected to create in
  --
  -- create default conversion with qualified name
  --
  CREATE DEFAULT CONVERSION public.mydef FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
+ ERROR:  permission denied for schema public
  --
  -- cannot make default conversion with same schema/for_encoding/to_encoding
  --
  CREATE DEFAULT CONVERSION public.mydef2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
! ERROR:  permission denied for schema public
  -- test comments
  COMMENT ON CONVERSION myconv_bad IS 'foo';
  ERROR:  conversion "myconv_bad" does not exist
  COMMENT ON CONVERSION myconv IS 'bar';
+ ERROR:  conversion "myconv" does not exist
  COMMENT ON CONVERSION myconv IS NULL;
+ ERROR:  conversion "myconv" does not exist
  --
  -- drop user defined conversion
  --
  DROP CONVERSION myconv;
+ ERROR:  conversion "myconv" does not exist
  DROP CONVERSION mydef;
+ ERROR:  conversion "mydef" does not exist
  --
  -- Note: the built-in conversions are exercised in opr_sanity.sql,
  -- so there's no need to do that here.

======================================================================

*** contrib/mmts/../../src/test/regress/expected/alter_table.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/alter_table.out	CENSORED
***************
*** 168,180 ****
  ALTER TABLE part_attmp1 RENAME TO part_at2tmp1;
  SET ROLE regress_alter_table_user1;
  ALTER INDEX part_attmp_index RENAME TO fail;
! ERROR:  must be owner of index part_attmp_index
  ALTER INDEX part_attmp1_index RENAME TO fail;
! ERROR:  must be owner of index part_attmp1_index
  ALTER TABLE part_at2tmp RENAME TO fail;
! ERROR:  must be owner of table part_at2tmp
  ALTER TABLE part_at2tmp1 RENAME TO fail;
! ERROR:  must be owner of table part_at2tmp1
  RESET ROLE;
  DROP TABLE part_at2tmp;
  --
--- 168,180 ----
  ALTER TABLE part_attmp1 RENAME TO part_at2tmp1;
  SET ROLE regress_alter_table_user1;
  ALTER INDEX part_attmp_index RENAME TO fail;
! ERROR:  relation "part_attmp_index" does not exist
  ALTER INDEX part_attmp1_index RENAME TO fail;
! ERROR:  relation "part_attmp1_index" does not exist
  ALTER TABLE part_at2tmp RENAME TO fail;
! ERROR:  relation "part_at2tmp" does not exist
  ALTER TABLE part_at2tmp1 RENAME TO fail;
! ERROR:  relation "part_at2tmp1" does not exist
  RESET ROLE;
  DROP TABLE part_at2tmp;
  --
***************
*** 236,249 ****
  ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
  SET ROLE regress_alter_table_user1;
  ALTER INDEX onek_unique1 RENAME TO fail;  -- permission denied
! ERROR:  must be owner of index onek_unique1
  RESET ROLE;
  -- renaming views
  CREATE VIEW attmp_view (unique1) AS SELECT unique1 FROM tenk1;
  ALTER TABLE attmp_view RENAME TO attmp_view_new;
  SET ROLE regress_alter_table_user1;
  ALTER VIEW attmp_view_new RENAME TO fail;  -- permission denied
! ERROR:  must be owner of view attmp_view_new
  RESET ROLE;
  -- hack to ensure we get an indexscan here
  set enable_seqscan to off;
--- 236,249 ----
  ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
  SET ROLE regress_alter_table_user1;
  ALTER INDEX onek_unique1 RENAME TO fail;  -- permission denied
! ERROR:  relation "onek_unique1" does not exist
  RESET ROLE;
  -- renaming views
  CREATE VIEW attmp_view (unique1) AS SELECT unique1 FROM tenk1;
  ALTER TABLE attmp_view RENAME TO attmp_view_new;
  SET ROLE regress_alter_table_user1;
  ALTER VIEW attmp_view_new RENAME TO fail;  -- permission denied
! ERROR:  relation "attmp_view_new" does not exist
  RESET ROLE;
  -- hack to ensure we get an indexscan here
  set enable_seqscan to off;
***************
*** 1039,1047 ****
  -- alter table / alter column [set/drop] not null tests
  -- try altering system catalogs, should fail
  alter table pg_class alter column relname drop not null;
- ERROR:  permission denied: "pg_class" is a system catalog
  alter table pg_class alter relname set not null;
- ERROR:  permission denied: "pg_class" is a system catalog
  -- try altering non-existent table, should fail
  alter table non_existent alter column bar set not null;
  ERROR:  relation "non_existent" does not exist
--- 1039,1045 ----
***************
*** 1170,1176 ****
  -- alter table / drop column tests
  -- try altering system catalogs, should fail
  alter table pg_class drop column relname;
- ERROR:  permission denied: "pg_class" is a system catalog
  -- try altering non-existent table, should fail
  alter table nosuchtable drop column bar;
  ERROR:  relation "nosuchtable" does not exist
--- 1168,1173 ----
***************
*** 1998,2035 ****
  alter table anothertab
    add exclude using btree (f4 with =) where (f4 is not null);
  \d anothertab
!              Table "public.anothertab"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  f1     | integer |           | not null | 
!  f2     | integer |           |          | 
!  f3     | integer |           |          | 
!  f4     | integer |           |          | 
! Indexes:
!     "anothertab_pkey" PRIMARY KEY, btree (f1)
!     "anothertab_f2_key" UNIQUE CONSTRAINT, btree (f2)
!     "anothertab_f3_excl" EXCLUDE USING btree (f3 WITH =)
!     "anothertab_f4_excl" EXCLUDE USING btree (f4 WITH =) WHERE (f4 IS NOT NULL)
! 
  alter table anothertab alter column f1 type bigint;
  alter table anothertab
    alter column f2 type bigint,
    alter column f3 type bigint,
    alter column f4 type bigint;
  \d anothertab
!             Table "public.anothertab"
!  Column |  Type  | Collation | Nullable | Default 
! --------+--------+-----------+----------+---------
!  f1     | bigint |           | not null | 
!  f2     | bigint |           |          | 
!  f3     | bigint |           |          | 
!  f4     | bigint |           |          | 
! Indexes:
!     "anothertab_pkey" PRIMARY KEY, btree (f1)
!     "anothertab_f2_key" UNIQUE CONSTRAINT, btree (f2)
!     "anothertab_f3_excl" EXCLUDE USING btree (f3 WITH =)
!     "anothertab_f4_excl" EXCLUDE USING btree (f4 WITH =) WHERE (f4 IS NOT NULL)
! 
  drop table anothertab;
  create table another (f1 int, f2 text);
  insert into another values(1, 'one');
--- 1995,2008 ----
  alter table anothertab
    add exclude using btree (f4 with =) where (f4 is not null);
  \d anothertab
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  alter table anothertab alter column f1 type bigint;
  alter table anothertab
    alter column f2 type bigint,
    alter column f3 type bigint,
    alter column f4 type bigint;
  \d anothertab
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table anothertab;
  create table another (f1 int, f2 text);
  insert into another values(1, 'one');
***************
*** 2069,2126 ****
  create index on at_partitioned (b);
  create index on at_partitioned (a);
  \d at_part_1
!              Table "public.at_part_1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | text    |           |          | 
! Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
! Indexes:
!     "at_part_1_a_idx" btree (a)
!     "at_part_1_b_idx" btree (b)
! 
  \d at_part_2
!              Table "public.at_part_2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  b      | text    |           |          | 
!  a      | integer |           |          | 
! 
  alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
  \d at_part_2
!              Table "public.at_part_2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  b      | text    |           |          | 
!  a      | integer |           |          | 
! Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
! Indexes:
!     "at_part_2_a_idx" btree (a)
!     "at_part_2_b_idx" btree (b)
! 
  alter table at_partitioned alter column b type numeric using b::numeric;
  \d at_part_1
!              Table "public.at_part_1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | numeric |           |          | 
! Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
! Indexes:
!     "at_part_1_a_idx" btree (a)
!     "at_part_1_b_idx" btree (b)
! 
  \d at_part_2
!              Table "public.at_part_2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  b      | numeric |           |          | 
!  a      | integer |           |          | 
! Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
! Indexes:
!     "at_part_2_a_idx" btree (a)
!     "at_part_2_b_idx" btree (b)
! 
  drop table at_partitioned;
  -- Alter column type when no table rewrite is required
  -- Also check that comments are preserved
--- 2042,2058 ----
  create index on at_partitioned (b);
  create index on at_partitioned (a);
  \d at_part_1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d at_part_2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
  \d at_part_2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  alter table at_partitioned alter column b type numeric using b::numeric;
  \d at_part_1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d at_part_2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table at_partitioned;
  -- Alter column type when no table rewrite is required
  -- Also check that comments are preserved
***************
*** 2141,2146 ****
--- 2073,2079 ----
  create temp table old_oids as
    select relname, oid as oldoid, relfilenode as oldfilenode
    from pg_class where relname like 'at_partitioned%';
+ ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname,
    c.oid = oldoid as orig_oid,
    case relfilenode
***************
*** 2153,2178 ****
    from pg_class c left join old_oids using (relname)
    where relname like 'at_partitioned%'
    order by relname;
!            relname            | orig_oid | storage |     desc      
! ------------------------------+----------+---------+---------------
!  at_partitioned               | t        | own     | 
!  at_partitioned_0             | t        | own     | 
!  at_partitioned_0_id_name_key | t        | own     | child 0 index
!  at_partitioned_1             | t        | own     | 
!  at_partitioned_1_id_name_key | t        | own     | child 1 index
!  at_partitioned_id_name_key   | t        | own     | parent index
! (6 rows)
! 
  select conname, obj_description(oid, 'pg_constraint') as desc
    from pg_constraint where conname like 'at_partitioned%'
    order by conname;
!            conname            |        desc        
! ------------------------------+--------------------
!  at_partitioned_0_id_name_key | child 0 constraint
!  at_partitioned_1_id_name_key | child 1 constraint
!  at_partitioned_id_name_key   | parent constraint
! (3 rows)
! 
  alter table at_partitioned alter column name type varchar(127);
  -- Note: these tests currently show the wrong behavior for comments :-(
  select relname,
--- 2086,2099 ----
    from pg_class c left join old_oids using (relname)
    where relname like 'at_partitioned%'
    order by relname;
! ERROR:  relation "old_oids" does not exist
! LINE 10:   from pg_class c left join old_oids using (relname)
!                                      ^
  select conname, obj_description(oid, 'pg_constraint') as desc
    from pg_constraint where conname like 'at_partitioned%'
    order by conname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  alter table at_partitioned alter column name type varchar(127);
  -- Note: these tests currently show the wrong behavior for comments :-(
  select relname,
***************
*** 2187,2212 ****
    from pg_class c left join old_oids using (relname)
    where relname like 'at_partitioned%'
    order by relname;
!            relname            | orig_oid | storage |     desc     
! ------------------------------+----------+---------+--------------
!  at_partitioned               | t        | own     | 
!  at_partitioned_0             | t        | own     | 
!  at_partitioned_0_id_name_key | f        | own     | parent index
!  at_partitioned_1             | t        | own     | 
!  at_partitioned_1_id_name_key | f        | own     | parent index
!  at_partitioned_id_name_key   | f        | own     | parent index
! (6 rows)
! 
  select conname, obj_description(oid, 'pg_constraint') as desc
    from pg_constraint where conname like 'at_partitioned%'
    order by conname;
!            conname            |       desc        
! ------------------------------+-------------------
!  at_partitioned_0_id_name_key | 
!  at_partitioned_1_id_name_key | 
!  at_partitioned_id_name_key   | parent constraint
! (3 rows)
! 
  -- Don't remove this DROP, it exposes bug #15672
  drop table at_partitioned;
  -- disallow recursive containment of row types
--- 2108,2121 ----
    from pg_class c left join old_oids using (relname)
    where relname like 'at_partitioned%'
    order by relname;
! ERROR:  relation "old_oids" does not exist
! LINE 10:   from pg_class c left join old_oids using (relname)
!                                      ^
  select conname, obj_description(oid, 'pg_constraint') as desc
    from pg_constraint where conname like 'at_partitioned%'
    order by conname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  -- Don't remove this DROP, it exposes bug #15672
  drop table at_partitioned;
  -- disallow recursive containment of row types
***************
*** 2241,2306 ****
  CREATE TABLE test_inh_check (a float check (a > 10.2), b float);
  CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
  \d test_inh_check
!                Table "public.test_inh_check"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | double precision |           |          | 
!  b      | double precision |           |          | 
! Check constraints:
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
! Number of child tables: 1 (Use \d+ to list them.)
! 
  \d test_inh_check_child
!             Table "public.test_inh_check_child"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | double precision |           |          | 
!  b      | double precision |           |          | 
! Check constraints:
!     "test_inh_check_a_check" CHECK (a > 10.2::double precision)
! Inherits: test_inh_check
! 
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
!        relname        |        conname         | coninhcount | conislocal | connoinherit 
! ----------------------+------------------------+-------------+------------+--------------
!  test_inh_check       | test_inh_check_a_check |           0 | t          | f
!  test_inh_check_child | test_inh_check_a_check |           1 | f          | f
! (2 rows)
! 
  ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
  \d test_inh_check
!                Table "public.test_inh_check"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
!  b      | double precision |           |          | 
! Check constraints:
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Number of child tables: 1 (Use \d+ to list them.)
! 
  \d test_inh_check_child
!             Table "public.test_inh_check_child"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
!  b      | double precision |           |          | 
! Check constraints:
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Inherits: test_inh_check
! 
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
!        relname        |        conname         | coninhcount | conislocal | connoinherit 
! ----------------------+------------------------+-------------+------------+--------------
!  test_inh_check       | test_inh_check_a_check |           0 | t          | f
!  test_inh_check_child | test_inh_check_a_check |           1 | f          | f
! (2 rows)
! 
  -- also try noinherit, local, and local+inherited cases
  ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
  ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
--- 2150,2173 ----
  CREATE TABLE test_inh_check (a float check (a > 10.2), b float);
  CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
  \d test_inh_check
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_inh_check_child
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
  \d test_inh_check
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_inh_check_child
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- also try noinherit, local, and local+inherited cases
  ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
  ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
***************
*** 2308,2390 ****
  ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
  NOTICE:  merging constraint "bmerged" with inherited definition
  \d test_inh_check
!                Table "public.test_inh_check"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
!  b      | double precision |           |          | 
! Check constraints:
!     "bmerged" CHECK (b > 1::double precision)
!     "bnoinherit" CHECK (b > 100::double precision) NO INHERIT
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Number of child tables: 1 (Use \d+ to list them.)
! 
  \d test_inh_check_child
!             Table "public.test_inh_check_child"
!  Column |       Type       | Collation | Nullable | Default 
! --------+------------------+-----------+----------+---------
!  a      | numeric          |           |          | 
!  b      | double precision |           |          | 
! Check constraints:
!     "blocal" CHECK (b < 1000::double precision)
!     "bmerged" CHECK (b > 1::double precision)
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Inherits: test_inh_check
! 
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
!        relname        |        conname         | coninhcount | conislocal | connoinherit 
! ----------------------+------------------------+-------------+------------+--------------
!  test_inh_check       | bmerged                |           0 | t          | f
!  test_inh_check       | bnoinherit             |           0 | t          | t
!  test_inh_check       | test_inh_check_a_check |           0 | t          | f
!  test_inh_check_child | blocal                 |           0 | t          | f
!  test_inh_check_child | bmerged                |           1 | t          | f
!  test_inh_check_child | test_inh_check_a_check |           1 | f          | f
! (6 rows)
! 
  ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
  NOTICE:  merging constraint "bmerged" with inherited definition
  \d test_inh_check
!            Table "public.test_inh_check"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | numeric |           |          | 
!  b      | numeric |           |          | 
! Check constraints:
!     "bmerged" CHECK (b::double precision > 1::double precision)
!     "bnoinherit" CHECK (b::double precision > 100::double precision) NO INHERIT
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Number of child tables: 1 (Use \d+ to list them.)
! 
  \d test_inh_check_child
!         Table "public.test_inh_check_child"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | numeric |           |          | 
!  b      | numeric |           |          | 
! Check constraints:
!     "blocal" CHECK (b::double precision < 1000::double precision)
!     "bmerged" CHECK (b::double precision > 1::double precision)
!     "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
! Inherits: test_inh_check
! 
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
!        relname        |        conname         | coninhcount | conislocal | connoinherit 
! ----------------------+------------------------+-------------+------------+--------------
!  test_inh_check       | bmerged                |           0 | t          | f
!  test_inh_check       | bnoinherit             |           0 | t          | t
!  test_inh_check       | test_inh_check_a_check |           0 | t          | f
!  test_inh_check_child | blocal                 |           0 | t          | f
!  test_inh_check_child | bmerged                |           1 | t          | f
!  test_inh_check_child | test_inh_check_a_check |           1 | f          | f
! (6 rows)
! 
  -- ALTER COLUMN TYPE with different schema in children
  -- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
  CREATE TABLE test_type_diff (f1 int);
--- 2175,2199 ----
  ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
  NOTICE:  merging constraint "bmerged" with inherited definition
  \d test_inh_check
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_inh_check_child
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
  NOTICE:  merging constraint "bmerged" with inherited definition
  \d test_inh_check
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_inh_check_child
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, conname, coninhcount, conislocal, connoinherit
    from pg_constraint c, pg_class r
    where relname like 'test_inh_check%' and c.conrelid = r.oid
    order by 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- ALTER COLUMN TYPE with different schema in children
  -- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
  CREATE TABLE test_type_diff (f1 int);
***************
*** 2415,2428 ****
  ANALYZE check_fk_presence_2;
  ROLLBACK;
  \d check_fk_presence_2
!         Table "public.check_fk_presence_2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  id     | integer |           |          | 
!  t      | text    |           |          | 
! Foreign-key constraints:
!     "check_fk_presence_2_id_fkey" FOREIGN KEY (id) REFERENCES check_fk_presence_1(id)
! 
  DROP TABLE check_fk_presence_1, check_fk_presence_2;
  -- check column addition within a view (bug #14876)
  create table at_base_table(id int, stuff text);
--- 2224,2230 ----
  ANALYZE check_fk_presence_2;
  ROLLBACK;
  \d check_fk_presence_2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TABLE check_fk_presence_1, check_fk_presence_2;
  -- check column addition within a view (bug #14876)
  create table at_base_table(id int, stuff text);
***************
*** 2430,2458 ****
  create view at_view_1 as select * from at_base_table bt;
  create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
  \d+ at_view_1
!                           View "public.at_view_1"
!  Column |  Type   | Collation | Nullable | Default | Storage  | Description 
! --------+---------+-----------+----------+---------+----------+-------------
!  id     | integer |           |          |         | plain    | 
!  stuff  | text    |           |          |         | extended | 
! View definition:
!  SELECT bt.id,
!     bt.stuff
!    FROM at_base_table bt;
! 
  \d+ at_view_2
!                           View "public.at_view_2"
!  Column |  Type   | Collation | Nullable | Default | Storage  | Description 
! --------+---------+-----------+----------+---------+----------+-------------
!  id     | integer |           |          |         | plain    | 
!  stuff  | text    |           |          |         | extended | 
!  j      | json    |           |          |         | extended | 
! View definition:
!  SELECT v1.id,
!     v1.stuff,
!     to_json(v1.*) AS j
!    FROM at_view_1 v1;
! 
  explain (verbose, costs off) select * from at_view_2;
                          QUERY PLAN                        
  ----------------------------------------------------------
--- 2232,2240 ----
  create view at_view_1 as select * from at_base_table bt;
  create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
  \d+ at_view_1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d+ at_view_2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  explain (verbose, costs off) select * from at_view_2;
                          QUERY PLAN                        
  ----------------------------------------------------------
***************
*** 2468,2498 ****
  
  create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
  \d+ at_view_1
!                           View "public.at_view_1"
!  Column |  Type   | Collation | Nullable | Default | Storage  | Description 
! --------+---------+-----------+----------+---------+----------+-------------
!  id     | integer |           |          |         | plain    | 
!  stuff  | text    |           |          |         | extended | 
!  more   | integer |           |          |         | plain    | 
! View definition:
!  SELECT bt.id,
!     bt.stuff,
!     2 + 2 AS more
!    FROM at_base_table bt;
! 
  \d+ at_view_2
!                           View "public.at_view_2"
!  Column |  Type   | Collation | Nullable | Default | Storage  | Description 
! --------+---------+-----------+----------+---------+----------+-------------
!  id     | integer |           |          |         | plain    | 
!  stuff  | text    |           |          |         | extended | 
!  j      | json    |           |          |         | extended | 
! View definition:
!  SELECT v1.id,
!     v1.stuff,
!     to_json(v1.*) AS j
!    FROM at_view_1 v1;
! 
  explain (verbose, costs off) select * from at_view_2;
                             QUERY PLAN                           
  ----------------------------------------------------------------
--- 2250,2258 ----
  
  create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
  \d+ at_view_1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d+ at_view_2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  explain (verbose, costs off) select * from at_view_2;
                             QUERY PLAN                           
  ----------------------------------------------------------------
***************
*** 2538,2641 ****
  and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
  and c.relname != 'my_locks'
  group by c.relname;
  create table alterlock (f1 int primary key, f2 text);
  insert into alterlock values (1, 'foo');
  create table alterlock2 (f3 int primary key, f1 int);
  insert into alterlock2 values (1, 1);
  begin; alter table alterlock alter column f2 set statistics 150;
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
! (1 row)
! 
  rollback;
  begin; alter table alterlock cluster on alterlock_pkey;
  select * from my_locks order by 1;
!     relname     |       max_lockmode       
! ----------------+--------------------------
!  alterlock      | ShareUpdateExclusiveLock
!  alterlock_pkey | ShareUpdateExclusiveLock
! (2 rows)
! 
  commit;
  begin; alter table alterlock set without cluster;
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
! (1 row)
! 
  commit;
  begin; alter table alterlock set (fillfactor = 100);
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
!  pg_toast  | ShareUpdateExclusiveLock
! (2 rows)
! 
  commit;
  begin; alter table alterlock reset (fillfactor);
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
!  pg_toast  | ShareUpdateExclusiveLock
! (2 rows)
! 
  commit;
  begin; alter table alterlock set (toast.autovacuum_enabled = off);
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
!  pg_toast  | ShareUpdateExclusiveLock
! (2 rows)
! 
  commit;
  begin; alter table alterlock set (autovacuum_enabled = off);
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
!  pg_toast  | ShareUpdateExclusiveLock
! (2 rows)
! 
  commit;
  begin; alter table alterlock alter column f2 set (n_distinct = 1);
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
! (1 row)
! 
  rollback;
  -- test that mixing options with different lock levels works as expected
  begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
  select * from my_locks order by 1;
!   relname  |       max_lockmode       
! -----------+--------------------------
!  alterlock | ShareUpdateExclusiveLock
!  pg_toast  | ShareUpdateExclusiveLock
! (2 rows)
! 
  commit;
  begin; alter table alterlock alter column f2 set storage extended;
  select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
! (1 row)
! 
  rollback;
  begin; alter table alterlock alter column f2 set default 'x';
  select * from my_locks order by 1;
!   relname  |    max_lockmode     
! -----------+---------------------
!  alterlock | AccessExclusiveLock
! (1 row)
! 
  rollback;
  begin;
  create trigger ttdummy
--- 2298,2374 ----
  and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
  and c.relname != 'my_locks'
  group by c.relname;
+ ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  create table alterlock (f1 int primary key, f2 text);
  insert into alterlock values (1, 'foo');
  create table alterlock2 (f3 int primary key, f1 int);
  insert into alterlock2 values (1, 1);
  begin; alter table alterlock alter column f2 set statistics 150;
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  rollback;
  begin; alter table alterlock cluster on alterlock_pkey;
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock set without cluster;
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock set (fillfactor = 100);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock reset (fillfactor);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock set (toast.autovacuum_enabled = off);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock set (autovacuum_enabled = off);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock alter column f2 set (n_distinct = 1);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  rollback;
  -- test that mixing options with different lock levels works as expected
  begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin; alter table alterlock alter column f2 set storage extended;
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  rollback;
  begin; alter table alterlock alter column f2 set default 'x';
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  rollback;
  begin;
  create trigger ttdummy
***************
*** 2644,2694 ****
  	execute procedure
  	ttdummy (1, 1);
  select * from my_locks order by 1;
!   relname  |     max_lockmode      
! -----------+-----------------------
!  alterlock | ShareRowExclusiveLock
! (1 row)
! 
  rollback;
  begin;
  select * from my_locks order by 1;
!  relname | max_lockmode 
! ---------+--------------
! (0 rows)
! 
  alter table alterlock2 add foreign key (f1) references alterlock (f1);
  select * from my_locks order by 1;
!      relname     |     max_lockmode      
! -----------------+-----------------------
!  alterlock       | ShareRowExclusiveLock
!  alterlock2      | ShareRowExclusiveLock
!  alterlock2_pkey | AccessShareLock
!  alterlock_pkey  | AccessShareLock
! (4 rows)
! 
  rollback;
  begin;
  alter table alterlock2
  add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
  select * from my_locks order by 1;
!   relname   |     max_lockmode      
! ------------+-----------------------
!  alterlock  | ShareRowExclusiveLock
!  alterlock2 | ShareRowExclusiveLock
! (2 rows)
! 
  commit;
  begin;
  alter table alterlock2 validate constraint alterlock2nv;
  select * from my_locks order by 1;
!      relname     |       max_lockmode       
! -----------------+--------------------------
!  alterlock       | RowShareLock
!  alterlock2      | ShareUpdateExclusiveLock
!  alterlock2_pkey | AccessShareLock
!  alterlock_pkey  | AccessShareLock
! (4 rows)
! 
  rollback;
  create or replace view my_locks as
  select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
--- 2377,2409 ----
  	execute procedure
  	ttdummy (1, 1);
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  rollback;
  begin;
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  alter table alterlock2 add foreign key (f1) references alterlock (f1);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  begin;
  alter table alterlock2
  add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
  select * from my_locks order by 1;
! ERROR:  relation "my_locks" does not exist
! LINE 1: select * from my_locks order by 1;
!                       ^
  commit;
  begin;
  alter table alterlock2 validate constraint alterlock2nv;
+ ERROR:  constraint "alterlock2nv" of relation "alterlock2" does not exist
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  create or replace view my_locks as
  select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
***************
*** 2701,2740 ****
  and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
  and c.relname = 'my_locks'
  group by c.relname;
  -- raise exception
  alter table my_locks set (autovacuum_enabled = false);
! ERROR:  unrecognized parameter "autovacuum_enabled"
  alter view my_locks set (autovacuum_enabled = false);
! ERROR:  unrecognized parameter "autovacuum_enabled"
  alter table my_locks reset (autovacuum_enabled);
  alter view my_locks reset (autovacuum_enabled);
  begin;
  alter view my_locks set (security_barrier=off);
  select * from my_locks order by 1;
!  relname  |    max_lockmode     
! ----------+---------------------
!  my_locks | AccessExclusiveLock
! (1 row)
! 
  alter view my_locks reset (security_barrier);
  rollback;
  -- this test intentionally applies the ALTER TABLE command against a view, but
  -- uses a view option so we expect this to succeed. This form of SQL is
  -- accepted for historical reasons, as shown in the docs for ALTER VIEW
  begin;
  alter table my_locks set (security_barrier=off);
  select * from my_locks order by 1;
!  relname  |    max_lockmode     
! ----------+---------------------
!  my_locks | AccessExclusiveLock
! (1 row)
! 
  alter table my_locks reset (security_barrier);
  rollback;
  -- cleanup
  drop table alterlock2;
  drop table alterlock;
  drop view my_locks;
  drop type lockmodes;
  --
  -- alter function
--- 2416,2455 ----
  and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
  and c.relname = 'my_locks'
  group by c.relname;
+ ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- raise exception
  alter table my_locks set (autovacuum_enabled = false);
! ERROR:  relation "my_locks" does not exist
  alter view my_locks set (autovacuum_enabled = false);
! ERROR:  relation "my_locks" does not exist
  alter table my_locks reset (autovacuum_enabled);
+ ERROR:  relation "my_locks" does not exist
  alter view my_locks reset (autovacuum_enabled);
+ ERROR:  relation "my_locks" does not exist
  begin;
  alter view my_locks set (security_barrier=off);
+ ERROR:  relation "my_locks" does not exist
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  alter view my_locks reset (security_barrier);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  -- this test intentionally applies the ALTER TABLE command against a view, but
  -- uses a view option so we expect this to succeed. This form of SQL is
  -- accepted for historical reasons, as shown in the docs for ALTER VIEW
  begin;
  alter table my_locks set (security_barrier=off);
+ ERROR:  relation "my_locks" does not exist
  select * from my_locks order by 1;
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  alter table my_locks reset (security_barrier);
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  rollback;
  -- cleanup
  drop table alterlock2;
  drop table alterlock;
  drop view my_locks;
+ ERROR:  view "my_locks" does not exist
  drop type lockmodes;
  --
  -- alter function
***************
*** 2858,2923 ****
  --
  CREATE TYPE test_type AS (a int);
  \d test_type
!          Composite type "public.test_type"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! 
  ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
  ERROR:  relation "nosuchtype" does not exist
  ALTER TYPE test_type ADD ATTRIBUTE b text;
  \d test_type
!          Composite type "public.test_type"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | text    |           |          | 
! 
  ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
  ERROR:  column "b" of relation "test_type" already exists
  ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
  \d test_type
!               Composite type "public.test_type"
!  Column |       Type        | Collation | Nullable | Default 
! --------+-------------------+-----------+----------+---------
!  a      | integer           |           |          | 
!  b      | character varying |           |          | 
! 
  ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
  \d test_type
!          Composite type "public.test_type"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
! 
  ALTER TYPE test_type DROP ATTRIBUTE b;
  \d test_type
!          Composite type "public.test_type"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! 
  ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
  ERROR:  column "c" of relation "test_type" does not exist
  ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
  NOTICE:  column "c" of relation "test_type" does not exist, skipping
  ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
  \d test_type
!          Composite type "public.test_type"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  d      | boolean |           |          | 
! 
  ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
  ERROR:  column "a" does not exist
  ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
  \d test_type
!          Composite type "public.test_type"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  dd     | boolean |           |          | 
! 
  DROP TYPE test_type;
  CREATE TYPE test_type1 AS (a int, b text);
  CREATE TABLE test_tbl1 (x int, y test_type1);
--- 2573,2607 ----
  --
  CREATE TYPE test_type AS (a int);
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
  ERROR:  relation "nosuchtype" does not exist
  ALTER TYPE test_type ADD ATTRIBUTE b text;
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
  ERROR:  column "b" of relation "test_type" already exists
  ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type DROP ATTRIBUTE b;
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
  ERROR:  column "c" of relation "test_type" does not exist
  ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
  NOTICE:  column "c" of relation "test_type" does not exist, skipping
  ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
  ERROR:  column "a" does not exist
  ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
  \d test_type
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TYPE test_type;
  CREATE TYPE test_type1 AS (a int, b text);
  CREATE TABLE test_tbl1 (x int, y test_type1);
***************
*** 2927,3039 ****
  CREATE TABLE test_tbl2 OF test_type2;
  CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
  \d test_type2
!         Composite type "public.test_type2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | text    |           |          | 
! 
  \d test_tbl2
!              Table "public.test_tbl2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | text    |           |          | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
  ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
  \d test_type2
!         Composite type "public.test_type2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | text    |           |          | 
!  c      | text    |           |          | 
! 
  \d test_tbl2
!              Table "public.test_tbl2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | text    |           |          | 
!  c      | text    |           |          | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
  ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
  \d test_type2
!              Composite type "public.test_type2"
!  Column |       Type        | Collation | Nullable | Default 
! --------+-------------------+-----------+----------+---------
!  a      | integer           |           |          | 
!  b      | character varying |           |          | 
!  c      | text              |           |          | 
! 
  \d test_tbl2
!                   Table "public.test_tbl2"
!  Column |       Type        | Collation | Nullable | Default 
! --------+-------------------+-----------+----------+---------
!  a      | integer           |           |          | 
!  b      | character varying |           |          | 
!  c      | text              |           |          | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
  ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
  \d test_type2
!         Composite type "public.test_type2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  c      | text    |           |          | 
! 
  \d test_tbl2
!              Table "public.test_tbl2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  c      | text    |           |          | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
  \d test_type2
!         Composite type "public.test_type2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  aa     | integer |           |          | 
!  c      | text    |           |          | 
! 
  \d test_tbl2
!              Table "public.test_tbl2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  aa     | integer |           |          | 
!  c      | text    |           |          | 
! Number of child tables: 1 (Use \d+ to list them.)
! Typed table of type: test_type2
! 
  \d test_tbl2_subclass
!          Table "public.test_tbl2_subclass"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  aa     | integer |           |          | 
!  c      | text    |           |          | 
! Inherits: test_tbl2
! 
  DROP TABLE test_tbl2_subclass;
  CREATE TYPE test_typex AS (a int, b text);
  CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
--- 2611,2653 ----
  CREATE TABLE test_tbl2 OF test_type2;
  CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
  \d test_type2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_tbl2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
  \d test_type2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_tbl2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
  \d test_type2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_tbl2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
  \d test_type2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_tbl2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
  ERROR:  cannot alter type "test_type2" because it is the type of a typed table
  HINT:  Use ALTER ... CASCADE to alter the typed tables too.
  ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
  \d test_type2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_tbl2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d test_tbl2_subclass
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TABLE test_tbl2_subclass;
  CREATE TYPE test_typex AS (a int, b text);
  CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
***************
*** 3044,3055 ****
  ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
  NOTICE:  drop cascades to constraint test_tblx_y_check on table test_tblx
  \d test_tblx
!                Table "public.test_tblx"
!  Column |    Type    | Collation | Nullable | Default 
! --------+------------+-----------+----------+---------
!  x      | integer    |           |          | 
!  y      | test_typex |           |          | 
! 
  DROP TABLE test_tblx;
  DROP TYPE test_typex;
  -- This test isn't that interesting on its own, but the purpose is to leave
--- 2658,2664 ----
  ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
  NOTICE:  drop cascades to constraint test_tblx_y_check on table test_tblx
  \d test_tblx
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TABLE test_tblx;
  DROP TYPE test_typex;
  -- This test isn't that interesting on its own, but the purpose is to leave
***************
*** 3092,3103 ****
  ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
  ALTER TABLE tt7 NOT OF;
  \d tt7
!                    Table "public.tt7"
!  Column |     Type     | Collation | Nullable | Default 
! --------+--------------+-----------+----------+---------
!  x      | integer      |           |          | 
!  y      | numeric(8,2) |           |          | 
! 
  -- make sure we can drop a constraint on the parent but it remains on the child
  CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
  CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
--- 2701,2707 ----
  ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
  ALTER TABLE tt7 NOT OF;
  \d tt7
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- make sure we can drop a constraint on the parent but it remains on the child
  CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
  CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
***************
*** 3132,3147 ****
  ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
  ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
  \d alter2.tt8
!                 Table "alter2.tt8"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  f1     | integer |           | not null | 0
! Indexes:
!     "xxx" PRIMARY KEY, btree (f1)
! Check constraints:
!     "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)
! 
  DROP TABLE alter2.tt8;
  DROP SCHEMA alter2;
  --
--- 2736,2742 ----
  ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
  ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
  \d alter2.tt8
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TABLE alter2.tt8;
  DROP SCHEMA alter2;
  --
***************
*** 3164,3183 ****
  ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6);
  ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
  \d tt9
!                 Table "public.tt9"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c      | integer |           |          | 
! Indexes:
!     "tt9_c_key" UNIQUE CONSTRAINT, btree (c)
!     "tt9_c_key1" UNIQUE CONSTRAINT, btree (c)
!     "tt9_c_key3" UNIQUE CONSTRAINT, btree (c)
! Check constraints:
!     "foo" CHECK (c > 3)
!     "tt9_c_check" CHECK (c > 1)
!     "tt9_c_check1" CHECK (c > 2)
!     "tt9_c_key2" CHECK (c > 6)
! 
  DROP TABLE tt9;
  -- Check that comments on constraints and indexes are not lost at ALTER TABLE.
  CREATE TABLE comment_test (
--- 2759,2765 ----
  ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6);
  ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
  \d tt9
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TABLE tt9;
  -- Check that comments on constraints and indexes are not lost at ALTER TABLE.
  CREATE TABLE comment_test (
***************
*** 3198,3216 ****
  (1 row)
  
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
!        index        |                    comment                    
! --------------------+-----------------------------------------------
!  comment_test_index | Simple index on comment_test
!  comment_test_pk    | Index backing the PRIMARY KEY of comment_test
! (2 rows)
! 
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
!            constraint            |                    comment                    
! ---------------------------------+-----------------------------------------------
!  comment_test_pk                 | PRIMARY KEY constraint of comment_test
!  comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
! (2 rows)
! 
  -- Change the datatype of all the columns. ALTER TABLE is optimized to not
  -- rebuild an index if the new data type is binary compatible with the old
  -- one. Check do a dummy ALTER TABLE that doesn't change the datatype
--- 2780,2790 ----
  (1 row)
  
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  -- Change the datatype of all the columns. ALTER TABLE is optimized to not
  -- rebuild an index if the new data type is binary compatible with the old
  -- one. Check do a dummy ALTER TABLE that doesn't change the datatype
***************
*** 3229,3247 ****
  (1 row)
  
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
!        index        |                    comment                    
! --------------------+-----------------------------------------------
!  comment_test_index | Simple index on comment_test
!  comment_test_pk    | Index backing the PRIMARY KEY of comment_test
! (2 rows)
! 
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
!            constraint            |                    comment                    
! ---------------------------------+-----------------------------------------------
!  comment_test_pk                 | PRIMARY KEY constraint of comment_test
!  comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
! (2 rows)
! 
  -- Check compatibility for foreign keys and comments. This is done
  -- separately as rebuilding the column type of the parent leads
  -- to an error and would reduce the test scope.
--- 2803,2813 ----
  (1 row)
  
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  -- Check compatibility for foreign keys and comments. This is done
  -- separately as rebuilding the column type of the parent leads
  -- to an error and would reduce the test scope.
***************
*** 3264,3280 ****
  (1 row)
  
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
!          index         |                       comment                       
! -----------------------+-----------------------------------------------------
!  comment_test_child_fk | Index backing the FOREIGN KEY of comment_test_child
! (1 row)
! 
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
!       constraint       |                   comment                    
! -----------------------+----------------------------------------------
!  comment_test_child_fk | FOREIGN KEY constraint of comment_test_child
! (1 row)
! 
  -- Check that we map relation oids to filenodes and back correctly.  Only
  -- display bad mappings so the test output doesn't change all the time.  A
  -- filenode function call can return NULL for a relation dropped concurrently
--- 2830,2840 ----
  (1 row)
  
  SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL function "obj_description" during inlining
  -- Check that we map relation oids to filenodes and back correctly.  Only
  -- display bad mappings so the test output doesn't change all the time.  A
  -- filenode function call can return NULL for a relation dropped concurrently
***************
*** 3286,3297 ****
  FROM pg_class,
      pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
  WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
  SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
  WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
!  oid | mapped_oid | reltablespace | relfilenode | relname 
! -----+------------+---------------+-------------+---------
! (0 rows)
! 
  -- Checks on creating and manipulation of user defined relations in
  -- pg_catalog.
  --
--- 2846,2857 ----
  FROM pg_class,
      pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
  WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
+ ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
  WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
! ERROR:  relation "filenode_mapping" does not exist
! LINE 1: SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c...
!                         ^
  -- Checks on creating and manipulation of user defined relations in
  -- pg_catalog.
  --
***************
*** 3301,3329 ****
  SHOW allow_system_table_mods;
   allow_system_table_mods 
  -------------------------
!  off
  (1 row)
  
  -- disallowed because of search_path issues with pg_dump
  CREATE TABLE pg_catalog.new_system_table();
- ERROR:  permission denied to create "pg_catalog.new_system_table"
- DETAIL:  System catalog modifications are currently disallowed.
  -- instead create in public first, move to catalog
  CREATE TABLE new_system_table(id serial primary key, othercol text);
  ALTER TABLE new_system_table SET SCHEMA pg_catalog;
  -- XXX: it's currently impossible to move relations out of pg_catalog
  ALTER TABLE new_system_table SET SCHEMA public;
! ERROR:  cannot remove dependency on schema pg_catalog because it is a system object
  -- move back, will be ignored -- already there
  ALTER TABLE new_system_table SET SCHEMA pg_catalog;
  ALTER TABLE new_system_table RENAME TO old_system_table;
  CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
  INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
  UPDATE old_system_table SET id = -id;
  DELETE FROM old_system_table WHERE othercol = 'somedata';
  TRUNCATE old_system_table;
  ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
  ALTER TABLE old_system_table DROP COLUMN othercol;
  DROP TABLE old_system_table;
  -- set logged
  CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
--- 2861,2899 ----
  SHOW allow_system_table_mods;
   allow_system_table_mods 
  -------------------------
!  on
  (1 row)
  
  -- disallowed because of search_path issues with pg_dump
  CREATE TABLE pg_catalog.new_system_table();
  -- instead create in public first, move to catalog
  CREATE TABLE new_system_table(id serial primary key, othercol text);
  ALTER TABLE new_system_table SET SCHEMA pg_catalog;
  -- XXX: it's currently impossible to move relations out of pg_catalog
  ALTER TABLE new_system_table SET SCHEMA public;
! ERROR:  relation "new_system_table" already exists in schema "public"
  -- move back, will be ignored -- already there
  ALTER TABLE new_system_table SET SCHEMA pg_catalog;
  ALTER TABLE new_system_table RENAME TO old_system_table;
  CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
+ ERROR:  column "othercol" does not exist
  INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
+ ERROR:  column "othercol" of relation "old_system_table" does not exist
+ LINE 1: INSERT INTO old_system_table(othercol) VALUES ('somedata'), ...
+                                      ^
  UPDATE old_system_table SET id = -id;
+ ERROR:  column "id" does not exist
+ LINE 1: UPDATE old_system_table SET id = -id;
+                                           ^
  DELETE FROM old_system_table WHERE othercol = 'somedata';
+ ERROR:  column "othercol" does not exist
+ LINE 1: DELETE FROM old_system_table WHERE othercol = 'somedata';
+                                            ^
  TRUNCATE old_system_table;
  ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
+ ERROR:  constraint "new_system_table_pkey" of relation "old_system_table" does not exist
  ALTER TABLE old_system_table DROP COLUMN othercol;
+ ERROR:  column "othercol" of relation "old_system_table" does not exist
  DROP TABLE old_system_table;
  -- set logged
  CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT);
***************
*** 3334,3348 ****
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
  ORDER BY relname;
!      relname      | relkind | relpersistence 
! ------------------+---------+----------------
!  toast index      | i       | u
!  toast table      | t       | u
!  unlogged1        | r       | u
!  unlogged1_f1_seq | S       | p
!  unlogged1_pkey   | i       | u
! (5 rows)
! 
  CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
  CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
  ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
--- 2904,2910 ----
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
  ORDER BY relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
  CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
  ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
***************
*** 3356,3370 ****
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
  ORDER BY relname;
!      relname      | relkind | relpersistence 
! ------------------+---------+----------------
!  toast index      | i       | p
!  toast table      | t       | p
!  unlogged1        | r       | p
!  unlogged1_f1_seq | S       | p
!  unlogged1_pkey   | i       | p
! (5 rows)
! 
  ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
  DROP TABLE unlogged3;
  DROP TABLE unlogged2;
--- 2918,2924 ----
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
  ORDER BY relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
  DROP TABLE unlogged3;
  DROP TABLE unlogged2;
***************
*** 3378,3392 ****
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
  ORDER BY relname;
!     relname     | relkind | relpersistence 
! ----------------+---------+----------------
!  logged1        | r       | p
!  logged1_f1_seq | S       | p
!  logged1_pkey   | i       | p
!  toast index    | i       | p
!  toast table    | t       | p
! (5 rows)
! 
  CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
  CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
  ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
--- 2932,2938 ----
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
  ORDER BY relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
  CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
  ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
***************
*** 3401,3415 ****
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
  ORDER BY relname;
!     relname     | relkind | relpersistence 
! ----------------+---------+----------------
!  logged1        | r       | u
!  logged1_f1_seq | S       | p
!  logged1_pkey   | i       | u
!  toast index    | i       | u
!  toast table    | t       | u
! (5 rows)
! 
  ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
  DROP TABLE logged3;
  DROP TABLE logged2;
--- 2947,2953 ----
  UNION ALL
  SELECT 'toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
  ORDER BY relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
  DROP TABLE logged3;
  DROP TABLE logged2;
***************
*** 3417,3436 ****
  -- test ADD COLUMN IF NOT EXISTS
  CREATE TABLE test_add_column(c1 integer);
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer;
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer; -- fail because c2 already exists
  ERROR:  column "c2" of relation "test_add_column" already exists
--- 2955,2965 ----
  -- test ADD COLUMN IF NOT EXISTS
  CREATE TABLE test_add_column(c1 integer);
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer;
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer; -- fail because c2 already exists
  ERROR:  column "c2" of relation "test_add_column" already exists
***************
*** 3438,3449 ****
  	ADD COLUMN c2 integer; -- fail because c2 already exists
  ERROR:  column "c2" of relation "test_add_column" already exists
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
--- 2967,2973 ----
  	ADD COLUMN c2 integer; -- fail because c2 already exists
  ERROR:  column "c2" of relation "test_add_column" already exists
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
***************
*** 3451,3498 ****
  	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer, -- fail because c2 already exists
  	ADD COLUMN c3 integer;
  ERROR:  column "c2" of relation "test_add_column" already exists
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
  	ADD COLUMN c3 integer; -- fail because c3 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
!  c3     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
  	ADD COLUMN IF NOT EXISTS c3 integer; -- skipping because c3 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
!  c3     | integer |           |          | 
! 
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
  	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
--- 2975,3000 ----
  	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN c2 integer, -- fail because c2 already exists
  	ADD COLUMN c3 integer;
  ERROR:  column "c2" of relation "test_add_column" already exists
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
  	ADD COLUMN c3 integer; -- fail because c3 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
  	ADD COLUMN IF NOT EXISTS c3 integer; -- skipping because c3 already exists
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE test_add_column
  	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
  	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
***************
*** 3500,3513 ****
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
  \d test_add_column
!           Table "public.test_add_column"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  c1     | integer |           |          | 
!  c2     | integer |           |          | 
!  c3     | integer |           |          | 
!  c4     | integer |           |          | 
! 
  DROP TABLE test_add_column;
  -- unsupported constraint types for partitioned tables
  CREATE TABLE partitioned (
--- 3002,3008 ----
  NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
  NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
  \d test_add_column
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  DROP TABLE test_add_column;
  -- unsupported constraint types for partitioned tables
  CREATE TABLE partitioned (
***************
*** 3575,3585 ****
  CREATE TABLE owned_by_me (
  	a int
  ) PARTITION BY LIST (a);
  ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
! ERROR:  must be owner of table not_owned_by_me
  RESET SESSION AUTHORIZATION;
  DROP TABLE owned_by_me, not_owned_by_me;
  DROP ROLE regress_test_not_me;
  DROP ROLE regress_test_me;
  -- check that the table being attached is not part of regular inheritance
  CREATE TABLE parent (LIKE list_parted);
--- 3070,3086 ----
  CREATE TABLE owned_by_me (
  	a int
  ) PARTITION BY LIST (a);
+ ERROR:  no schema has been selected to create in
+ LINE 1: CREATE TABLE owned_by_me (
+                      ^
  ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
! ERROR:  relation "owned_by_me" does not exist
  RESET SESSION AUTHORIZATION;
  DROP TABLE owned_by_me, not_owned_by_me;
+ ERROR:  table "owned_by_me" does not exist
  DROP ROLE regress_test_not_me;
+ ERROR:  role "regress_test_not_me" cannot be dropped because some objects depend on it
+ DETAIL:  owner of table not_owned_by_me
  DROP ROLE regress_test_me;
  -- check that the table being attached is not part of regular inheritance
  CREATE TABLE parent (LIKE list_parted);
***************
*** 3598,3608 ****
  DROP TABLE temp_parted, perm_part;
  -- check that the table being attached is not a typed table
  CREATE TYPE mytype AS (a int);
  CREATE TABLE fail_part OF mytype;
  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
! ERROR:  cannot attach a typed table as partition
  DROP TYPE mytype CASCADE;
! NOTICE:  drop cascades to table fail_part
  -- check existence (or non-existence) of oid column
  ALTER TABLE list_parted SET WITH OIDS;
  CREATE TABLE fail_part (a int);
--- 3099,3111 ----
  DROP TABLE temp_parted, perm_part;
  -- check that the table being attached is not a typed table
  CREATE TYPE mytype AS (a int);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  CREATE TABLE fail_part OF mytype;
+ ERROR:  type "mytype" does not exist
  ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
! ERROR:  relation "fail_part" does not exist
  DROP TYPE mytype CASCADE;
! ERROR:  type "mytype" does not exist
  -- check existence (or non-existence) of oid column
  ALTER TABLE list_parted SET WITH OIDS;
  CREATE TABLE fail_part (a int);

======================================================================

*** contrib/mmts/../../src/test/regress/expected/sequence.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/sequence.out	CENSORED
***************
*** 627,791 ****
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT SELECT ON seq3 TO regress_seq_user;
  SELECT nextval('seq3');
! ERROR:  permission denied for sequence seq3
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT UPDATE ON seq3 TO regress_seq_user;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT USAGE ON seq3 TO regress_seq_user;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  ROLLBACK;
  -- currval
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT SELECT ON seq3 TO regress_seq_user;
  SELECT currval('seq3');
!  currval 
! ---------
!        1
! (1 row)
! 
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT UPDATE ON seq3 TO regress_seq_user;
  SELECT currval('seq3');
! ERROR:  permission denied for sequence seq3
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT USAGE ON seq3 TO regress_seq_user;
  SELECT currval('seq3');
!  currval 
! ---------
!        1
! (1 row)
! 
  ROLLBACK;
  -- lastval
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT SELECT ON seq3 TO regress_seq_user;
  SELECT lastval();
!  lastval 
! ---------
!        1
! (1 row)
! 
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT UPDATE ON seq3 TO regress_seq_user;
  SELECT lastval();
! ERROR:  permission denied for sequence seq3
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  SELECT nextval('seq3');
!  nextval 
! ---------
!        1
! (1 row)
! 
  REVOKE ALL ON seq3 FROM regress_seq_user;
  GRANT USAGE ON seq3 TO regress_seq_user;
  SELECT lastval();
!  lastval 
! ---------
!        1
! (1 row)
! 
  ROLLBACK;
  -- setval
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
  REVOKE ALL ON seq3 FROM regress_seq_user;
  SAVEPOINT save;
  SELECT setval('seq3', 5);
! ERROR:  permission denied for sequence seq3
  ROLLBACK TO save;
  GRANT UPDATE ON seq3 TO regress_seq_user;
  SELECT setval('seq3', 5);
!  setval 
! --------
!       5
! (1 row)
! 
! SELECT nextval('seq3');
!  nextval 
! ---------
!        6
! (1 row)
! 
  ROLLBACK;
  -- ALTER SEQUENCE
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  ALTER SEQUENCE sequence_test2 START WITH 1;
! ERROR:  must be owner of sequence sequence_test2
  ROLLBACK;
  -- Sequences should get wiped out as well:
  DROP TABLE serialTest1, serialTest2;
--- 627,767 ----
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT SELECT ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT UPDATE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT USAGE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  -- currval
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT SELECT ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT currval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT UPDATE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT currval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT USAGE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT currval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  -- lastval
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT SELECT ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT lastval();
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT UPDATE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT lastval();
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  GRANT USAGE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT lastval();
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  -- setval
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  CREATE SEQUENCE seq3;
+ ERROR:  no schema has been selected to create in
  REVOKE ALL ON seq3 FROM regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SAVEPOINT save;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT setval('seq3', 5);
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK TO save;
+ ERROR:  savepoint "save" does not exist
  GRANT UPDATE ON seq3 TO regress_seq_user;
+ ERROR:  current transaction is aborted, commands ignored until end of transaction block
  SELECT setval('seq3', 5);
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
! SELECT nextval('seq3');
! ERROR:  current transaction is aborted, commands ignored until end of transaction block
  ROLLBACK;
  -- ALTER SEQUENCE
  BEGIN;
  SET LOCAL SESSION AUTHORIZATION regress_seq_user;
  ALTER SEQUENCE sequence_test2 START WITH 1;
! ERROR:  relation "sequence_test2" does not exist
  ROLLBACK;
  -- Sequences should get wiped out as well:
  DROP TABLE serialTest1, serialTest2;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/largeobject.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/largeobject.out	CENSORED
***************
*** 17,31 ****
  		|| ' OWNER TO regress_lo_user';
    END
  $$;
  SELECT
  	rol.rolname
  FROM
  	lotest_stash_values s
  	JOIN pg_largeobject_metadata lo ON s.loid = lo.oid
  	JOIN pg_authid rol ON lo.lomowner = rol.oid;
!      rolname     
! -----------------
!  regress_lo_user
  (1 row)
  
  -- NOTE: large objects require transactions
--- 17,32 ----
  		|| ' OWNER TO regress_lo_user';
    END
  $$;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT
  	rol.rolname
  FROM
  	lotest_stash_values s
  	JOIN pg_largeobject_metadata lo ON s.loid = lo.oid
  	JOIN pg_authid rol ON lo.lomowner = rol.oid;
!  rolname 
! ---------
!  alex
  (1 row)
  
  -- NOTE: large objects require transactions
***************
*** 310,320 ****
  -- lo_unlink(lobjId oid) returns integer
  -- return value appears to always be 1
  SELECT lo_unlink(loid) from lotest_stash_values;
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
  TRUNCATE lotest_stash_values;
  INSERT INTO lotest_stash_values (loid) SELECT lo_import('/home/alex/projects/ppro/postgrespro/contrib/mmts/../../src/test/regress/data/tenk.data');
  BEGIN;
--- 311,317 ----
  -- lo_unlink(lobjId oid) returns integer
  -- return value appears to always be 1
  SELECT lo_unlink(loid) from lotest_stash_values;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  TRUNCATE lotest_stash_values;
  INSERT INTO lotest_stash_values (loid) SELECT lo_import('/home/alex/projects/ppro/postgrespro/contrib/mmts/../../src/test/regress/data/tenk.data');
  BEGIN;
***************
*** 400,410 ****
  (0 rows)
  
  SELECT lo_unlink(loid) FROM lotest_stash_values;
!  lo_unlink 
! -----------
!          1
! (1 row)
! 
  TRUNCATE lotest_stash_values;
  \lo_unlink :newloid
  \lo_import '/home/alex/projects/ppro/postgrespro/contrib/mmts/../../src/test/regress/results/lotest.txt'
--- 397,403 ----
  (0 rows)
  
  SELECT lo_unlink(loid) FROM lotest_stash_values;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  TRUNCATE lotest_stash_values;
  \lo_unlink :newloid
  \lo_import '/home/alex/projects/ppro/postgrespro/contrib/mmts/../../src/test/regress/results/lotest.txt'

======================================================================

*** contrib/mmts/../../src/test/regress/expected/with.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/with.out	CENSORED
***************
*** 1875,1892 ****
--- 1875,1897 ----
  WITH aa AS (SELECT 1 a, 2 b)
  INSERT INTO withz VALUES(1, 'insert')
  ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  WITH aa AS (SELECT 1 a, 2 b)
  INSERT INTO withz VALUES(1, 'insert')
  ON CONFLICT (k) DO UPDATE SET v = ' update' WHERE withz.k = (SELECT a FROM aa);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  WITH aa AS (SELECT 1 a, 2 b)
  INSERT INTO withz VALUES(1, 'insert')
  ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  WITH aa AS (SELECT 'a' a, 'b' b UNION ALL SELECT 'a' a, 'b' b)
  INSERT INTO withz VALUES(1, 'insert')
  ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 'a' LIMIT 1);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  WITH aa AS (SELECT 1 a, 2 b)
  INSERT INTO withz VALUES(1, (SELECT b || ' insert' FROM aa WHERE a = 1 ))
  ON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  -- Update a row more than once, in different parts of a wCTE. That is
  -- an allowed, presumably very rare, edge case, but since it was
  -- broken in the past, having a test seems worthwhile.
***************
*** 1899,1908 ****
  INSERT INTO withz VALUES(2, 'Red') ON CONFLICT (k) DO
  UPDATE SET (k, v) = (SELECT k, v FROM upsert_cte WHERE upsert_cte.k = withz.k)
  RETURNING k, v;
!  k | v 
! ---+---
! (0 rows)
! 
  DROP TABLE withz;
  -- check that run to completion happens in proper ordering
  TRUNCATE TABLE y;
--- 1904,1910 ----
  INSERT INTO withz VALUES(2, 'Red') ON CONFLICT (k) DO
  UPDATE SET (k, v) = (SELECT k, v FROM upsert_cte WHERE upsert_cte.k = withz.k)
  RETURNING k, v;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  DROP TABLE withz;
  -- check that run to completion happens in proper ordering
  TRUNCATE TABLE y;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/autoprepare.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/autoprepare.out	CENSORED
***************
*** 1,9 ****
  select count(*) from pg_class where relname='pg_class';
!  count 
! -------
!      1
! (1 row)
! 
  select * from pg_autoprepared_statements;
   statement | parameter_types | exec_count 
  -----------+-----------------+------------
--- 1,5 ----
  select count(*) from pg_class where relname='pg_class';
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select * from pg_autoprepared_statements;
   statement | parameter_types | exec_count 
  -----------+-----------------+------------
***************
*** 11,40 ****
  
  set autoprepare_threshold = 1;
  select count(*) from pg_class where relname='pg_class';
!  count 
! -------
!      1
! (1 row)
! 
  select * from pg_autoprepared_statements;
!                         statement                        | parameter_types | exec_count 
! ---------------------------------------------------------+-----------------+------------
!  select count(*) from pg_class where relname='pg_class'; | {unknown}       |          1
!  select * from pg_autoprepared_statements;               | {}              |          1
! (2 rows)
! 
! select count(*) from pg_class where relname='pg_class';
!  count 
! -------
!      1
  (1 row)
  
  select * from pg_autoprepared_statements;
!                         statement                        | parameter_types | exec_count 
! ---------------------------------------------------------+-----------------+------------
!  select count(*) from pg_class where relname='pg_class'; | {unknown}       |          2
!  select * from pg_autoprepared_statements;               | {}              |          2
! (2 rows)
  
  set autoprepare_threshold = 0;
  select * from pg_autoprepared_statements;
--- 7,26 ----
  
  set autoprepare_threshold = 1;
  select count(*) from pg_class where relname='pg_class';
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select * from pg_autoprepared_statements;
!                  statement                 | parameter_types | exec_count 
! -------------------------------------------+-----------------+------------
!  select * from pg_autoprepared_statements; | {}              |          1
  (1 row)
  
+ select count(*) from pg_class where relname='pg_class';
+ ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select * from pg_autoprepared_statements;
!                  statement                 | parameter_types | exec_count 
! -------------------------------------------+-----------------+------------
!  select * from pg_autoprepared_statements; | {}              |          2
! (1 row)
  
  set autoprepare_threshold = 0;
  select * from pg_autoprepared_statements;
***************
*** 43,53 ****
  (0 rows)
  
  select count(*) from pg_class where relname='pg_class';
!  count 
! -------
!      1
! (1 row)
! 
  select * from pg_autoprepared_statements;
   statement | parameter_types | exec_count 
  -----------+-----------------+------------
--- 29,35 ----
  (0 rows)
  
  select count(*) from pg_class where relname='pg_class';
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select * from pg_autoprepared_statements;
   statement | parameter_types | exec_count 
  -----------+-----------------+------------

======================================================================

*** contrib/mmts/../../src/test/regress/expected/identity.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/identity.out	CENSORED
***************
*** 33,44 ****
  (1 row)
  
  \d itest1_a_seq
!                     Sequence "public.itest1_a_seq"
!   Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
! ---------+-------+---------+------------+-----------+---------+-------
!  integer |     1 |       1 | 2147483647 |         1 | no      |     1
! Sequence for identity column: public.itest1.a
! 
  CREATE TABLE itest4 (a int, b text);
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, requires NOT NULL
  ERROR:  column "a" of relation "itest4" must be declared NOT NULL before identity can be added
--- 33,39 ----
  (1 row)
  
  \d itest1_a_seq
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  CREATE TABLE itest4 (a int, b text);
  ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY;  -- error, requires NOT NULL
  ERROR:  column "a" of relation "itest4" must be declared NOT NULL before identity can be added
***************
*** 281,292 ****
  (1 row)
  
  \d itest3
!                            Table "public.itest3"
!  Column |  Type   | Collation | Nullable |             Default              
! --------+---------+-----------+----------+----------------------------------
!  a      | integer |           | not null | generated by default as identity
!  b      | text    |           |          | 
! 
  ALTER TABLE itest3 ALTER COLUMN a TYPE text;  -- error
  ERROR:  identity column type must be smallint, integer, or bigint
  -- ALTER COLUMN ... SET
--- 276,282 ----
  (1 row)
  
  \d itest3
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  ALTER TABLE itest3 ALTER COLUMN a TYPE text;  -- error
  ERROR:  identity column type must be smallint, integer, or bigint
  -- ALTER COLUMN ... SET
***************
*** 365,376 ****
  GRANT SELECT, INSERT ON itest8 TO regress_identity_user1;
  SET ROLE regress_identity_user1;
  INSERT INTO itest8 DEFAULT VALUES;
  SELECT * FROM itest8;
!  a | b 
! ---+---
!  1 | 
! (1 row)
! 
  RESET ROLE;
  DROP TABLE itest8;
  DROP USER regress_identity_user1;
--- 355,367 ----
  GRANT SELECT, INSERT ON itest8 TO regress_identity_user1;
  SET ROLE regress_identity_user1;
  INSERT INTO itest8 DEFAULT VALUES;
+ ERROR:  relation "itest8" does not exist
+ LINE 1: INSERT INTO itest8 DEFAULT VALUES;
+                     ^
  SELECT * FROM itest8;
! ERROR:  relation "itest8" does not exist
! LINE 1: SELECT * FROM itest8;
!                       ^
  RESET ROLE;
  DROP TABLE itest8;
  DROP USER regress_identity_user1;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/indexing.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/indexing.out	CENSORED
***************
*** 55,99 ****
  create index idxparti2 on idxpart (b, c);
  create table idxpart1 (like idxpart);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
!  c      | text    |           |          | 
! 
  alter table idxpart attach partition idxpart1 for values from (0) to (10);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
!  c      | text    |           |          | 
! Partition of: idxpart FOR VALUES FROM (0) TO (10)
! Indexes:
!     "idxpart1_a_idx" btree (a)
!     "idxpart1_b_c_idx" btree (b, c)
! 
  \d+ idxpart1_a_idx
!                  Index "public.idxpart1_a_idx"
!  Column |  Type   | Key? | Definition | Storage | Stats target 
! --------+---------+------+------------+---------+--------------
!  a      | integer | yes  | a          | plain   | 
! Partition of: idxparti 
! No partition constraint
! btree, for table "public.idxpart1"
! 
  \d+ idxpart1_b_c_idx
!                 Index "public.idxpart1_b_c_idx"
!  Column |  Type   | Key? | Definition | Storage  | Stats target 
! --------+---------+------+------------+----------+--------------
!  b      | integer | yes  | b          | plain    | 
!  c      | text    | yes  | c          | extended | 
! Partition of: idxparti2 
! No partition constraint
! btree, for table "public.idxpart1"
! 
  drop table idxpart;
  -- If a partition already has an index, don't create a duplicative one
  create table idxpart (a int, b int) partition by range (a, b);
--- 55,68 ----
  create index idxparti2 on idxpart (b, c);
  create table idxpart1 (like idxpart);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  alter table idxpart attach partition idxpart1 for values from (0) to (10);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d+ idxpart1_a_idx
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d+ idxpart1_b_c_idx
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- If a partition already has an index, don't create a duplicative one
  create table idxpart (a int, b int) partition by range (a, b);
***************
*** 101,115 ****
  create index on idxpart1 (a, b);
  create index on idxpart (a, b);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (0, 0) TO (10, 10)
! Indexes:
!     "idxpart1_a_b_idx" btree (a, b)
! 
  select relname, relkind, inhparent::regclass
      from pg_class left join pg_index ix on (indexrelid = oid)
  	left join pg_inherits on (ix.indexrelid = inhrelid)
--- 70,76 ----
  create index on idxpart1 (a, b);
  create index on idxpart (a, b);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, relkind, inhparent::regclass
      from pg_class left join pg_index ix on (indexrelid = oid)
  	left join pg_inherits on (ix.indexrelid = inhrelid)
***************
*** 133,154 ****
  drop index idxpart_a_idx;	-- both indexes go away
  select relname, relkind from pg_class
    where relname like 'idxpart%' order by relname;
!  relname  | relkind 
! ----------+---------
!  idxpart  | p
!  idxpart1 | r
! (2 rows)
! 
  create index on idxpart (a);
  drop table idxpart1;		-- the index on partition goes away too
  select relname, relkind from pg_class
    where relname like 'idxpart%' order by relname;
!     relname    | relkind 
! ---------------+---------
!  idxpart       | p
!  idxpart_a_idx | I
! (2 rows)
! 
  drop table idxpart;
  -- ALTER INDEX .. ATTACH, error cases
  create table idxpart (a int, b int) partition by range (a, b);
--- 94,105 ----
  drop index idxpart_a_idx;	-- both indexes go away
  select relname, relkind from pg_class
    where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  create index on idxpart (a);
  drop table idxpart1;		-- the index on partition goes away too
  select relname, relkind from pg_class
    where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- ALTER INDEX .. ATTACH, error cases
  create table idxpart (a int, b int) partition by range (a, b);
***************
*** 202,220 ****
  create index on idxpart (a);
  alter table idxpart attach partition idxpart1 for values from (0) to (1000);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (0) TO (1000)
! Indexes:
!     "idxpart1_a_a1_idx" btree (a, a)
!     "idxpart1_a_idx" hash (a)
!     "idxpart1_a_idx1" btree (a) WHERE b > 1
!     "idxpart1_a_idx2" btree (a)
!     "idxpart1_expr_idx" btree ((a + 0))
! 
  drop table idxpart;
  -- If CREATE INDEX ONLY, don't create indexes on partitions; and existing
  -- indexes on partitions don't change parent.  ALTER INDEX ATTACH can change
--- 153,159 ----
  create index on idxpart (a);
  alter table idxpart attach partition idxpart1 for values from (0) to (1000);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- If CREATE INDEX ONLY, don't create indexes on partitions; and existing
  -- indexes on partitions don't change parent.  ALTER INDEX ATTACH can change
***************
*** 231,262 ****
  -- Here we expect that idxpart1 and idxpart2 have a new index, but idxpart21
  -- does not; also, idxpart22 is not attached.
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (0) TO (100)
! Indexes:
!     "idxpart1_a_idx" btree (a)
! 
  \d idxpart2
!               Table "public.idxpart2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (100) TO (1000)
! Partition key: RANGE (a)
! Indexes:
!     "idxpart2_a_idx" btree (a) INVALID
! Number of partitions: 2 (Use \d+ to list them.)
! 
  \d idxpart21
!              Table "public.idxpart21"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! Partition of: idxpart2 FOR VALUES FROM (100) TO (200)
! 
  select indexrelid::regclass, indrelid::regclass, inhparent::regclass
    from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
  where indexrelid::regclass::text like 'idxpart%'
--- 170,180 ----
  -- Here we expect that idxpart1 and idxpart2 have a new index, but idxpart21
  -- does not; also, idxpart22 is not attached.
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d idxpart2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d idxpart21
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select indexrelid::regclass, indrelid::regclass, inhparent::regclass
    from pg_index idx left join pg_inherits inh on (idx.indexrelid = inh.inhrelid)
  where indexrelid::regclass::text like 'idxpart%'
***************
*** 285,314 ****
  -- attaching idxpart22 is not enough to set idxpart22_a_idx valid ...
  alter index idxpart2_a_idx attach partition idxpart22_a_idx;
  \d idxpart2
!               Table "public.idxpart2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (100) TO (1000)
! Partition key: RANGE (a)
! Indexes:
!     "idxpart2_a_idx" btree (a) INVALID
! Number of partitions: 2 (Use \d+ to list them.)
! 
  -- ... but this one is.
  create index on idxpart21 (a);
  alter index idxpart2_a_idx attach partition idxpart21_a_idx;
  \d idxpart2
!               Table "public.idxpart2"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (100) TO (1000)
! Partition key: RANGE (a)
! Indexes:
!     "idxpart2_a_idx" btree (a)
! Number of partitions: 2 (Use \d+ to list them.)
! 
  drop table idxpart;
  -- When a table is attached a partition and it already has an index, a
  -- duplicate index should not get created, but rather the index becomes
--- 203,214 ----
  -- attaching idxpart22 is not enough to set idxpart22_a_idx valid ...
  alter index idxpart2_a_idx attach partition idxpart22_a_idx;
  \d idxpart2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- ... but this one is.
  create index on idxpart21 (a);
  alter index idxpart2_a_idx attach partition idxpart21_a_idx;
  \d idxpart2
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- When a table is attached a partition and it already has an index, a
  -- duplicate index should not get created, but rather the index becomes
***************
*** 318,333 ****
  create index idxparti2 on idxpart (b, c);
  create table idxpart1 (like idxpart including indexes);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
!  c      | text    |           |          | 
! Indexes:
!     "idxpart1_a_idx" btree (a)
!     "idxpart1_b_c_idx" btree (b, c)
! 
  select relname, relkind, inhparent::regclass
      from pg_class left join pg_index ix on (indexrelid = oid)
  	left join pg_inherits on (ix.indexrelid = inhrelid)
--- 218,224 ----
  create index idxparti2 on idxpart (b, c);
  create table idxpart1 (like idxpart including indexes);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, relkind, inhparent::regclass
      from pg_class left join pg_index ix on (indexrelid = oid)
  	left join pg_inherits on (ix.indexrelid = inhrelid)
***************
*** 344,360 ****
  
  alter table idxpart attach partition idxpart1 for values from (0) to (10);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
!  c      | text    |           |          | 
! Partition of: idxpart FOR VALUES FROM (0) TO (10)
! Indexes:
!     "idxpart1_a_idx" btree (a)
!     "idxpart1_b_c_idx" btree (b, c)
! 
  select relname, relkind, inhparent::regclass
      from pg_class left join pg_index ix on (indexrelid = oid)
  	left join pg_inherits on (ix.indexrelid = inhrelid)
--- 235,241 ----
  
  alter table idxpart attach partition idxpart1 for values from (0) to (10);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select relname, relkind, inhparent::regclass
      from pg_class left join pg_index ix on (indexrelid = oid)
  	left join pg_inherits on (ix.indexrelid = inhrelid)
***************
*** 422,439 ****
  alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
  create table idxpart3 partition of idxpart for values from (2000) to (3000);
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
!     relname     | relkind 
! ----------------+---------
!  idxpart        | p
!  idxpart1       | r
!  idxpart1_a_idx | i
!  idxpart2       | r
!  idxpart2_a_idx | i
!  idxpart3       | r
!  idxpart3_a_idx | i
!  idxpart_a_idx  | I
! (8 rows)
! 
  -- a) after detaching partitions, the indexes can be dropped independently
  alter table idxpart detach partition idxpart1;
  alter table idxpart detach partition idxpart2;
--- 303,309 ----
  alter table idxpart attach partition idxpart2 for values from (1000) to (2000);
  create table idxpart3 partition of idxpart for values from (2000) to (3000);
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- a) after detaching partitions, the indexes can be dropped independently
  alter table idxpart detach partition idxpart1;
  alter table idxpart detach partition idxpart2;
***************
*** 442,462 ****
  drop index idxpart2_a_idx;
  drop index idxpart3_a_idx;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
!     relname    | relkind 
! ---------------+---------
!  idxpart       | p
!  idxpart1      | r
!  idxpart2      | r
!  idxpart3      | r
!  idxpart_a_idx | I
! (5 rows)
! 
  drop table idxpart, idxpart1, idxpart2, idxpart3;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
!  relname | relkind 
! ---------+---------
! (0 rows)
! 
  create table idxpart (a int) partition by range (a);
  create table idxpart1 (like idxpart);
  create index on idxpart1 (a);
--- 312,321 ----
  drop index idxpart2_a_idx;
  drop index idxpart3_a_idx;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart, idxpart1, idxpart2, idxpart3;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  create table idxpart (a int) partition by range (a);
  create table idxpart1 (like idxpart);
  create index on idxpart1 (a);
***************
*** 467,506 ****
  create table idxpart3 partition of idxpart for values from (2000) to (3000);
  -- b) after detaching, dropping the index on parent does not remove the others
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
!     relname     | relkind 
! ----------------+---------
!  idxpart        | p
!  idxpart1       | r
!  idxpart1_a_idx | i
!  idxpart2       | r
!  idxpart2_a_idx | i
!  idxpart3       | r
!  idxpart3_a_idx | i
!  idxpart_a_idx  | I
! (8 rows)
! 
  alter table idxpart detach partition idxpart1;
  alter table idxpart detach partition idxpart2;
  alter table idxpart detach partition idxpart3;
  drop index idxpart_a_idx;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
!     relname     | relkind 
! ----------------+---------
!  idxpart        | p
!  idxpart1       | r
!  idxpart1_a_idx | i
!  idxpart2       | r
!  idxpart2_a_idx | i
!  idxpart3       | r
!  idxpart3_a_idx | i
! (7 rows)
! 
  drop table idxpart, idxpart1, idxpart2, idxpart3;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
!  relname | relkind 
! ---------+---------
! (0 rows)
! 
  -- Verify that expression indexes inherit correctly
  create table idxpart (a int, b int) partition by range (a);
  create table idxpart1 (like idxpart);
--- 326,341 ----
  create table idxpart3 partition of idxpart for values from (2000) to (3000);
  -- b) after detaching, dropping the index on parent does not remove the others
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  alter table idxpart detach partition idxpart1;
  alter table idxpart detach partition idxpart2;
  alter table idxpart detach partition idxpart3;
  drop index idxpart_a_idx;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart, idxpart1, idxpart2, idxpart3;
  select relname, relkind from pg_class where relname like 'idxpart%' order by relname;
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- Verify that expression indexes inherit correctly
  create table idxpart (a int, b int) partition by range (a);
  create table idxpart1 (like idxpart);
***************
*** 637,652 ****
    from pg_class c join pg_index i on c.oid = i.indexrelid
    where indrelid::regclass::text like 'idxpart%'
    order by indexrelid::regclass::text collate "C";
!      relname      |                           pg_get_indexdef                           
! ------------------+---------------------------------------------------------------------
!  idxpart1_a_idx   | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a)
!  idxpart1_c_b_idx | CREATE INDEX idxpart1_c_b_idx ON public.idxpart1 USING btree (c, b)
!  idxpart2_a_idx   | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a)
!  idxpart2_c_b_idx | CREATE INDEX idxpart2_c_b_idx ON public.idxpart2 USING btree (c, b)
!  idxparti         | CREATE INDEX idxparti ON ONLY public.idxpart USING btree (a)
!  idxparti2        | CREATE INDEX idxparti2 ON ONLY public.idxpart USING btree (c, b)
! (6 rows)
! 
  drop table idxpart;
  -- Verify that columns are mapped correctly in expression indexes
  create table idxpart (col1 int, col2 int, a int, b int) partition by range (a);
--- 472,478 ----
    from pg_class c join pg_index i on c.oid = i.indexrelid
    where indrelid::regclass::text like 'idxpart%'
    order by indexrelid::regclass::text collate "C";
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- Verify that columns are mapped correctly in expression indexes
  create table idxpart (col1 int, col2 int, a int, b int) partition by range (a);
***************
*** 664,679 ****
    from pg_class c join pg_index i on c.oid = i.indexrelid
    where indrelid::regclass::text like 'idxpart%'
    order by indexrelid::regclass::text collate "C";
!       relname      |                               pg_get_indexdef                                
! -------------------+------------------------------------------------------------------------------
!  idxpart1_abs_idx  | CREATE INDEX idxpart1_abs_idx ON public.idxpart1 USING btree (abs(b))
!  idxpart1_expr_idx | CREATE INDEX idxpart1_expr_idx ON public.idxpart1 USING btree (((b + 1)))
!  idxpart2_abs_idx  | CREATE INDEX idxpart2_abs_idx ON public.idxpart2 USING btree (abs(b))
!  idxpart2_expr_idx | CREATE INDEX idxpart2_expr_idx ON public.idxpart2 USING btree (((b + 1)))
!  idxpart_abs_idx   | CREATE INDEX idxpart_abs_idx ON ONLY public.idxpart USING btree (abs(b))
!  idxpart_expr_idx  | CREATE INDEX idxpart_expr_idx ON ONLY public.idxpart USING btree (((b + 1)))
! (6 rows)
! 
  drop table idxpart;
  -- Verify that columns are mapped correctly for WHERE in a partial index
  create table idxpart (col1 int, a int, col3 int, b int) partition by range (a);
--- 490,496 ----
    from pg_class c join pg_index i on c.oid = i.indexrelid
    where indrelid::regclass::text like 'idxpart%'
    order by indexrelid::regclass::text collate "C";
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- Verify that columns are mapped correctly for WHERE in a partial index
  create table idxpart (col1 int, a int, col3 int, b int) partition by range (a);
***************
*** 690,702 ****
    from pg_class c join pg_index i on c.oid = i.indexrelid
    where indrelid::regclass::text like 'idxpart%'
    order by indexrelid::regclass::text collate "C";
!     relname     |                                  pg_get_indexdef                                   
! ----------------+------------------------------------------------------------------------------------
!  idxpart1_a_idx | CREATE INDEX idxpart1_a_idx ON public.idxpart1 USING btree (a) WHERE (b > 1000)
!  idxpart2_a_idx | CREATE INDEX idxpart2_a_idx ON public.idxpart2 USING btree (a) WHERE (b > 1000)
!  idxpart_a_idx  | CREATE INDEX idxpart_a_idx ON ONLY public.idxpart USING btree (a) WHERE (b > 1000)
! (3 rows)
! 
  drop table idxpart;
  -- Column number mapping: dropped columns in the partition
  create table idxpart1 (drop_1 int, drop_2 int, col_keep int, drop_3 int);
--- 507,513 ----
    from pg_class c join pg_index i on c.oid = i.indexrelid
    where indrelid::regclass::text like 'idxpart%'
    order by indexrelid::regclass::text collate "C";
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- Column number mapping: dropped columns in the partition
  create table idxpart1 (drop_1 int, drop_2 int, col_keep int, drop_3 int);
***************
*** 708,731 ****
  create index on idxpart (col_keep);
  alter table idxpart attach partition idxpart1 for values from (0) to (1000);
  \d idxpart
!                Table "public.idxpart"
!   Column  |  Type   | Collation | Nullable | Default 
! ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
! Partition key: RANGE (col_keep)
! Indexes:
!     "idxpart_col_keep_idx" btree (col_keep)
! Number of partitions: 1 (Use \d+ to list them.)
! 
  \d idxpart1
!                Table "public.idxpart1"
!   Column  |  Type   | Collation | Nullable | Default 
! ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (0) TO (1000)
! Indexes:
!     "idxpart1_col_keep_idx" btree (col_keep)
! 
  select attrelid::regclass, attname, attnum from pg_attribute
    where attrelid::regclass::text like 'idxpart%' and attnum > 0
    order by attrelid::regclass, attnum;
--- 519,527 ----
  create index on idxpart (col_keep);
  alter table idxpart attach partition idxpart1 for values from (0) to (1000);
  \d idxpart
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select attrelid::regclass, attname, attnum from pg_attribute
    where attrelid::regclass::text like 'idxpart%' and attnum > 0
    order by attrelid::regclass, attnum;
***************
*** 751,774 ****
  create index on idxpart (col_keep);
  alter table idxpart attach partition idxpart1 for values from (0) to (1000);
  \d idxpart
!                Table "public.idxpart"
!   Column  |  Type   | Collation | Nullable | Default 
! ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
! Partition key: RANGE (col_keep)
! Indexes:
!     "idxpart_col_keep_idx" btree (col_keep)
! Number of partitions: 1 (Use \d+ to list them.)
! 
  \d idxpart1
!                Table "public.idxpart1"
!   Column  |  Type   | Collation | Nullable | Default 
! ----------+---------+-----------+----------+---------
!  col_keep | integer |           |          | 
! Partition of: idxpart FOR VALUES FROM (0) TO (1000)
! Indexes:
!     "idxpart1_col_keep_idx" btree (col_keep)
! 
  select attrelid::regclass, attname, attnum from pg_attribute
    where attrelid::regclass::text like 'idxpart%' and attnum > 0
    order by attrelid::regclass, attnum;
--- 547,555 ----
  create index on idxpart (col_keep);
  alter table idxpart attach partition idxpart1 for values from (0) to (1000);
  \d idxpart
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  select attrelid::regclass, attname, attnum from pg_attribute
    where attrelid::regclass::text like 'idxpart%' and attnum > 0
    order by attrelid::regclass, attnum;
***************
*** 790,805 ****
  -- Verify that it works to add primary key / unique to partitioned tables
  create table idxpart (a int primary key, b int) partition by range (a);
  \d idxpart
!               Table "public.idxpart"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
!  b      | integer |           |          | 
! Partition key: RANGE (a)
! Indexes:
!     "idxpart_pkey" PRIMARY KEY, btree (a)
! Number of partitions: 0
! 
  -- multiple primary key on child should fail
  create table failpart partition of idxpart (b primary key) for values from (0) to (100);
  ERROR:  multiple primary keys for table "failpart" are not allowed
--- 571,577 ----
  -- Verify that it works to add primary key / unique to partitioned tables
  create table idxpart (a int primary key, b int) partition by range (a);
  \d idxpart
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  -- multiple primary key on child should fail
  create table failpart partition of idxpart (b primary key) for values from (0) to (100);
  ERROR:  multiple primary keys for table "failpart" are not allowed
***************
*** 808,821 ****
  create table idxpart (a int) partition by range (a);
  create table idxpart1pk partition of idxpart (a primary key) for values from (0) to (100);
  \d idxpart1pk
!              Table "public.idxpart1pk"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
! Partition of: idxpart FOR VALUES FROM (0) TO (100)
! Indexes:
!     "idxpart1pk_pkey" PRIMARY KEY, btree (a)
! 
  drop table idxpart;
  -- Failing to use the full partition key is not allowed
  create table idxpart (a int unique, b int) partition by range (a, b);
--- 580,586 ----
  create table idxpart (a int) partition by range (a);
  create table idxpart1pk partition of idxpart (a primary key) for values from (0) to (100);
  \d idxpart1pk
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- Failing to use the full partition key is not allowed
  create table idxpart (a int unique, b int) partition by range (a, b);
***************
*** 852,880 ****
  DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
  alter table idxpart add primary key (a, b);	-- this works
  \d idxpart
!               Table "public.idxpart"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
!  b      | integer |           | not null | 
!  c      | text    |           |          | 
! Partition key: RANGE (a, b)
! Indexes:
!     "idxpart_pkey" PRIMARY KEY, btree (a, b)
! Number of partitions: 0
! 
  create table idxpart1 partition of idxpart for values from (0, 0) to (1000, 1000);
  \d idxpart1
!               Table "public.idxpart1"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           | not null | 
!  b      | integer |           | not null | 
!  c      | text    |           |          | 
! Partition of: idxpart FOR VALUES FROM (0, 0) TO (1000, 1000)
! Indexes:
!     "idxpart1_pkey" PRIMARY KEY, btree (a, b)
! 
  drop table idxpart;
  -- use ALTER TABLE to add a unique constraint
  create table idxpart (a int, b int) partition by range (a, b);
--- 617,626 ----
  DETAIL:  PRIMARY KEY constraint on table "idxpart" lacks column "b" which is part of the partition key.
  alter table idxpart add primary key (a, b);	-- this works
  \d idxpart
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  create table idxpart1 partition of idxpart for values from (0, 0) to (1000, 1000);
  \d idxpart1
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- use ALTER TABLE to add a unique constraint
  create table idxpart (a int, b int) partition by range (a, b);
***************
*** 883,898 ****
  DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
  alter table idxpart add unique (b, a);		-- this works
  \d idxpart
!               Table "public.idxpart"
!  Column |  Type   | Collation | Nullable | Default 
! --------+---------+-----------+----------+---------
!  a      | integer |           |          | 
!  b      | integer |           |          | 
! Partition key: RANGE (a, b)
! Indexes:
!     "idxpart_b_a_key" UNIQUE CONSTRAINT, btree (b, a)
! Number of partitions: 0
! 
  drop table idxpart;
  -- Exclusion constraints cannot be added
  create table idxpart (a int, b int) partition by range (a);
--- 629,635 ----
  DETAIL:  UNIQUE constraint on table "idxpart" lacks column "b" which is part of the partition key.
  alter table idxpart add unique (b, a);		-- this works
  \d idxpart
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  drop table idxpart;
  -- Exclusion constraints cannot be added
  create table idxpart (a int, b int) partition by range (a);

======================================================================

*** contrib/mmts/../../src/test/regress/expected/fast_default.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/fast_default.out	CENSORED
***************
*** 61,71 ****
  -- Test a large sample of different datatypes
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT 1);
  SELECT set('t');
!  set 
! -----
!  
! (1 row)
! 
  INSERT INTO T VALUES (1), (2);
  ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT 'hello',
                ALTER COLUMN c_int SET DEFAULT 2;
--- 61,74 ----
  -- Test a large sample of different datatypes
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT 1);
  SELECT set('t');
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "UPDATE m
!   SET id = (SELECT c.relfilenode
!             FROM pg_class AS c, pg_namespace AS s
!             WHERE c.relname = tabname
!                 AND c.relnamespace = s.oid
!                 AND s.nspname = 'fast_default')"
! PL/pgSQL function set(name) line 3 at SQL statement
  INSERT INTO T VALUES (1), (2);
  ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT 'hello',
                ALTER COLUMN c_int SET DEFAULT 2;
***************
*** 159,169 ****
  (28 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Unchanged
! (1 row)
! 
  DROP TABLE T;
  -- Test expressions in the defaults
  CREATE OR REPLACE FUNCTION foo(a INT) RETURNS TEXT AS $$
--- 162,177 ----
  (28 rows)
  
  SELECT comp();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (SELECT CASE
!                WHEN m.id = c.relfilenode THEN 'Unchanged'
!                ELSE 'Rewritten'
!                END
!            FROM m, pg_class AS c, pg_namespace AS s
!            WHERE c.relname = 't'
!                AND c.relnamespace = s.oid
!                AND s.nspname = 'fast_default')"
! PL/pgSQL function comp() line 3 at RETURN
  DROP TABLE T;
  -- Test expressions in the defaults
  CREATE OR REPLACE FUNCTION foo(a INT) RETURNS TEXT AS $$
***************
*** 179,189 ****
  END; $$ LANGUAGE PLPGSQL STABLE;
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT LENGTH(foo(6)));
  SELECT set('t');
!  set 
! -----
!  
! (1 row)
! 
  INSERT INTO T VALUES (1), (2);
  ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT foo(4),
                ALTER COLUMN c_int SET DEFAULT LENGTH(foo(8));
--- 187,200 ----
  END; $$ LANGUAGE PLPGSQL STABLE;
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY, c_int INT DEFAULT LENGTH(foo(6)));
  SELECT set('t');
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "UPDATE m
!   SET id = (SELECT c.relfilenode
!             FROM pg_class AS c, pg_namespace AS s
!             WHERE c.relname = tabname
!                 AND c.relnamespace = s.oid
!                 AND s.nspname = 'fast_default')"
! PL/pgSQL function set(name) line 3 at SQL statement
  INSERT INTO T VALUES (1), (2);
  ALTER TABLE T ADD COLUMN c_bpchar BPCHAR(5) DEFAULT foo(4),
                ALTER COLUMN c_int SET DEFAULT LENGTH(foo(8));
***************
*** 239,286 ****
  (16 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Unchanged
! (1 row)
! 
  DROP TABLE T;
  DROP FUNCTION foo(INT);
  -- Fall back to full rewrite for volatile expressions
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
  INSERT INTO T VALUES (1);
  SELECT set('t');
!  set 
! -----
!  
! (1 row)
! 
  -- now() is stable, because it returns the transaction timestamp
  ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
  SELECT comp();
!    comp    
! -----------
!  Unchanged
! (1 row)
! 
  -- clock_timestamp() is volatile
  ALTER TABLE T ADD COLUMN c2 TIMESTAMP DEFAULT clock_timestamp();
  NOTICE:  rewriting table t for reason 2
  SELECT comp();
!    comp    
! -----------
!  Rewritten
! (1 row)
! 
  DROP TABLE T;
  -- Simple querie
  CREATE TABLE T (pk INT NOT NULL PRIMARY KEY);
  SELECT set('t');
!  set 
! -----
!  
! (1 row)
! 
  INSERT INTO T SELECT * FROM generate_series(1, 10) a;
  ALTER TABLE T ADD COLUMN c_bigint BIGINT NOT NULL DEFAULT -1;
  INSERT INTO T SELECT b, b - 10 FROM generate_series(11, 20) a(b);
--- 250,318 ----
  (16 rows)
  
  SELECT comp();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (SELECT CASE
!                WHEN m.id = c.relfilenode THEN 'Unchanged'
!                ELSE 'Rewritten'
!                END
!            FROM m, pg_class AS c, pg_namespace AS s
!            WHERE c.relname = 't'
!                AND c.relnamespace = s.oid
!                AND s.nspname = 'fast_default')"
! PL/pgSQL function comp() line 3 at RETURN
  DROP TABLE T;
  DROP FUNCTION foo(INT);
  -- Fall back to full rewrite for volatile expressions
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
  INSERT INTO T VALUES (1);
  SELECT set('t');
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "UPDATE m
!   SET id = (SELECT c.relfilenode
!             FROM pg_class AS c, pg_namespace AS s
!             WHERE c.relname = tabname
!                 AND c.relnamespace = s.oid
!                 AND s.nspname = 'fast_default')"
! PL/pgSQL function set(name) line 3 at SQL statement
  -- now() is stable, because it returns the transaction timestamp
  ALTER TABLE T ADD COLUMN c1 TIMESTAMP DEFAULT now();
  SELECT comp();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (SELECT CASE
!                WHEN m.id = c.relfilenode THEN 'Unchanged'
!                ELSE 'Rewritten'
!                END
!            FROM m, pg_class AS c, pg_namespace AS s
!            WHERE c.relname = 't'
!                AND c.relnamespace = s.oid
!                AND s.nspname = 'fast_default')"
! PL/pgSQL function comp() line 3 at RETURN
  -- clock_timestamp() is volatile
  ALTER TABLE T ADD COLUMN c2 TIMESTAMP DEFAULT clock_timestamp();
  NOTICE:  rewriting table t for reason 2
  SELECT comp();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (SELECT CASE
!                WHEN m.id = c.relfilenode THEN 'Unchanged'
!                ELSE 'Rewritten'
!                END
!            FROM m, pg_class AS c, pg_namespace AS s
!            WHERE c.relname = 't'
!                AND c.relnamespace = s.oid
!                AND s.nspname = 'fast_default')"
! PL/pgSQL function comp() line 3 at RETURN
  DROP TABLE T;
  -- Simple querie
  CREATE TABLE T (pk INT NOT NULL PRIMARY KEY);
  SELECT set('t');
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "UPDATE m
!   SET id = (SELECT c.relfilenode
!             FROM pg_class AS c, pg_namespace AS s
!             WHERE c.relname = tabname
!                 AND c.relnamespace = s.oid
!                 AND s.nspname = 'fast_default')"
! PL/pgSQL function set(name) line 3 at SQL statement
  INSERT INTO T SELECT * FROM generate_series(1, 10) a;
  ALTER TABLE T ADD COLUMN c_bigint BIGINT NOT NULL DEFAULT -1;
  INSERT INTO T SELECT b, b - 10 FROM generate_series(11, 20) a(b);
***************
*** 451,470 ****
  (9 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Unchanged
! (1 row)
! 
  DROP TABLE T;
  -- Combine with other DDL
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
  SELECT set('t');
!  set 
! -----
!  
! (1 row)
! 
  INSERT INTO T VALUES (1), (2);
  ALTER TABLE T ADD COLUMN c_int INT NOT NULL DEFAULT -1;
  INSERT INTO T VALUES (3), (4);
--- 483,510 ----
  (9 rows)
  
  SELECT comp();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (SELECT CASE
!                WHEN m.id = c.relfilenode THEN 'Unchanged'
!                ELSE 'Rewritten'
!                END
!            FROM m, pg_class AS c, pg_namespace AS s
!            WHERE c.relname = 't'
!                AND c.relnamespace = s.oid
!                AND s.nspname = 'fast_default')"
! PL/pgSQL function comp() line 3 at RETURN
  DROP TABLE T;
  -- Combine with other DDL
  CREATE TABLE T(pk INT NOT NULL PRIMARY KEY);
  SELECT set('t');
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "UPDATE m
!   SET id = (SELECT c.relfilenode
!             FROM pg_class AS c, pg_namespace AS s
!             WHERE c.relname = tabname
!                 AND c.relnamespace = s.oid
!                 AND s.nspname = 'fast_default')"
! PL/pgSQL function set(name) line 3 at SQL statement
  INSERT INTO T VALUES (1), (2);
  ALTER TABLE T ADD COLUMN c_int INT NOT NULL DEFAULT -1;
  INSERT INTO T VALUES (3), (4);
***************
*** 500,510 ****
  (6 rows)
  
  SELECT comp();
!    comp    
! -----------
!  Unchanged
! (1 row)
! 
  -- query to exercise expand_tuple function
  CREATE TABLE t1 AS
  SELECT 1::int AS a , 2::int AS b
--- 540,555 ----
  (6 rows)
  
  SELECT comp();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (SELECT CASE
!                WHEN m.id = c.relfilenode THEN 'Unchanged'
!                ELSE 'Rewritten'
!                END
!            FROM m, pg_class AS c, pg_namespace AS s
!            WHERE c.relname = 't'
!                AND c.relnamespace = s.oid
!                AND s.nspname = 'fast_default')"
! PL/pgSQL function comp() line 3 at RETURN
  -- query to exercise expand_tuple function
  CREATE TABLE t1 AS
  SELECT 1::int AS a , 2::int AS b

======================================================================

*** contrib/mmts/../../src/test/regress/expected/stats.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/stats.out	CENSORED
***************
*** 154,175 ****
  \c -
  -- wait for stats collector to update
  SELECT wait_for_stats();
!  wait_for_stats 
! ----------------
!  
! (1 row)
! 
  -- check effects
  SELECT relname, n_tup_ins, n_tup_upd, n_tup_del, n_live_tup, n_dead_tup
    FROM pg_stat_user_tables
   WHERE relname like 'trunc_stats_test%' order by relname;
        relname      | n_tup_ins | n_tup_upd | n_tup_del | n_live_tup | n_dead_tup 
  -------------------+-----------+-----------+-----------+------------+------------
!  trunc_stats_test  |         3 |         0 |         0 |          0 |          0
!  trunc_stats_test1 |         4 |         2 |         1 |          1 |          0
!  trunc_stats_test2 |         1 |         0 |         0 |          1 |          0
!  trunc_stats_test3 |         4 |         0 |         0 |          2 |          2
!  trunc_stats_test4 |         2 |         0 |         0 |          0 |          2
  (5 rows)
  
  SELECT st.seq_scan >= pr.seq_scan + 1,
--- 154,174 ----
  \c -
  -- wait for stats collector to update
  SELECT wait_for_stats();
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
! CONTEXT:  SQL statement "SELECT (st.seq_scan >= pr.seq_scan + 1)                     FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
!      WHERE st.relname='tenk2' AND cl.relname='tenk2'"
! PL/pgSQL function wait_for_stats() line 18 at SQL statement
  -- check effects
  SELECT relname, n_tup_ins, n_tup_upd, n_tup_del, n_live_tup, n_dead_tup
    FROM pg_stat_user_tables
   WHERE relname like 'trunc_stats_test%' order by relname;
        relname      | n_tup_ins | n_tup_upd | n_tup_del | n_live_tup | n_dead_tup 
  -------------------+-----------+-----------+-----------+------------+------------
!  trunc_stats_test  |         0 |         0 |         0 |          0 |          0
!  trunc_stats_test1 |         0 |         0 |         0 |          0 |          0
!  trunc_stats_test2 |         0 |         0 |         0 |          0 |          0
!  trunc_stats_test3 |         0 |         0 |         0 |          0 |          0
!  trunc_stats_test4 |         0 |         0 |         0 |          0 |          0
  (5 rows)
  
  SELECT st.seq_scan >= pr.seq_scan + 1,
***************
*** 178,202 ****
         st.idx_tup_fetch >= pr.idx_tup_fetch + 1
    FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
   WHERE st.relname='tenk2' AND cl.relname='tenk2';
!  ?column? | ?column? | ?column? | ?column? 
! ----------+----------+----------+----------
!  t        | t        | t        | t
! (1 row)
! 
  SELECT st.heap_blks_read + st.heap_blks_hit >= pr.heap_blks + cl.relpages,
         st.idx_blks_read + st.idx_blks_hit >= pr.idx_blks + 1
    FROM pg_statio_user_tables AS st, pg_class AS cl, prevstats AS pr
   WHERE st.relname='tenk2' AND cl.relname='tenk2';
!  ?column? | ?column? 
! ----------+----------
!  t        | t
! (1 row)
! 
  SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer
  FROM prevstats AS pr;
   snapshot_newer 
  ----------------
!  t
  (1 row)
  
  DROP TABLE trunc_stats_test, trunc_stats_test1, trunc_stats_test2, trunc_stats_test3, trunc_stats_test4;
--- 177,193 ----
         st.idx_tup_fetch >= pr.idx_tup_fetch + 1
    FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
   WHERE st.relname='tenk2' AND cl.relname='tenk2';
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  SELECT st.heap_blks_read + st.heap_blks_hit >= pr.heap_blks + cl.relpages,
         st.idx_blks_read + st.idx_blks_hit >= pr.idx_blks + 1
    FROM pg_statio_user_tables AS st, pg_class AS cl, prevstats AS pr
   WHERE st.relname='tenk2' AND cl.relname='tenk2';
! ERROR:  column "........pg.dropped.1........" of relation "pg_class" does not exist
  SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer
  FROM prevstats AS pr;
   snapshot_newer 
  ----------------
!  f
  (1 row)
  
  DROP TABLE trunc_stats_test, trunc_stats_test1, trunc_stats_test2, trunc_stats_test3, trunc_stats_test4;

======================================================================

