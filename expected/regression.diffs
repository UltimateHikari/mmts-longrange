*** contrib/mmts/../../src/test/regress/expected/opr_sanity.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/opr_sanity.out	CENSORED
***************
*** 871,877 ****
   xml               | text              |        0 | a
   xml               | character varying |        0 | a
   xml               | character         |        0 | a
! (9 rows)
  
  -- **************** pg_conversion ****************
  -- Look for illegal values in pg_conversion fields.
--- 871,878 ----
   xml               | text              |        0 | a
   xml               | character varying |        0 | a
   xml               | character         |        0 | a
!  pg_lsn            | bigint            |        0 | e
! (10 rows)
  
  -- **************** pg_conversion ****************
  -- Look for illegal values in pg_conversion fields.

======================================================================

*** contrib/mmts/../../src/test/regress/expected/create_table.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/create_table.out	CENSORED
***************
*** 265,281 ****
  DROP TABLE as_select1;
  PREPARE select1 AS SELECT 1 as a;
  CREATE TABLE as_select1 AS EXECUTE select1;
  CREATE TABLE as_select1 AS EXECUTE select1;
! ERROR:  relation "as_select1" already exists
  SELECT * FROM as_select1;
!  a 
! ---
!  1
! (1 row)
! 
  CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
! NOTICE:  relation "as_select1" already exists, skipping
  DROP TABLE as_select1;
  DEALLOCATE select1;
  -- create an extra wide table to test for issues related to that
  -- (temporarily hide query, to avoid the long CREATE TABLE stmt)
--- 265,281 ----
  DROP TABLE as_select1;
  PREPARE select1 AS SELECT 1 as a;
  CREATE TABLE as_select1 AS EXECUTE select1;
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  CREATE TABLE as_select1 AS EXECUTE select1;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT * FROM as_select1;
! ERROR:  relation "as_select1" does not exist
! LINE 1: SELECT * FROM as_select1;
!                       ^
  CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
! ERROR:  [multimaster] failed to prepare transaction at peer node
  DROP TABLE as_select1;
+ ERROR:  table "as_select1" does not exist
  DEALLOCATE select1;
  -- create an extra wide table to test for issues related to that
  -- (temporarily hide query, to avoid the long CREATE TABLE stmt)

======================================================================

*** contrib/mmts/../../src/test/regress/expected/create_index.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/create_index.out	CENSORED
***************
*** 2655,2685 ****
  CREATE TABLE concur_heap (f1 text, f2 text);
  -- empty table
  CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
  CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
! NOTICE:  relation "concur_index1" already exists, skipping
  INSERT INTO concur_heap VALUES  ('a','b');
  INSERT INTO concur_heap VALUES  ('b','b');
  -- unique index
  CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
  CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
! NOTICE:  relation "concur_index2" already exists, skipping
  -- check if constraint is set up properly to be enforced
  INSERT INTO concur_heap VALUES ('b','x');
- ERROR:  duplicate key value violates unique constraint "concur_index2"
- DETAIL:  Key (f1)=(b) already exists.
  -- check if constraint is enforced properly at build time
  CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
! ERROR:  could not create unique index "concur_index3"
! DETAIL:  Key (f2)=(b) is duplicated.
  -- test that expression indexes and partial indexes work concurrently
  CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
  CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
  -- here we also check that you can default the index name
  CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
  -- You can't do a concurrent index build in a transaction
  BEGIN;
  CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
! ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
  COMMIT;
  -- But you can do a regular index build in a transaction
  BEGIN;
--- 2655,2687 ----
  CREATE TABLE concur_heap (f1 text, f2 text);
  -- empty table
  CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
! ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  INSERT INTO concur_heap VALUES  ('a','b');
  INSERT INTO concur_heap VALUES  ('b','b');
  -- unique index
  CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
! ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  -- check if constraint is set up properly to be enforced
  INSERT INTO concur_heap VALUES ('b','x');
  -- check if constraint is enforced properly at build time
  CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
! ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  -- test that expression indexes and partial indexes work concurrently
  CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  -- here we also check that you can default the index name
  CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  -- You can't do a concurrent index build in a transaction
  BEGIN;
  CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
! ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  COMMIT;
  -- But you can do a regular index build in a transaction
  BEGIN;
***************
*** 2688,2695 ****
  -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
  VACUUM FULL concur_heap;
  REINDEX TABLE concur_heap;
- ERROR:  could not create unique index "concur_index3"
- DETAIL:  Key (f2)=(b) is duplicated.
  DELETE FROM concur_heap WHERE f1 = 'b';
  VACUUM FULL concur_heap;
  \d concur_heap
--- 2690,2695 ----
***************
*** 2699,2710 ****
   f1     | text |           |          | 
   f2     | text |           |          | 
  Indexes:
-     "concur_index2" UNIQUE, btree (f1)
-     "concur_index3" UNIQUE, btree (f2) INVALID
-     "concur_heap_expr_idx" btree ((f2 || f1))
-     "concur_index1" btree (f2, f1)
-     "concur_index4" btree (f2) WHERE f1 = 'a'::text
-     "concur_index5" btree (f2) WHERE f1 = 'x'::text
      "std_index" btree (f2)
  
  REINDEX TABLE concur_heap;
--- 2699,2704 ----
***************
*** 2715,2726 ****
   f1     | text |           |          | 
   f2     | text |           |          | 
  Indexes:
-     "concur_index2" UNIQUE, btree (f1)
-     "concur_index3" UNIQUE, btree (f2)
-     "concur_heap_expr_idx" btree ((f2 || f1))
-     "concur_index1" btree (f2, f1)
-     "concur_index4" btree (f2) WHERE f1 = 'a'::text
-     "concur_index5" btree (f2) WHERE f1 = 'x'::text
      "std_index" btree (f2)
  
  -- Temporary tables with concurrent builds and on-commit actions
--- 2709,2714 ----
***************
*** 2730,2736 ****
--- 2718,2726 ----
    ON COMMIT PRESERVE ROWS;
  INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
  CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  DROP INDEX CONCURRENTLY concur_temp_ind;
+ ERROR:  index "concur_temp_ind" does not exist
  DROP TABLE concur_temp;
  -- ON COMMIT DROP
  BEGIN;
***************
*** 2739,2757 ****
  INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
  -- Fails when running in a transaction.
  CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
! ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
  COMMIT;
  -- ON COMMIT DELETE ROWS
  CREATE TEMP TABLE concur_temp (f1 int, f2 text)
    ON COMMIT DELETE ROWS;
  INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
  CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
  DROP INDEX CONCURRENTLY concur_temp_ind;
  DROP TABLE concur_temp;
  --
  -- Try some concurrent index drops
  --
  DROP INDEX CONCURRENTLY "concur_index2";				-- works
  DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
  NOTICE:  index "concur_index2" does not exist, skipping
  -- failures
--- 2729,2750 ----
  INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
  -- Fails when running in a transaction.
  CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
! ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  COMMIT;
  -- ON COMMIT DELETE ROWS
  CREATE TEMP TABLE concur_temp (f1 int, f2 text)
    ON COMMIT DELETE ROWS;
  INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
  CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  DROP INDEX CONCURRENTLY concur_temp_ind;
+ ERROR:  index "concur_temp_ind" does not exist
  DROP TABLE concur_temp;
  --
  -- Try some concurrent index drops
  --
  DROP INDEX CONCURRENTLY "concur_index2";				-- works
+ ERROR:  index "concur_index2" does not exist
  DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
  NOTICE:  index "concur_index2" does not exist, skipping
  -- failures
***************
*** 2763,2772 ****
--- 2756,2770 ----
  ROLLBACK;
  -- successes
  DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
+ NOTICE:  index "concur_index3" does not exist, skipping
  DROP INDEX CONCURRENTLY "concur_index4";
+ ERROR:  index "concur_index4" does not exist
  DROP INDEX CONCURRENTLY "concur_index5";
+ ERROR:  index "concur_index5" does not exist
  DROP INDEX CONCURRENTLY "concur_index1";
+ ERROR:  index "concur_index1" does not exist
  DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
+ ERROR:  index "concur_heap_expr_idx" does not exist
  \d concur_heap
             Table "public.concur_heap"
   Column | Type | Collation | Nullable | Default 

======================================================================

*** contrib/mmts/../../src/test/regress/expected/index_including.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/index_including.out	CENSORED
***************
*** 291,302 ****
  CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
  INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,1000) AS x;
  CREATE UNIQUE INDEX CONCURRENTLY on tbl (c1, c2) INCLUDE (c3, c4);
  SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
                                            indexdef                                           
  ---------------------------------------------------------------------------------------------
-  CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_idx ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
   CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
! (2 rows)
  
  DROP TABLE tbl;
  /*
--- 291,302 ----
  CREATE TABLE tbl (c1 int,c2 int, c3 int, c4 box, UNIQUE(c1, c2) INCLUDE(c3,c4));
  INSERT INTO tbl SELECT x, 2*x, 3*x, box('4,4,4,4') FROM generate_series(1,1000) AS x;
  CREATE UNIQUE INDEX CONCURRENTLY on tbl (c1, c2) INCLUDE (c3, c4);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  SELECT indexdef FROM pg_indexes WHERE tablename = 'tbl' ORDER BY indexname;
                                            indexdef                                           
  ---------------------------------------------------------------------------------------------
   CREATE UNIQUE INDEX tbl_c1_c2_c3_c4_key ON public.tbl USING btree (c1, c2) INCLUDE (c3, c4)
! (1 row)
  
  DROP TABLE tbl;
  /*

======================================================================

*** contrib/mmts/../../src/test/regress/expected/constraints.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/constraints.out	CENSORED
***************
*** 740,758 ****
  ERROR:  duplicate key value violates unique constraint "must_be_different"
  DETAIL:  Key (a)=(2) already exists.
  CREATE UNIQUE INDEX CONCURRENTLY must_be_different_new ON constraint_alter_index USING BTREE(a);
  ALTER TABLE constraint_alter_index ALTER CONSTRAINT must_be_different USING INDEX must_be_different_new;
! NOTICE:  ALTER TABLE / ALTER CONSTRAINT USING INDEX will rename constraint "must_be_different" to "must_be_different_new"
  DROP INDEX must_be_different;
  DROP INDEX must_be_different_new; -- failure here
! ERROR:  cannot drop index must_be_different_new because constraint must_be_different_new on table constraint_alter_index requires it
! HINT:  You can drop constraint must_be_different_new on table constraint_alter_index instead.
  INSERT INTO  constraint_alter_index VALUES(2, 3); -- failure here
! ERROR:  duplicate key value violates unique constraint "must_be_different_new"
  DETAIL:  Key (a)=(2) already exists.
  INSERT INTO  constraint_alter_index VALUES(3, 3);
  CREATE INDEX CONCURRENTLY must_be_different_new2 ON constraint_alter_index USING BTREE(a);
  ALTER TABLE constraint_alter_index ALTER CONSTRAINT must_be_different_new USING INDEX must_be_different_new2;
! ERROR:  index in constraint must_be_different_new cannot be replaced by must_be_different_new2
  DROP TABLE constraint_alter_index;
  DROP ROLE regress_constraint_comments;
  DROP ROLE regress_constraint_comments_noaccess;
--- 740,761 ----
  ERROR:  duplicate key value violates unique constraint "must_be_different"
  DETAIL:  Key (a)=(2) already exists.
  CREATE UNIQUE INDEX CONCURRENTLY must_be_different_new ON constraint_alter_index USING BTREE(a);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  ALTER TABLE constraint_alter_index ALTER CONSTRAINT must_be_different USING INDEX must_be_different_new;
! ERROR:  cannot find index "must_be_different_new"
  DROP INDEX must_be_different;
+ ERROR:  cannot drop index must_be_different because constraint must_be_different on table constraint_alter_index requires it
+ HINT:  You can drop constraint must_be_different on table constraint_alter_index instead.
  DROP INDEX must_be_different_new; -- failure here
! ERROR:  index "must_be_different_new" does not exist
  INSERT INTO  constraint_alter_index VALUES(2, 3); -- failure here
! ERROR:  duplicate key value violates unique constraint "must_be_different"
  DETAIL:  Key (a)=(2) already exists.
  INSERT INTO  constraint_alter_index VALUES(3, 3);
  CREATE INDEX CONCURRENTLY must_be_different_new2 ON constraint_alter_index USING BTREE(a);
+ ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  ALTER TABLE constraint_alter_index ALTER CONSTRAINT must_be_different_new USING INDEX must_be_different_new2;
! ERROR:  constraint "must_be_different_new" of relation "constraint_alter_index" does not exist
  DROP TABLE constraint_alter_index;
  DROP ROLE regress_constraint_comments;
  DROP ROLE regress_constraint_comments_noaccess;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/sanity_check.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/sanity_check.out	CENSORED
***************
*** 11,16 ****
--- 11,18 ----
     FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = relnamespace
     WHERE relkind IN ('r', 'p') AND (nspname ~ '^pg_temp_') IS NOT TRUE
     ORDER BY relname;
+ _pg_publication|t
+ _pg_subscription|t
  a|f
  a_star|f
  aggtest|f
***************
*** 32,37 ****
--- 34,41 ----
  check_tbl|f
  circle_tbl|t
  city|f
+ cluster_nodes|t
+ config|t
  copy_tbl|f
  d|f
  d_star|f
***************
*** 69,74 ****
--- 73,79 ----
  iportaltest|f
  kd_point_tbl|t
  line_tbl|f
+ local_tables|t
  log_table|f
  lseg_tbl|f
  main_table|f
***************
*** 141,147 ****
  pg_pltemplate|t
  pg_policy|t
  pg_proc|t
- pg_publication|t
  pg_publication_rel|t
  pg_range|t
  pg_replication_origin|t
--- 146,151 ----
***************
*** 153,159 ****
  pg_shseclabel|t
  pg_statistic|t
  pg_statistic_ext|t
- pg_subscription|t
  pg_subscription_rel|t
  pg_tablespace|t
  pg_transform|t
--- 157,162 ----
***************
*** 175,180 ****
--- 178,184 ----
  radix_text_tbl|t
  ramp|f
  real_city|f
+ referee_decision|t
  road|t
  shighway|t
  slow_emp4000|f
***************
*** 187,192 ****
--- 191,197 ----
  sql_sizing_profiles|f
  stud_emp|f
  student|f
+ syncpoints|t
  tbl_include_box|t
  tbl_include_box_pk|f
  tbl_include_pk|t

======================================================================

*** contrib/mmts/../../src/test/regress/expected/rowsecurity.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/rowsecurity.out	CENSORED
***************
*** 113,142 ****
  (3 rows)
  
  \d document
!         Table "regress_rls_schema.document"
!  Column  |  Type   | Collation | Nullable | Default 
! ---------+---------+-----------+----------+---------
!  did     | integer |           | not null | 
!  cid     | integer |           |          | 
!  dlevel  | integer |           | not null | 
!  dauthor | name    |           |          | 
!  dtitle  | text    |           |          | 
! Indexes:
!     "document_pkey" PRIMARY KEY, btree (did)
! Foreign-key constraints:
!     "document_cid_fkey" FOREIGN KEY (cid) REFERENCES category(cid)
! Policies:
!     POLICY "p1"
!       USING ((dlevel <= ( SELECT uaccount.seclv
!    FROM uaccount
!   WHERE (uaccount.pguser = CURRENT_USER))))
!     POLICY "p1r" AS RESTRICTIVE
!       TO regress_rls_dave
!       USING ((cid <> 44))
!     POLICY "p2r" AS RESTRICTIVE
!       TO regress_rls_dave
!       USING (((cid <> 44) AND (cid < 50)))
! 
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
       schemaname     | tablename | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
  --------------------+-----------+------------+-------------+--------------------+-----+--------------------------------------------+------------
--- 113,119 ----
  (3 rows)
  
  \d document
! ERROR:  permission denied for view pg_publication
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
       schemaname     | tablename | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
  --------------------+-----------+------------+-------------+--------------------+-----+--------------------------------------------+------------
***************
*** 938,964 ****
  CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave
      USING (cid < 55);
  \d+ part_document
!                           Table "regress_rls_schema.part_document"
!  Column  |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
! ---------+---------+-----------+----------+---------+----------+--------------+-------------
!  did     | integer |           |          |         | plain    |              | 
!  cid     | integer |           |          |         | plain    |              | 
!  dlevel  | integer |           | not null |         | plain    |              | 
!  dauthor | name    |           |          |         | plain    |              | 
!  dtitle  | text    |           |          |         | extended |              | 
! Partition key: RANGE (cid)
! Policies:
!     POLICY "pp1"
!       USING ((dlevel <= ( SELECT uaccount.seclv
!    FROM uaccount
!   WHERE (uaccount.pguser = CURRENT_USER))))
!     POLICY "pp1r" AS RESTRICTIVE
!       TO regress_rls_dave
!       USING ((cid < 55))
! Partitions: part_document_fiction FOR VALUES FROM (11) TO (12),
!             part_document_nonfiction FOR VALUES FROM (99) TO (100),
!             part_document_satire FOR VALUES FROM (55) TO (56)
! 
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
       schemaname     |   tablename   | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
  --------------------+---------------+------------+-------------+--------------------+-----+--------------------------------------------+------------
--- 915,921 ----
  CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave
      USING (cid < 55);
  \d+ part_document
! ERROR:  permission denied for view pg_publication
  SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
       schemaname     |   tablename   | policyname | permissive  |       roles        | cmd |                    qual                    | with_check 
  --------------------+---------------+------------+-------------+--------------------+-----+--------------------------------------------+------------

======================================================================

*** contrib/mmts/../../src/test/regress/expected/atx.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/atx.out	CENSORED
***************
*** 1148,1153 ****
--- 1148,1154 ----
  RESET client_min_messages;
  create database regression_atx_test_database;
  ALTER DATABASE "regression_atx_test_database" SET lc_messages TO 'C';
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  \c regression_atx_test_database
  create table atx_test as select 1 as id;
  begin;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/atx5.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/atx5.out	CENSORED
***************
*** 24,33 ****
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
!  x 
! ---
! (0 rows)
! 
  SET client_min_messages = 'warning';
  DROP FUNCTION IF EXISTS atx_test_30_one();
  DROP FUNCTION IF EXISTS atx_test_30_two();
--- 24,30 ----
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
  NOTICE:  function atx_test_30_one() does not exist, skipping
! ERROR:  cannot PREPARE a transaction that has exported snapshots
  SET client_min_messages = 'warning';
  DROP FUNCTION IF EXISTS atx_test_30_one();
  DROP FUNCTION IF EXISTS atx_test_30_two();

======================================================================

*** contrib/mmts/../../src/test/regress/expected/rules.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/rules.out	CENSORED
***************
*** 1283,1288 ****
--- 1283,1297 ----
  -- temporarily disable fancy output, so view changes create less diff noise
  \a\t
  SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schema' ORDER BY viewname;
+ _pg_prepared_xacts| SELECT p.transaction,
+     p.gid,
+     p.prepared,
+     u.rolname AS owner,
+     d.datname AS database,
+     p.state3pc
+    FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
+      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
+      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
  iexit| SELECT ih.name,
      ih.thepath,
      interpt_pp(ih.thepath, r.thepath) AS exit
***************
*** 1440,1458 ****
      p.parameter_types,
      p.from_sql
     FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
! pg_prepared_xacts| SELECT p.transaction,
!     p.gid,
!     p.prepared,
!     u.rolname AS owner,
!     d.datname AS database,
!     p.state3pc
!    FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid, state3pc)
!      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
!      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
  pg_publication_tables| SELECT p.pubname,
      n.nspname AS schemaname,
      c.relname AS tablename
!    FROM pg_publication p,
      (pg_class c
       JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
    WHERE (c.oid IN ( SELECT pg_get_publication_tables.relid
--- 1449,1477 ----
      p.parameter_types,
      p.from_sql
     FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
! pg_prepared_xacts| SELECT _pg_prepared_xacts.transaction,
!     _pg_prepared_xacts.gid,
!     _pg_prepared_xacts.prepared,
!     _pg_prepared_xacts.owner,
!     _pg_prepared_xacts.database,
!     _pg_prepared_xacts.state3pc
!    FROM _pg_prepared_xacts
!   WHERE (_pg_prepared_xacts.gid !~~ 'MTM-%'::text)
!   ORDER BY ((_pg_prepared_xacts.transaction)::text)::bigint;
! pg_publication| SELECT _pg_publication.oid,
!     _pg_publication.pubname,
!     _pg_publication.pubowner,
!     _pg_publication.puballtables,
!     _pg_publication.pubinsert,
!     _pg_publication.pubupdate,
!     _pg_publication.pubdelete,
!     _pg_publication.pubtruncate
!    FROM _pg_publication
!   WHERE (_pg_publication.pubname <> 'multimaster'::name);
  pg_publication_tables| SELECT p.pubname,
      n.nspname AS schemaname,
      c.relname AS tablename
!    FROM _pg_publication p,
      (pg_class c
       JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
    WHERE (c.oid IN ( SELECT pg_get_publication_tables.relid
***************
*** 1642,1648 ****
      l.provider,
      l.label
     FROM (pg_seclabel l
!      JOIN pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))
    WHERE (l.objsubid = 0)
  UNION ALL
   SELECT l.objoid,
--- 1661,1667 ----
      l.provider,
      l.label
     FROM (pg_seclabel l
!      JOIN _pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))
    WHERE (l.objsubid = 0)
  UNION ALL
   SELECT l.objoid,
***************
*** 1654,1660 ****
      l.provider,
      l.label
     FROM (pg_shseclabel l
!      JOIN pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))
  UNION ALL
   SELECT l.objoid,
      l.classoid,
--- 1673,1679 ----
      l.provider,
      l.label
     FROM (pg_shseclabel l
!      JOIN _pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))
  UNION ALL
   SELECT l.objoid,
      l.classoid,
***************
*** 1907,1913 ****
      st.last_msg_receipt_time,
      st.latest_end_lsn,
      st.latest_end_time
!    FROM (pg_subscription su
       LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON ((st.subid = su.oid)));
  pg_stat_sys_indexes| SELECT pg_stat_all_indexes.relid,
      pg_stat_all_indexes.indexrelid,
--- 1926,1932 ----
      st.last_msg_receipt_time,
      st.latest_end_lsn,
      st.latest_end_time
!    FROM (_pg_subscription su
       LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON ((st.subid = su.oid)));
  pg_stat_sys_indexes| SELECT pg_stat_all_indexes.relid,
      pg_stat_all_indexes.indexrelid,
***************
*** 2217,2222 ****
--- 2236,2252 ----
       JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))
       LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
    WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));
+ pg_subscription| SELECT _pg_subscription.oid,
+     _pg_subscription.subdbid,
+     _pg_subscription.subname,
+     _pg_subscription.subowner,
+     _pg_subscription.subenabled,
+     _pg_subscription.subconninfo,
+     _pg_subscription.subslotname,
+     _pg_subscription.subsynccommit,
+     _pg_subscription.subpublications
+    FROM _pg_subscription
+   WHERE (_pg_subscription.subname !~~ 'mtm_sub_%'::text);
  pg_tables| SELECT n.nspname AS schemaname,
      c.relname AS tablename,
      pg_get_userbyid(c.relowner) AS tableowner,
***************
*** 2360,2365 ****
--- 2390,2403 ----
             FROM pg_control_snapshot() pg_control_snapshot(oldest_snapshot, recent_snapshot, active_snapshot)), ( SELECT pg_control_snapshot.recent_snapshot
             FROM pg_control_snapshot() pg_control_snapshot(oldest_snapshot, recent_snapshot, active_snapshot))) snap_id(snap_id)
    WHERE pg_snapshot_exists(snap_id.snap_id);
+ stat_bgwpool| SELECT node_bgwpool_stat.nworkers,
+     node_bgwpool_stat.active,
+     node_bgwpool_stat.pending,
+     node_bgwpool_stat.size,
+     node_bgwpool_stat.head,
+     node_bgwpool_stat.tail,
+     node_bgwpool_stat.receivername
+    FROM mtm.node_bgwpool_stat() node_bgwpool_stat(nworkers, active, pending, size, head, tail, receivername);
  street| SELECT r.name,
      r.thepath,
      c.cname

======================================================================

*** contrib/mmts/../../src/test/regress/expected/publication.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/publication.out	CENSORED
***************
*** 8,16 ****
  CREATE PUBLICATION testpub_default;
  COMMENT ON PUBLICATION testpub_default IS 'test publication';
  SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
!  obj_description  
! ------------------
!  test publication
  (1 row)
  
  CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);
--- 8,16 ----
  CREATE PUBLICATION testpub_default;
  COMMENT ON PUBLICATION testpub_default IS 'test publication';
  SELECT obj_description(p.oid, 'pg_publication') FROM pg_publication p;
!  obj_description 
! -----------------
!  
  (1 row)
  
  CREATE PUBLICATION testpib_ins_trunct WITH (publish = insert);

======================================================================

*** contrib/mmts/../../src/test/regress/expected/subscription.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/subscription.out	CENSORED
***************
*** 32,40 ****
  WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
  COMMENT ON SUBSCRIPTION testsub IS 'test subscription';
  SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
!   obj_description  
! -------------------
!  test subscription
  (1 row)
  
  -- fail - name already exists
--- 32,40 ----
  WARNING:  tables were not subscribed, you will have to run ALTER SUBSCRIPTION ... REFRESH PUBLICATION to subscribe the tables
  COMMENT ON SUBSCRIPTION testsub IS 'test subscription';
  SELECT obj_description(s.oid, 'pg_subscription') FROM pg_subscription s;
!  obj_description 
! -----------------
!  
  (1 row)
  
  -- fail - name already exists

======================================================================

*** contrib/mmts/../../src/test/regress/expected/prepare.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/prepare.out	CENSORED
***************
*** 124,150 ****
  	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2
  	ORDER BY unique1;
  CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
  SELECT * FROM q5_prep_results;
!  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
! ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
!      200 |    9441 |   0 |    0 |   0 |      0 |       0 |      200 |         200 |       200 |      200 |   0 |    1 | SHAAAA   | DZNAAA   | HHHHxx
!      497 |    9092 |   1 |    1 |   7 |     17 |      97 |      497 |         497 |       497 |      497 | 194 |  195 | DTAAAA   | SLNAAA   | AAAAxx
!     1173 |    6699 |   1 |    1 |   3 |     13 |      73 |      173 |        1173 |      1173 |     1173 | 146 |  147 | DTAAAA   | RXJAAA   | VVVVxx
!     1849 |    8143 |   1 |    1 |   9 |      9 |      49 |      849 |        1849 |      1849 |     1849 |  98 |   99 | DTAAAA   | FBMAAA   | VVVVxx
!     2525 |      64 |   1 |    1 |   5 |      5 |      25 |      525 |         525 |      2525 |     2525 |  50 |   51 | DTAAAA   | MCAAAA   | AAAAxx
!     3201 |    7309 |   1 |    1 |   1 |      1 |       1 |      201 |        1201 |      3201 |     3201 |   2 |    3 | DTAAAA   | DVKAAA   | HHHHxx
!     3877 |    4060 |   1 |    1 |   7 |     17 |      77 |      877 |        1877 |      3877 |     3877 | 154 |  155 | DTAAAA   | EAGAAA   | AAAAxx
!     4553 |    4113 |   1 |    1 |   3 |     13 |      53 |      553 |         553 |      4553 |     4553 | 106 |  107 | DTAAAA   | FCGAAA   | HHHHxx
!     5229 |    6407 |   1 |    1 |   9 |      9 |      29 |      229 |        1229 |       229 |     5229 |  58 |   59 | DTAAAA   | LMJAAA   | VVVVxx
!     5905 |    9537 |   1 |    1 |   5 |      5 |       5 |      905 |        1905 |       905 |     5905 |  10 |   11 | DTAAAA   | VCOAAA   | HHHHxx
!     6581 |    4686 |   1 |    1 |   1 |      1 |      81 |      581 |         581 |      1581 |     6581 | 162 |  163 | DTAAAA   | GYGAAA   | OOOOxx
!     7257 |    1895 |   1 |    1 |   7 |     17 |      57 |      257 |        1257 |      2257 |     7257 | 114 |  115 | DTAAAA   | XUCAAA   | VVVVxx
!     7933 |    4514 |   1 |    1 |   3 |     13 |      33 |      933 |        1933 |      2933 |     7933 |  66 |   67 | DTAAAA   | QRGAAA   | OOOOxx
!     8609 |    5918 |   1 |    1 |   9 |      9 |       9 |      609 |         609 |      3609 |     8609 |  18 |   19 | DTAAAA   | QTIAAA   | OOOOxx
!     9285 |    8469 |   1 |    1 |   5 |      5 |      85 |      285 |        1285 |      4285 |     9285 | 170 |  171 | DTAAAA   | TNMAAA   | HHHHxx
!     9961 |    2058 |   1 |    1 |   1 |      1 |      61 |      961 |        1961 |      4961 |     9961 | 122 |  123 | DTAAAA   | EBDAAA   | OOOOxx
! (16 rows)
! 
  -- unknown or unspecified parameter types: should succeed
  PREPARE q6 AS
      SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;
--- 124,134 ----
  	SELECT * FROM tenk1 WHERE unique1 = $1 OR stringu1 = $2
  	ORDER BY unique1;
  CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT * FROM q5_prep_results;
! ERROR:  relation "q5_prep_results" does not exist
! LINE 1: SELECT * FROM q5_prep_results;
!                       ^
  -- unknown or unspecified parameter types: should succeed
  PREPARE q6 AS
      SELECT * FROM tenk1 WHERE unique1 = $1 AND stringu1 = $2;

======================================================================

*** contrib/mmts/../../src/test/regress/expected/without_oid.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/without_oid.out	CENSORED
***************
*** 84,103 ****
  PREPARE table_source(int) AS
      SELECT a + b AS c1, a - b AS c2, $1 AS c3 FROM create_table_test;
  CREATE TABLE execute_with WITH OIDS AS EXECUTE table_source(1);
  CREATE TABLE execute_without WITHOUT OIDS AS EXECUTE table_source(2);
  SELECT count(oid) FROM execute_with;
!  count 
! -------
!      2
! (1 row)
! 
  -- should fail
  SELECT count(oid) FROM execute_without;
! ERROR:  column "oid" does not exist
  LINE 1: SELECT count(oid) FROM execute_without;
!                      ^
  DROP TABLE create_table_test;
  DROP TABLE create_table_test2;
  DROP TABLE create_table_test3;
  DROP TABLE execute_with;
  DROP TABLE execute_without;
--- 84,105 ----
  PREPARE table_source(int) AS
      SELECT a + b AS c1, a - b AS c2, $1 AS c3 FROM create_table_test;
  CREATE TABLE execute_with WITH OIDS AS EXECUTE table_source(1);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  CREATE TABLE execute_without WITHOUT OIDS AS EXECUTE table_source(2);
+ ERROR:  [multimaster] failed to prepare transaction at peer node
  SELECT count(oid) FROM execute_with;
! ERROR:  relation "execute_with" does not exist
! LINE 1: SELECT count(oid) FROM execute_with;
!                                ^
  -- should fail
  SELECT count(oid) FROM execute_without;
! ERROR:  relation "execute_without" does not exist
  LINE 1: SELECT count(oid) FROM execute_without;
!                                ^
  DROP TABLE create_table_test;
  DROP TABLE create_table_test2;
  DROP TABLE create_table_test3;
  DROP TABLE execute_with;
+ ERROR:  table "execute_with" does not exist
  DROP TABLE execute_without;
+ ERROR:  table "execute_without" does not exist

======================================================================

*** contrib/mmts/../../src/test/regress/expected/indexing.out	CENSORED
--- contrib/mmts/../../src/test/regress/results/indexing.out	CENSORED
***************
*** 27,33 ****
  create table idxpart (a int, b int, c text) partition by range (a);
  create table idxpart1 partition of idxpart for values from (0) to (10);
  create index concurrently on idxpart (a);
! ERROR:  cannot create index on partitioned table "idxpart" concurrently
  drop table idxpart;
  -- Verify bugfix with query on indexed partitioned table with no partitions
  -- https://postgr.es/m/20180124162006.pmapfiznhgngwtjf@alvherre.pgsql
--- 27,33 ----
  create table idxpart (a int, b int, c text) partition by range (a);
  create table idxpart1 partition of idxpart for values from (0) to (10);
  create index concurrently on idxpart (a);
! ERROR:  multimaster doesn't support CREATE INDEX CONCURRENTLY
  drop table idxpart;
  -- Verify bugfix with query on indexed partitioned table with no partitions
  -- https://postgr.es/m/20180124162006.pmapfiznhgngwtjf@alvherre.pgsql

======================================================================

